<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用 Node.js 把玩一番 Alfred Workflow]]></title>
    <url>%2Fposts%2F4c23be51%2F</url>
    <content type="text"><![CDATA[插件地址(集成Github、掘金、知乎、淘宝等搜索)作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。一些安利附上一张个人装着的插件的截图。Caffeinate 插件能在指定时间使电脑不黑屏；在 Dash 插件上能轻松查任何文档；Youdao Translate 插件比系统自带的翻译方便许多。插件也是因人而异，大家可以在 Workflow List 上逛逛，各取所需。在用了别人的插件感觉高大上后，便萌发了也写一个插件的想法，计划把自己常逛的网站集合成一个插件，使用特定的缩略词便可快速进行搜索数据，又看了官方称可以使用 bash, zsh, PHP, Ruby, Python, Perl, Apple Script 开发 Alfred Workflow。于是我选择了 Node.js 作为开发语言，开发了一款 commonSearch, 开发完效果如下(集成了Github、掘金、知乎、淘宝等搜索)。开发阶段在开发前，得先对一些特定的操作步骤和知识点有一定的认知，这样开发时就基本上没有大碍了。前置步骤可以先参考 如何去写一个第三方的 workflow 的开始部分, 完成基本工作流的搭建，如下图是我搭建好的基本工作流连线。在 Script 中，可以看到 /usr/local/bin/node common_search.js 相当于就是在调用该插件的时候起了一个 node 服务，后面的 1 是为了区分当前调用的是哪个搜索手动传入 common_search.js 的，{query} 则是用户查询的名称。使用 Node.js 调用 JSON API最初开发参考了 知乎搜索 这个项目，它是基于 cheerio 这个模块对请求到的网页数据进行分析爬取，但是引入了 cheerio 后，插件体积多了 2M 多，这对于一个插件来说太不友好了，所以这可能是 python 之类的语言更适合开发类似插件的原因吧(猜想:python 不需要引人第三方库就能进行爬虫)，于是我开始选择提供 JSON API 的接口，比如找寻掘金返回数据的接口。首先打开 chrome 控制台，这可能对前端工程师比较熟悉了。从而找到了掘金返回搜索数据的接口是 https://search-merger-ms.juejin.im/v1/search?query={query}&amp;page=0&amp;raw_result=false&amp;src=web接着愉快地使用 node 提供的 https 模块，这里有一个注意点，http.get() 回调中的 res 参数不是正文，而是 http.ClientResponse 对象，所以我们需要组装内容。12345678910111213141516171819202122232425262728293031var options = &#123; host: 'search-merger-ms.juejin.im', path: '/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web' &#125; https.get(options, function (res) &#123; res.on('data', (chunk) =&gt; &#123; var content += chunk &#125;).on('end', function () &#123; var jsonContent = JSON.parse(content) &amp;&amp; JSON.parse(content).d var result_array = [] for (var i = 0; i &lt; jsonContent.length; i++) &#123; if (jsonContent[i].user.jobTitle === '') &#123; result_array.push(&#123; title: subtitle: arg: icon: &#123; path: join(__dirname, 'xx.png'), &#125;, mods: &#123; cmd: &#123;&#125; &#125; &#125;) &#125; &#125; content = '' console.log(JSON.stringify(&#123; items: result_array &#125;)) &#125;) &#125;)这种方法应该是最直接的调用 JSON API 的方案了，当然也可以引人第三方模块 request 后解析 JSON，示例如下：123456789101112131415161718var request = require('request')var url = 'search-merger-ms.juejin.im/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web'request.get(&#123; url: url, json: true, headers: &#123;'User-Agent': 'request'&#125; &#125;, (err, res, data) =&gt; &#123; if (err) &#123; console.log('Error:', err); &#125; else if (res.statusCode !== 200) &#123; console.log('Status:', res.statusCode); &#125; else &#123; // data is already parsed as JSON: console.log(data.html_url); &#125;&#125;);还有一点要注意的是返回值的字段是固定的，具体可以参考它的官方解释，琢磨了好久才把 JS 中的 Icon 自定义的格式找出来。12345title: 主标题subtitle: 内容行arg: 跳转链接icons: 图标mods：定制键盘按键的方法对于 Github、掘金、知乎、淘宝的搜索都是基于以上思路进行开发的，就是对于具体返回的 JSON 数据进行了不同处理，虽然粗糙，但也算完成了第一个 Alfred Workflow 插件的开发。尾声本文的知识点写的不是特别丰满，一是就是对开发这个插件的小结，另外就是抛砖引玉了，能让更多的小伙伴了解开发一个插件并不是难事，同时让更多的朋友开发出更多有意义，有趣的 alfred-workflow 插件也算是本文分享的一个初衷了。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>alfred workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 JavaScript 到 TypeScript]]></title>
    <url>%2Fposts%2F66a54fc2%2F</url>
    <content type="text"><![CDATA[文中的案例代码已经上传到 TypeScriptTypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。TypeScript 简介TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。使用 TypeScript 的原因JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~)数据类型String 类型一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。12let name: string = 'muyy'let name2: String = 'muyy'Boolen 类型boolean是 true 或 false 的值，所以 let isBool3: boolean = new Boolean(1) 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。1let isBool1: boolean = falseNumber 类型1let number: number = 10;Array 类型数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 Array&lt;type&gt; or type[] 语法为数组内的元素指定类型12345let arr:number[] = [1, 2, 3, 4, 5];let arr2:Array&lt;number&gt; = [1, 2, 3, 4, 5];let arr3:string[] = ["1","2"];let arr4:Array&lt;string&gt; = ["1","2"];Enums 类型列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：123enum Role &#123;Employee = 3, Manager, Admin&#125;let role: Role = Role.Employeeconsole.log(role) // 3Any 类型any 是默认的类型，其类型的变量允许任何类型的值：12let notSure:any = 10;let notSure2:any[] = [1,"2",false];Void 类型JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：123function alertName(): void &#123; console.log('My name is muyy')&#125;函数为函数定义类型我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。1234567891011function add(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add2 = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add3: (x: string, y: string) =&gt; string = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125;可选参数和默认参数JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：1234567function buildName(firstName: string, lastname?: string)&#123; console.log(lastname ? firstName + "" + lastname : firstName)&#125;let res1 = buildName("鸣","人"); // 鸣人let res2 = buildName("鸣"); // 鸣let res3 = buildName("鸣", "人", "君"); // Supplied parameters do not match any signature of call target.如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：123456function buildName2(firstName = "鸣", lastName?: string)&#123; console.log(firstName + "" + lastName)&#125;let res4 = buildName2("人"); // undefined人let res5 = buildName2(undefined, "人"); // 鸣人类传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。类1234567891011121314class Person&#123; name:string; // 这个是对后文this.name类型的定义 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; print()&#123; return this.name + this.age; &#125;&#125;let person:Person = new Person('muyy',23)console.log(person.print()) // muyy23我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。继承12345678910111213141516171819202122232425class Person&#123; public name:string; // public、private、static 是 typescript 中的类访问修饰符 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; tell()&#123; console.log(this.name + this.age); &#125;&#125;class Student extends Person&#123; gender:string; constructor(gender:string)&#123; super("muyy",23); this.gender = gender; &#125; tell()&#123; console.log(this.name + this.age + this.gender); &#125;&#125;var student = new Student("male");student.tell(); // muyy23male这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。存储器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。对于存取器有下面几点需要注意的：首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。12345678910111213141516171819202122232425class Hello&#123; private _name: string; private _age: number; get name(): string &#123; return this._name; &#125; set name(value: string) &#123; this._name = value; &#125; get age(): number&#123; return this._age; &#125; set age(age: number) &#123; if(age&gt;0 &amp;&amp; age&lt;100)&#123; console.log("年龄在0-100之间"); // 年龄在0-100之间 return; &#125; this._age = age; &#125;&#125;let hello = new Hello();hello.name = "muyy";hello.age = 23console.log(hello.name); // muyy接口接口TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。123456789101112interface LabelValue&#123; label: string;&#125;function printLabel(labelObj: LabelValue)&#123; console.log(labelObj.label);&#125;let myObj = &#123; "label":"hello Interface"&#125;;printLabel(myObj);LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。可选属性带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。123456789101112131415161718192021interface Person&#123; name?:string; age?:number;&#125;function printInfo(info:Person)&#123; console.log(info);&#125;let info = &#123; "name":"muyy", "age":23&#125;;printInfo(info); // &#123;"name": "muyy", "age": 23&#125;let info2 = &#123; "name":"muyy"&#125;;printInfo(info2); // &#123;"name": "muyy"&#125;函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。1234567891011interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string,subString: string)&#123; return source.search(subString) !== -1;&#125;;console.log(mySearch("鸣人","鸣")); // trueconsole.log(mySearch("鸣人","缨")); // false可索引类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[&quot;daniel&quot;]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：1234567interface StringArray&#123; [index: number]: string;&#125;let MyArray: StringArray;MyArray = ["是","云","随","风"];console.log(MyArray[2]); // 随类类型与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。我们可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样：123456789101112interface ClockInterface&#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface&#123; currentTime: Date; setTime(d: Date)&#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125;继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。12345678910111213141516interface Shape&#123; color: string;&#125;interface PenStroke&#123; penWidth: number;&#125;interface Square extends Shape,PenStroke&#123; sideLength: number;&#125;let s = &lt;Square&gt;&#123;&#125;;s.color = "blue";s.penWidth = 100;s.sideLength = 10;模块TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。123456789101112131415161718export interface StringValidator&#123; isAcceptable(s:string): boolean;&#125;var strReg = /^[A-Za-z]+$/;var numReg = /^[0-9]+$/;export class letterValidator implements StringValidator&#123; isAcceptable(s:string): boolean&#123; return strReg.test(s); &#125;&#125;export class zipCode implements StringValidator&#123; isAcceptable(s: string): boolean&#123; return s.length == 5 &amp;&amp; numReg.test(s); &#125;&#125;泛型软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。初探泛型如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 output 和 output2 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：123456789function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;let outPut = Hello&lt;string&gt;('Hello Generic');let output2 = Hello('Hello Generic')console.log(outPut);console.log(outPut2);参考资料TypeScript 中文文档TypeScriptTypeScript for Angular 2 - Part 1 (An Introduction)]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 在服务端渲染的实现]]></title>
    <url>%2Fposts%2F2d678a6%2F</url>
    <content type="text"><![CDATA[原文地址：Server-Side React RenderingReact是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？React 在服务端渲染的实现假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。服务端渲染的优势可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。入门接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了相关代码，您可以在其中看到完整的示例。提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 ButterCMS 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以使用你的 GitHub 账号登入 ButterCMS。1234567891011121314151617181920212223242526272829303132333435import React from 'react';import Butter from 'buttercms'const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; getInitialState: function() &#123; return &#123;loaded: false&#125;; &#125;, componentWillMount: function() &#123; butter.post.list().then((resp) =&gt; &#123; this.setState(&#123; loaded: true, resp: resp.data &#125;) &#125;); &#125;, render: function() &#123; if (this.state.loaded) &#123; return ( &lt;div&gt; &#123;this.state.resp.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Hello;启动器代码中包含以下内容：package.json - 依赖项Webpack 和 Babel 配置index.html - app 的 HTML 文件index.js - 加载 React 并渲染 Hello 组件要使应用运行，请先克隆资源库：12git clone ...cd ..安装依赖:1npm install然后启动服务器:1npm run start浏览器输入 http://localhost:8000 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：&quot;start&quot;: webpack-dev-server --watch)如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取:增加服务器端渲染接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看GitHub上的差异。To get started, we’ll install Express, a Node.js server side application framework:开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架：1npm install express --save我们要创建一个渲染我们的 React 组件的服务器：123456789101112131415161718192021222324252627282930313233import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';function handleRender(req, res) &#123; // 把 Hello 组件渲染成 HTML 字符串 const html = ReactDOMServer.renderToString(&lt;Hello /&gt;); // 加载 index.html 的内容 fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; // 把渲染后的 React HTML 插入到 div 中 const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`); // 把响应传回给客户端 res.send(document); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000);让我们分解下程序看看发生了什么事情…handleRender 函数处理所有请求。在文件顶部导入的 ReactDOMServer 类提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法1ReactDOMServer.renderToString(&lt;Hello /&gt;);这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。1const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/,`&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`);To start the server, update the start script in package.json and then run npm run start:要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 npm run start :123"scripts": &#123; "start": "webpack &amp;&amp; babel-node server.js"&#125;,浏览 http://localhost:3000 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，React repo 有一个 issue，超过 100 条评论讨论了这个问题和各种解决方法。在渲染之前获取数据要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在GitHub上查看完整的差异。To move data fetching before rendering, we’ll install react-transmit:要在渲染之前获取数据，我们需安装 react-transmit：1npm install react-transmit --saveReact Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。这是我们使用 react-transmit 后的组件的代码：12345678910111213141516171819202122232425262728293031323334import React from 'react';import Butter from 'buttercms'import Transmit from 'react-transmit';const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; render: function() &#123; if (this.props.posts) &#123; return ( &lt;div&gt; &#123;this.props.posts.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Transmit.createContainer(Hello, &#123; // 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错 initialVariables: &#123;&#125;, // 定义的方法名将成为 Transmit props 的名称 fragments: &#123; posts() &#123; return butter.post.list().then((resp) =&gt; resp.data); &#125; &#125;&#125;);我们已经使用 Transmit.createContainer 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 Transmit.renderToString 而不是 ReactDOM.renderToString 方法12345678910111213141516171819202122232425262728293031import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';import Transmit from 'react-transmit';function handleRender(req, res) &#123; Transmit.renderToString(Hello).then((&#123;reactString, reactData&#125;) =&gt; &#123; fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;reactString&#125;&lt;/div&gt;`); const output = Transmit.injectIntoMarkup(document, reactData, ['/build/client.js']); res.send(document); &#125;); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000);重新启动服务器浏览到 http://localhost：3000。查看页面源代码，您将看到该页面现在完全呈现在服务器上！更进一步我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 Electrode 或 Next.js。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 Hypernova 。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 React 全家桶搭建一个后台管理系统]]></title>
    <url>%2Fposts%2F9bfbdbf4%2F</url>
    <content type="text"><![CDATA[使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。项目地址以及局部展示项目地址小模块展示：redux在项目中的运用demo展示项目目录结构1234567891011121314151617181920212223242526272829303132├── build.js 项目打包后的文件├── config webpack配置文件│ ├──...│ ├──webpack.config.dev.js 开发环境配置│ ├──webpack.config.prod.js 生产环境配置├── node_modules node模块目录├── public│ └──index.html├── scripts│ ├── build.js 打包项目文件│ ├── start.js 启动项目文件│ └── test.js 测试项目文件├── src│ ├── client 汇聚(入口)目录│ ├── common 核心目录│ │ ├── actions redux中的action│ │ ├── components 通用功能组件│ │ ├── container 通用样式组件│ │ ├── images│ │ ├── pages 页面模块│ │ ├── reducers redux中的reducer│ │ ├── utils 工具类│ │ │ ├── config.js 通用配置│ │ │ ├── menu.js 菜单配置│ │ │ └── ajax.js ajax模块(日后用到)│ │ └── routes.js 前端路由│ └── server 服务端目录(日后用到)│ └── controller├── .gitignore├── package.json├── README.md└── yarn.lock项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。下面对目录结构作以下说明项目最初始是用 create-react-app 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;client 作为入口目录，到时候可以把第三方中间件也放在此处;container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。containercomponent目的如何工作(数据获取,状态更新)如何显示(样式，布局)是否在 Redux 数据流中是否读取数据从 Redux 获取 state从 props 获取数据修改数据向 Redux 派发 actions从 props 调用回调函数实现方式向react-redux生成手写ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。server 层就是作为网关层，日后计划用来写 node 的。技术栈相关虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;webpack(2.x)4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。按需加载babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:123456789101112&#123; test: /\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; plugins: [ "transform-decorators-legacy", // 引人 ES7 的装饰器 @ ['import', [&#123; libraryName: 'antd', style: true &#125;]], ], cacheDirectory: true, &#125;, &#125;,引人less首先引人 less-loader 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件12345678910111213141516171819202122232425262728293031 test: /\.less$/, use: [ require.resolve('style-loader'), require.resolve('css-loader'), &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', //https://webpack.js.org/guides/migrating/#complex-options plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader'), options: &#123; modifyVars: &#123; "@primary-color": "#1DA57A" &#125;, // 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。 &#125;, &#125;, ],&#125;,一键发布到 gh-pages用到了 gh-pages ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。引用路径的缩写1234567891011alias: &#123; 'react-native': 'react-native-web', components: path.resolve(__dirname, '..') + '/src/common/components', container: path.resolve(__dirname, '..') + '/src/common/container', images: path.resolve(__dirname, '..') + '/src/common/images', pages: path.resolve(__dirname, '..') + '/src/common/pages', utils: path.resolve(__dirname, '..') + '/src/common/utils', data: path.resolve(__dirname, '..') + '/src/server/data', actions: path.resolve(__dirname, '..') + '/src/common/actions', reducers: path.resolve(__dirname, '..') + '/src/common/reducers', &#125;,配置了引用路径的缩写后，就可以在任意地方如这样引用，比如1import Table from 'components/table'Antd(2.x)antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的设计理念也学到了很多关于UI、UX的知识。该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。React-router(4.x)react-router 4.x和2.x的差异又是特别的大，召唤文档,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。2.x:1234&lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt; &lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;&lt;/Route&gt;4.x:123&lt;Route path="/" component=&#123;App&#125; /&gt;&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;Fetchfetch 使用比较简单，基本的 promise 用法如下123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e))此外还能这样用1234567try &#123; let response = await fetch(url); let data = await response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125;但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 fetch-jsonp 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下123fetchJsonp(url,&#123;method: 'GET'&#125;) .then((res) =&gt;res.json()) .then((data) =&gt; &#123;&#125;)Redux使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇深入Redux架构下面通过把 代办事项 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。首先，在入口目录创建 store12345678const store = createStore(rootReducer)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123; routes &#125; &lt;/Provider&gt;, document.getElementById('root'));接着，我使用了 redux-actions 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):123import &#123; createAction &#125; from 'redux-actions'export const setVisibility = createAction('SET_VISIBILITY')没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，123456export const setVisibility = (filter) =&gt; &#123; return &#123; type: "SET_VISIBILITY", filter &#125;&#125;相应的代办事项的 reducers 文件片段:12345export const setVisibility = handleActions(&#123; 'SET_VISIBILITY'(state, action) &#123; return &#123; ...state, ...action.payload&#125; &#125;&#125;, 'SHOW_ALL')使用 redux-actions 后，只要进行如下调用,reducers文件里的SET_VISIBILITY的 action 就能捕获到SHOW_ALL这个状态。12345678import &#123; setVisibility &#125; from 'actions/todoList'@connect( (state) =&gt; (&#123; setVisibility: state.setVisibility, // 这个 setVisibility 是取自 reducers 的 &#125;))dispatch(this.props.dispatch(setVisibility('SHOW_ALL')))connect 来自 react-redux，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 mapStateToProps、mapDispatchToProps。项目的一些扩展计划计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，点我 Star。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-你不知道的 JavaScript (上)]]></title>
    <url>%2Fposts%2F4a895cbd%2F</url>
    <content type="text"><![CDATA[《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。什么是作用域作用域是一套规则，用于确定在何处以及如何查找变量。编译原理JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。分词/词法分析将字符串分解成有意义的代码块，代码块又称词法单元。比如程序var a = 2;会被分解为var、a、=、2、;解析/语法分析将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。代码生成将抽象语法树转换为机器能够识别的指令。理解作用域作用域 分别与编译器、引擎进行配合完成代码的解析引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。编译器负责语法分析以及生成代码。作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。对于 var a = 2 这条语句，首先编译器会将其分为两部分，一部分是 var a，一部分是 a = 2。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！异常对于 var a = 10 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 LHS 查询。 对于 console.log(a) 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 RHS 查询。为什么区分 LHS 和 RHS 是一件重要的事情？在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。作用域的工作模式作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。词法作用域词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:123456789101112function foo() &#123; console.log(a); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar()词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。动态作用域而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。123456789101112function foo() &#123; console.log(a); // 3&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar()函数作用域匿名与具名对于函数表达式一个最熟悉的场景可能就是回调函数了，比如123setTimeout( function() &#123; console.log("I waited 1 second!")&#125;, 1000 )这叫作匿名函数表达式。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。始终给函数表达式命名是一个最佳实践:123setTimeout( function timeoutHandler() &#123; // 我有名字了 console.log("I waited 1 second!")&#125;, 1000 )提升先有声明还是先有赋值考虑以下代码：12345a = 2;var a;console.log(a); // 2考虑另外一段代码123console.log(a); // undefinedvar a = 2;我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。可以看出，先有声明后有赋值。再来看以下代码：123456foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;;这个代码片段经过提升后，实际上会被理解为以下形式:123456789var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123; var bar = ...self... // ...&#125;;这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式就会赋值)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。闭包之前写过关于闭包的一篇文章深入浅出JavaScript之闭包(Closure)循环和闭包要说明闭包，for 循环是最常见的例子。12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125;正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：12345678for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)();&#125;还可以对这段代码进行一些改进：1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)(i);&#125;在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。重返块作用域我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 )&#125;本质上这是将一个块转换成一个可以被关闭的作用域。此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125;this全面解析之前写过一篇深入浅出JavaScript之this。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。this词法来看下面这段代码的问题：123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log(this.id); &#125;&#125;;var id = "not awesome";obj.cool(); // awesomesetTimeout( obj.cool, 100); // not awesomeobj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;123456789101112131415var obj = &#123; count: 0, cool: function coolFn() &#123; var self = this; if (self.count &lt; 1) &#123; setTimeout( function timer()&#123; self.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome?这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。ES6 中的箭头函数引人了一个叫作 this 词法的行为：12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome?箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("more awesome"); &#125;.bind( this ), 100) &#125; &#125;&#125;obj.cool(); // more awesome绑定规则函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。默认绑定独立函数调用隐式绑定当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象显示绑定call/applybind（本质是对call/apply函数的封装 fn.apply( obj, arguments )）第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 thisnew 绑定JavaScript 中的 new 机制实际上和面向类的语言完全不同实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。被忽略的 this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：12345678910function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;// 把数组"展开"成参数foo.apply(null, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2);bar(3); // a:2, b:3其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。123456789101112function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;var ø = Object.create(null);// 把数组"展开"成参数foo.apply( ø, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2);bar(3); // a:2, b:3对象JavaScript中的对象有字面形式（比如var a = { .. })和构造形式（比如var a = new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选择。作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。复制对象思考一下这个对象：12345678910111213141516function anotherFunction() &#123; /*..*/ &#125;var anotherObject = &#123; c: true&#125;;var anotherArray = [];var myObject = &#123; a: 2, b: anotherObject, // 引用，不是复本！ c: anotherArray, // 另一个引用！ d: anotherFunction&#125;;anotherArray.push( myObject )如何准确地表示 myObject 的复制呢？这里有一个知识点。浅复制。复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用。深复制。除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的复制方法：1var newObj = JSON.parse( JSON.stringify(someObj) )我认为这种方法就是深复制。相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：123456var newObj = Object.assign( &#123;&#125;, myObject );newObj.a; // 2newObj.b === anotherObject; // truenewObj.c === anotherArray; // truenewObj.d === anotherFunction; // true类JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。检查“类”关系思考下面的代码：1234567function Foo() &#123; // ...&#125;Foo.prototype.blah = ...;var a = new Foo();我们如何找出 a 的“祖先”（委托关系）呢？方法一：a instanceof Foo; // true (对象 instanceof 函数)方法二: Foo.prototype.isPrototypeOf(a); // true (对象 isPrototypeOf 对象)方法三: Object.getPrototypeOf(a) === Foo.prototype; // true (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;方法四: a.__proto__ == Foo.prototype; // true构造函数函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。对象关联来看下面的代码：123456789var foo = &#123; something: function() &#123; console.log("Tell me something good..."); &#125;&#125;;var bar = Object.create(foo);bar.something(); // Tell me something good...Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。此书的第二章第6部分就把面对类和继承和行为委托两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到Object.create()的强大。ES6中的Class来看一段 ES6中Class 的例子123456789101112131415161718192021222324252627282930class Widget &#123; constructor(width, height) &#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if (this.$elem) &#123; this.$elem.css(&#123; width: this.width + "px"， height: this.height + "px" &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget &#123; constructor(width, height, label) &#123; super(width, height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label) &#125; render($where) &#123; super($where); this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt) &#123; console.log("Button '" + this.label + "' clicked!") &#125;&#125;除了语法更好看之外，ES6还有以下优点基本上不再引用杂乱的 .prototype 了。Button 声明时直接 “继承” 了 Widget。可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。可以通过 extends 很自然地扩展对象(子)类型。但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。这也是本书作者希望我们思考的问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 摸爬滚打之进阶教程]]></title>
    <url>%2Fposts%2Ff55182c5%2F</url>
    <content type="text"><![CDATA[本文首发在我的个人博客：http://muyunyun.cn/写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了hexo。本文有以下内容:快速实现博客压缩文章链接唯一化添加酷炫的打赏二维码自定义JS和CSS添加酷炫的歌单模块以及播放器github分支管理博客思路秒传图片到七牛云并展现在博客中将博客同时部署到github和coding快速实现博客压缩项目压缩也叫代码丑化,分别对html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把images进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。蛮多朋友使用了gulp对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块hexo-all-minifier，这个模块集成了对html、css、js、image的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。12345678910111213141516171819202122232425html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章链接唯一化也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装1npm install hexo-abbrlink --save在站点配置文件中查找代码permalink，将其更改为:1permalink: posts/:abbrlink/ # “posts/” 可自行更换这里有个知识点：百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。然后在站点配置文件中添加如下代码:1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex可选择模式：crc16 &amp; hexcrc16 &amp; deccrc32 &amp; hexcrc32 &amp; dec添加酷炫的打赏二维码看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)实现这个酷炫二维码的流程如下：首先，分别获得支付宝和微信的收款码接着到芝麻二维码里将两张二维码合并最后到第九工场生成自己喜欢的造型讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上1alipay: /pay.png打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/自定义JS和CSS博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的添加自定义js样式首先把js文件放在\themes\next\source\js\src文件目录下然后找到\themes\next\layout目录下的布局文件_layout.swig把script引用代码加入到该文件中即可&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;添加自定义css样式添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在\themes\next\source\css\_custom\custom.styl文件中进行样式的添加。添加酷炫的歌单模块以及播放器这个模块借鉴了@小胡子哥。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：核心代码在\themes\next\source\js\src\music\nmlist中，点击看源码，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)解决了这个bug。再接着玩的话，可以给播放器加上歌词的功能。这里有一篇相关文章,有机会可以去把玩一番。github分支管理博客思路有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件push到user.github.io的其他分支。我选择了后者。创建muyy(任意)分支创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制12git initgit remote add origin &lt;server&gt;&lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传至muyy分支.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public/_config.yml.deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去依次执行123git add .git commit -m "..."git push origin muyy秒传图片到七牛云并展现在博客中在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具qiniu-image-tool，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac是基于Alfred的，其windows也有相应版本windows版本。按照其要求配置好以后，用截图软件截图后，或者本地图片后copy，然后直接按设置好的command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。将博客同时部署到github和coding通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。coding上创建一个新项目这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面同步本地hexo到coding上把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心,其实和github配置一模一样的。本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。添加后，在git bash命令输入：1ssh -T git@git.coding.net如果得到下面提示就表示公钥添加成功了：1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ]想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch]所以我是这样的12345deploy:- type: git repo: github: https://github.com/MuYunyun/MuYunyun.github.io.git,master coding: git@git.coding.net:muyunyun/muyunyun.git,master最后使用部署命令就能把博客同步到coding上面：1hexo deploy -gpages服务方式部署将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了设置域名解析现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：参考资料小胡子哥Hexo Next主题设置和优化Hexo 博客补丁Water Sister’s BlogHexo+NexT主题配置备忘Cherry’s BlogHexo 3.1.1 静态博客搭建指南hexo的next主题个性化教程:打造炫酷网站将hexo博客同时托管到github和coding]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>