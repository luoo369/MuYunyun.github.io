<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[探索从 MVC 到 MVVM + Flux 架构模式的转变]]></title>
    <url>%2Fposts%2Ff0f11de9%2F</url>
    <content type="text"><![CDATA[在业务中一般 MVVM 框架一般都会配合上数据状态库(redux, mobx 等)一起使用，本文会通过一个小 demo 来讲述为什么会引人数据状态库。从 MVC 到 MVVM 模式说起传统 MVC 架构(如 JSP)在当今移动端流量寸土寸金的年代一个比较头疼的问题就是会进行大量的全局重复渲染。但是 MVC 架构是好东西，其对数据、视图、逻辑有了清晰的分工，于是前端 MVC 框架(比如 backbone.js) 出来了，对于很多业务规模不大的场景，前端 MVC 框架已经够用了，它也能做到前后端分离开发单页面应用，那么它的缺陷在哪呢？拿 backbone.js 说，它的 Model 对外暴露了 set 方法，也就是说可以在不止一个 View 里修改同个 Model 的数据，然后一个 Model 的数据同时对应多个 View 的呈现，如下图所示。当业务逻辑过多时，多个 Model 和多个 View 就会耦合到一块，可以想到排查 bug 的时候会比较痛苦。针对传统 MVC 架构性能低(多次全局渲染)以及前端 MVC 框架耦合度高(Model 和 View) 的痛处，MVVM 框架完美地解决了以上两点。可以参阅之前写的 MVVM 框架解析之双向绑定only MVVM假设有这么一个场景，在输入框中查询条件，点击查询，然后在列表中返回相应内容。如下图所示：假设用 react 实现，思路大体是先调用查询接口，调用成功后将获取到的数据通过 setState 存进 list 中，列表显示部分代码如下：123456789101112131415161718const Decorate = (ListComponent) =&gt; class extends Component &#123; constructor() &#123; super() this.state = &#123; list: [] &#125; &#125; componentDidMount() &#123; fetch('./list.json') .then((res) =&gt; res.json()) .then(result =&gt; this.setState(&#123; list: result.data &#125;)) &#125; render() &#123; return ( &lt;ListComponent data=&#123;this.state.list&#125; /&gt; ) &#125;&#125;接着往封装的 Decorate 组件里，传入无状态函数构建的 List 组件用来展示列表数据，代码如下：123456789function List(props) &#123; return ( &lt;div&gt; &#123;props.data.map(r =&gt; &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;/p&gt; )&#125; &lt;/div&gt; )&#125;可以看到 List 组件相当于是 View 层，而封装的 Decorate 组件相当于是 Model 层。但是这么做还是把业务逻辑写进了组件当中。而我们期望的是能得到一个纯粹的 Model 层和 View 层。接着一起看看 Flux 架构模式是如何解决这个问题的。引人 Flux 架构模式Flux 架构模式的 4 个重要组成部分以及它们的关系如上图所示，下文会根据 dispatch，store, action, view 的顺序逐步揭开 Flux 架构模式的面纱。从 Flux 的源码中可以看出 Dispacher.js 是其的核心文件，其核心是基于事件的发布/订阅模式完成的，核心源码如下：12345678910111213141516class Dispatcher &#123; ... // 注册回调函数， register(callback) &#123; var id = _prefix + this._lastID++; this._callbacks[id] = callback; &#125; // 当调用 dispatch 的时候会调用 register 中注册的回调函数 dispatch(payload) &#123; this._startDispatching(payload); for (var id in this._callbacks) &#123; this._invokeCallback(id); &#125; &#125;&#125;回顾下之前的目的：让 Store 层变得纯粹。于是定义了一个变量 comments 用来专门存放列表数据，在了解 Dispatcher 的核心原理之后，当调用 dispatch(obj) 方法时，就可以把参数传递到事先注册的 register 函数中，代码如下：123456789101112131415// commentStore.jslet comments = []const CommentStore = &#123; getComment() &#123; return comments &#125;&#125;dispathcer.register((action) =&gt; &#123; // 调用 Dispatcher 实例上的 register 函数 switch (action.type) &#123; case 'GET_LIST_SUCCESS': &#123; comments = action.comment &#125; &#125;&#125;)以及 action 中的函数如下：123456789101112// commentAction.jsconst commentAction = &#123; getList() &#123; fetch('./list.json') .then((res) =&gt; res.json()) .then(result =&gt; dispathcer.dispatch(&#123; // 调用 Dispatcher 实例上的 dispatch 函数 type: 'GET_LIST_SUCCESS', comment: result.data &#125;)) &#125;&#125;但是似乎少了点什么，当 GET_LIST_SUCCESS 成功后，发现还缺少通知到页面再次调用 CommentStore.getComment() 的能力，所以再次引用事件发布/订阅模式，这次使用了 Node.js 提供的 events 模块，对 commentStore.js 文件进行修改，修改后代码如下：1234567891011121314151617181920212223let comments = []const CommentStore = Object.assign(&#123;&#125;, EventEmitter.prototype, &#123; getComment() &#123; return comments &#125;, emitChange() &#123; this.emit('change') &#125;, addListener(callback) &#123; // 提供给页面组件使用 this.on('change', callback) &#125;&#125;)appDispathcer.register((action) =&gt; &#123; switch (action.type) &#123; case 'GET_LIST_SUCCESS': &#123; comments = action.comment CommentStore.emitChange() // 有了这行代码，也就有了通知页面再次进行调用 CommentStore.getComment 的能力 &#125; &#125;&#125;)剩下最后一步了，就是整合 store 和 action 进页面中，代码如下:123456789101112131415161718192021222324class ComponentList extends Component &#123; constructor() &#123; super() this.state = &#123; comment: commentStore.getComment() &#125; &#125; componentDidMount() &#123; commentStore.addListener(() =&gt; this.setState(&#123; // 注册函数，上面已经提过，供 store 使用 comment: commentStore.getComment() &#125;)) &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.comment.map(r =&gt; &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;/p&gt; )&#125; &lt;/div&gt; ) &#125;&#125;小结单纯以 mvvm 构建应用会发现业务逻辑以及数据都耦合在组件之中，引入了 Flux 架构模式后数据和业务逻辑得到较好的分离。但是使用 Flux 有什么缺点呢？在下篇 《聊聊 Redux 架构模式》中会进行分析，下回见。本文实践案例已上传至 stateManage系列博客，欢迎 Star]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>状态管理</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域二三事]]></title>
    <url>%2Fposts%2Fe29f2c47%2F</url>
    <content type="text"><![CDATA[跨域是日常开发中经常开发中经常会接触到的一个重难点知识，何不总结实践一番，从此心中对之了无牵挂。同源策略之所以会出现跨域解决方案，是因为同源策略的限制。同源策略规定了如果两个 url 的协议、域名、端口中有任何一个不等，就认定它们跨源了。比如下列表格列出和 http://127.0.0.1:3000 比较的同源检测的结果，url结果原因http://127.0.0.1:3000/index同源https://127.0.0.1:3000跨源协议不同https://localhost:3000跨源域名不同http://127.0.0.1:3001跨源端口不同那跨源有什么后果呢？归纳有三：不能获取 Cookie、LocalStorage、IndexedDB；不能获取 dom 节点；不能进行一般的 Ajax 通信；跨域解决方案的出现就是为了解决以上痛处。JSONP 跨域提到 JSONP 跨域，不得不先提到 script 标签，和 img、iframe 标签类似，这些标签是不受同源策略限制的，JSONP 的核心就是通过动态加载 script 标签来完成对目标 url 的请求。先来看一段 JSONP 调用的 Headers 部分，字段如下：1234Request URL:http://127.0.0.1:3000/?callback=handleResponseRequest Method:GETStatus Code:200 OKRemote Address:127.0.0.1:3000可以很鲜明地发现在 Request URL 中有一句 ?callback=handleResponse，这个 callback 后面跟着的 handleResponse 即回调函数名（可以任意取），服务端会接收到这个参数然后拼接成形如 handleResponse(JSON) 的形式返还给前端(这也是 JSONP == JSON with padding 的原因吧)，如下图，这时候浏览器就会自动调用我们事先定义好的 handleResponse 函数。前端代码示例：(源为 http://127.0.0.1:3001)1234567function handleResponse(res) &#123; console.log(res) // &#123;text: "jsonp"&#125;&#125;const script = document.createElement('script')script.src = 'http://127.0.0.1:3000?callback=handleResponse'document.head.appendChild(script)服务端代码示例：(源为 http://127.0.0.1:3000)1234567891011const server = http.createServer((req, res) =&gt; &#123; if (~req.url.indexOf('?callback')) &#123; // 简单处理 JSONP 跨域的时候 const obj = &#123; "text": 'jsonp', &#125; const callback = req.url.split('callback=')[1] const json = JSON.stringify(obj) const build = callback + `($&#123;json&#125;)` res.end(build) // 这里返还给前端的是拼接好的 JSON 对象 &#125;&#125;);可以看出 JSONP 具有直接访问响应文本的优点，但是要想确认 JSONP 是否请求失败并不容易，因为 script 标签的 onerror 事件还未得到浏览器广泛的支持，此外它仅能支持 GET 方式调用。CORS 跨域CORS(Cross-Origin Resource Sharing) 可以理解为加强版的 Ajax，也是目前主流的跨域解决方案。它的核心思想即前端与后端进行 Ajax 通信时，通过自定义 HTTP 头部设置从而决定请求或响应是否生效。比如前端代码(url 为 http://127.0.0.1:3001)写了段 Ajax，代码如下：12345678910const xhr = new XMLHttpRequest()xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status === 304) &#123; console.log('responseTesx:' + xhr.responseText) &#125; &#125;&#125;xhr.open('get', 'http://127.0.0.1:3000', true)xhr.send()因为端口不一致的关系这时候导致不同源了，这时候会在 Request Headers 中发现多了这么一行字段，1Origin: http://127.0.0.1:3001而且控制台中会报出如下错误:1Failed to load http://127.0.0.1:3000/: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://127.0.0.1:3001' is therefore not allowed access.这时候就需要在服务端设置字段 Access-Control-Allow-Origin，它的作用就是设置允许来自什么源的请求，如果值设置为 *，表明允许来自任意源的请求。服务端代码示例如下：123http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') // 设置允许来自 http://127.0.0.1:3001 源的请求&#125;)CORS 分为简单请求以及非简单请求。可以这么区分，如果请求方法为 POST、GET、HEAD 时为简单请求，其它方法如 PUT、DELETE 等为非简单请求，如果是非简单请求的话，可以在 chrome 的 Network 中看到多了一次 Request Method 为 OPTIONS 的请求。如下图:可以把这个请求称为预请求，用白话文翻译下，浏览器询问服务器，’服务器大哥，我这次要进行 PUT 请求，你给我发张通行证呗’，服务器大哥见浏览器小弟这么殷勤，于是给了它发了张通行证，叫作 Access-Control-Allow-Methods:PUT，接着浏览器就能愉快地进行 PUT 请求了。服务端代码示例如下：1234http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') res.setHeader('Access-Control-Allow-Methods', 'http://127.0.0.1:3001')&#125;)聊完简单请求和非简单请求的区别后，再来看看如何利用 CORS 实现 Cookie 的跨域传送，首先在服务器随意设置个 Cookie 值下发到浏览器，如果非跨域的情况下，浏览器再次请求服务器时就会带上服务器给的 Cookie，但是跨域的时候怎么办呢？不卖关子了，需在服务端设置 Access-Control-Allow-Credentials 字段以及在客户端设置 withCredentials 字段，两者缺一不可，代码如下：前端代码示例：(源为 http://127.0.0.1:3001)12345const xhr = new XMLHttpRequest()...xhr.withCredentials = true // 传 cookie 的时候前端要做的xhr.open('get', 'http://127.0.0.1:3000', true)xhr.send()服务端代码示例: (源为 http://127.0.0.1:3000)123456const server = http.createServer((req, res) =&gt; &#123; res.setHeader('Access-Control-Allow-Origin', 'http://127.0.0.1:3001') // 必填：接受域的请求 res.setHeader('Set-Cookie', ['type=muyy']) // 下发 cookie res.setHeader('Access-Control-Allow-Credentials', true) // ② 选填：是否允许浏览器传 cookie 到服务端，只能设置为 true res.end('date from cors')&#125;)至此介绍了几个比较关键 HTTP 头在 CORS 中的实践运用，更为详细的资料可以参阅 Cross-Origin Resource Sharing，最后概括下 CORS 的优缺点，优点是支持所有类型的 HTTP 方法，缺点是有些老的浏览器不支持 CORS。hash + iframe在文章最开始提到过 iframe 标签也是不受同源策略限制的标签之一，hash + iframe 的跨域核心思想就是，在 A 源中通过动态改变 iframe 标签的 src 的哈希值，在 B 源中通过 window.onhashchange 来捕获到相应的哈希值。思路不难直接上代码：A 页面代码示例(源为 http://127.0.0.1:3000)1234567891011&lt;body&gt; &lt;iframe src="http://127.0.0.1:3001"&gt;&lt;/iframe&gt; &lt;script&gt; const iframe = document.getElementsByTagName('iframe')[0] iframe.setAttribute('style', 'display: none') const obj = &#123; data: 'hash' &#125; iframe.src = iframe.src + '#' + JSON.stringify(obj) // ① 关键语句 &lt;/script&gt;&lt;/body&gt;B 页面代码示例(源为 http://127.0.0.1:3001)123window.onhashchange = function() &#123; // ① 关键语句 console.log('来自 page2 的代码 ' + window.location.hash) // 来自 page2 的代码 #&#123;"data":"hash"&#125;&#125;刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。1来自 page2 的代码 #&#123;"data":"hash"&#125;这种方式进行跨域优点是支持页面和页面间的通信，缺点也是只支持 GET 方法和单向的跨域通信。postMessage为了实现跨文档传送(cross-document messaging)，简称 XDM。HTML5 给出了一个 api —— postMessage，postMessage() 方法接收两个参数：发送消息以及消息接收方所在域的字符串。代码示例如下:A 页面代码示例(源为 http://127.0.0.1:3000)12345678910&lt;body&gt; &lt;iframe src="http://127.0.0.1:3001"&gt;&lt;/iframe&gt; &lt;script&gt; const iframe = document.getElementsByTagName('iframe')[0] iframe.setAttribute('style', 'display: none') iframe.onload = function() &#123; // 此处要等 iframe 加载完毕，后续代码才会生效 iframe.contentWindow.postMessage('a secret', 'http://127.0.0.1:3001') &#125; &lt;/script&gt;&lt;/body&gt;B 页面代码示例(源为 http://127.0.0.1:3001)1234window.addEventListener('message', function(event) &#123; console.log('From page1 ' + event.data) console.log('From page1 ' + event.origin)&#125;, false)刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。12From page1 a secretFrom page1 http://127.0.0.1:3000这种跨域方式优点是是支持页面和页面间的双向通信，缺点也是只能支持 GET 方法调用。WebSocketsWebSockets 属于 HTML5 的协议，它的目的是在一个持久连接上建立全双工通信。由于 WebSockets 采用了自定义协议，所以优点是客户端和服务端发送数据量少，缺点是要额外的服务器。基础的使用方法如下：12345678910111213141516const ws = new WebSocket('ws://127.0.0.1:3000')ws.onopen = function() &#123; // 连接成功建立&#125;ws.onmessage = function(event) &#123; // 处理数据&#125;ws.onerror = function() &#123; // 发生错误时触发，连接中断&#125;ws.onclose = function() &#123; // 连接关闭时触发&#125;当然一般我们会使用封装好 WebSockets 的第三方库 socket.io，这里具体就不展开了。项目地址前文所述五种跨域实践的 demo 已上传至 cross-domain，前端环境基于 create-react-app 搭建，后端环境用 node 搭建。当然跨域方式还有一些其他方式的实现，后续酌情慢慢填坑~]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生 JS 实现一个瀑布流插件]]></title>
    <url>%2Fposts%2F16b9cce7%2F</url>
    <content type="text"><![CDATA[瀑布流布局中的图片有一个核心特点 —— 等宽不定等高，瀑布流布局在国内外网站都有一定规模的使用，比如pinterest、花瓣网等等。那么接下来就基于这个特点开始瀑布流探索之旅。基础功能实现首先我们定义好一个有 20 张图片的容器，1234567891011121314151617181920&lt;body&gt; &lt;style&gt; #waterfall &#123; position: relative; &#125; .waterfall-box &#123; float: left; width: 200px; &#125; &lt;/style&gt;&lt;/body&gt;&lt;div id="waterfall"&gt; &lt;img src="images/1.png" class="waterfall-box"&gt; &lt;img src="images/2.png" class="waterfall-box"&gt; &lt;img src="images/3.png" class="waterfall-box"&gt; &lt;img src="images/4.png" class="waterfall-box"&gt; &lt;img src="images/5.png" class="waterfall-box"&gt; &lt;img src="images/6.png" class="waterfall-box"&gt; ... &lt;/div&gt;由于未知的 css 知识点，丝袜最长的妹子把下面的空间都占用掉了。。。接着正文，假如如上图，每排有 5 列，那第 6 张图片应该出现前 5 张图片哪张的下面呢？当然是绝对定位到前 5 张图片高度最小的图片下方。那第 7 张图片呢？这时候把第 6 张图片和在它上面的图片当作是一个整体后，思路和上述是一致的。代码实现如下:12345678910111213141516171819Waterfall.prototype.init = function () &#123; ... const perNum = this.getPerNum() // 获取每排图片数 const perList = [] // 存储第一列的各图片的高度 for (let i = 0; i &lt; perNum; i++) &#123; perList.push(imgList[i].offsetHeight) &#125; let pointer = this.getMinPointer(perList) // 求出当前最小高度的数组下标 for (let i = perNum; i &lt; imgList.length; i++) &#123; imgList[i].style.position = 'absolute' // 核心语句 imgList[i].style.left = `$&#123;imgList[pointer].offsetLeft&#125;px` imgList[i].style.top = `$&#123;perList[pointer]&#125;px` perList[pointer] = perList[pointer] + imgList[i].offsetHeight // 数组最小的值加上相应图片的高度 pointer = this.getMinPointer(perList) &#125;&#125;细心的朋友也许发现了代码中获取图片的高度用到了 offsetHeight 这个属性，这个属性的高度之和等于图片高度 + 内边距 + 边框，正因为此，我们用了 padding 而不是 margin 来设置图片与图片之间的距离。此外除了offsetHeight 属性，此外还要理解 offsetHeight、clientHeight、offsetTop、scrollTop 等属性的区别，才能比较好的理解这个项目。css 代码简单如下：123456.waterfall-box &#123; float: left; width: 200px; padding-left: 10px; padding-bottom: 10px;&#125;至此完成了瀑布流的基本布局，效果图如下：scroll、resize 事件监听的实现实现了初始化函数 init 以后，下一步就要实现对 scroll 滚动事件进行监听，从而实现当滚到父节点的底部有源源不断的图片被加载出来的效果。这时候要考虑一个点，是滚动到什么位置时触发加载函数呢？这个因人而异，我的做法是当满足 父容器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop 这个条件，即橙色线条 + 紫色线条 &gt; 蓝色线条时触发加载函数，代码如下：12345678910111213window.onscroll = function() &#123; // ... if (scrollPX + bsHeight &gt; imgList[imgList.length - 1].offsetTop) &#123;// 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop const fragment = document.createDocumentFragment() for(let i = 0; i &lt; 20; i++) &#123; const img = document.createElement('img') img.setAttribute('src', `images/$&#123;i+1&#125;.png`) img.setAttribute('class', 'waterfall-box') fragment.appendChild(img) &#125; $waterfall.appendChild(fragment) &#125;&#125;因为父节点可能自定义节点，所以提供了对监听 scroll 函数的封装，代码如下：12345678910proto.bind = function () &#123; const bindScrollElem = document.getElementById(this.opts.scrollElem) util.addEventListener(bindScrollElem || window, 'scroll', scroll.bind(this))&#125;const util = &#123; addEventListener: function (elem, evName, func) &#123; elem.addEventListener(evName, func, false) &#125;,&#125;resize 事件的监听与 scroll 事件监听大同小异，当触发了 resize 函数，调用 init 函数进行重置就行。使用发布-订阅模式和继承实现监听绑定既然以开发插件为目标，不能仅仅满足于功能的实现，还要留出相应的操作空间给开发者自行处理。联想到业务场景中瀑布流中下拉加载的图片一般都来自 Ajax 异步获取，那么加载的数据必然不能写死在库里，期望能实现如下调用(此处借鉴了 waterfall 的使用方式)，12345const waterfall = new Waterfall(&#123;options&#125;)waterfall.on("load", function () &#123; // 此处进行 ajax 同步/异步添加图片&#125;)观察调用方式，不难联想到使用发布/订阅模式来实现它，关于发布/订阅模式，之前在 Node.js 异步异闻录 有介绍它。其核心思想即通过订阅函数将函数添加到缓存中，然后通过发布函数实现异步调用，下面给出其代码实现:1234567891011121314151617function eventEmitter() &#123; this.sub = &#123;&#125;&#125;eventEmitter.prototype.on = function (eventName, func) &#123; // 订阅函数 if (!this.sub[eventName]) &#123; this.sub[eventName] = [] &#125; this.sub[eventName].push(func) // 添加事件监听器&#125;eventEmitter.prototype.emit = function (eventName) &#123; // 发布函数 const argsList = Array.prototype.slice.call(arguments, 1) for (let i = 0, length = this.sub[eventName].length; i &lt; length; i++) &#123; this.sub[eventName][i].apply(this, argsList) // 调用事件监听器 &#125;&#125;接着，要让 Waterfall 能使用发布/订阅模式，只需让 Waterfall 继承 eventEmitter 函数，代码实现如下:1234567function Waterfall(options = &#123;&#125;) &#123; eventEmitter.call(this) this.init(options) // 这个 this 是 new 的时候，绑上去的&#125;Waterfall.prototype = Object.create(eventEmitter.prototype)Waterfall.prototype.constructor = Waterfall继承方式的写法吸收了基于构造函数继承和基于原型链继承两种写法的优点，以及使用 Object.create 隔离了子类和父类，关于继承更多方面的细节，可以另写一篇文章了，此处点到为止。小优化为了防止 scroll 事件触发多次加载图片，可以考虑用函数防抖与节流实现。在基于发布-订阅模式的基础上，定义了个 isLoading 参数表示是否在加载中，并根据其布尔值决定是否加载，代码如下：12345678910111213141516let isLoading = falseconst scroll = function () &#123; if (isLoading) return false // 避免一次触发事件多次 if (scrollPX + bsHeight &gt; imgList[imgList.length - 1].offsetTop) &#123; // 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop isLoading = true this.emit('load') &#125;&#125;proto.done = function () &#123; this.on('done', function () &#123; isLoading = false ... &#125;) this.emit('done')&#125;这时候需要在调用的地方加上 waterfall.done, 从而告知当前图片已经加载完毕，代码如下:12345const waterfall = new Waterfall(&#123;&#125;)waterfall.on("load", function () &#123; // 异步/同步加载图片 waterfall.done()&#125;)项目地址项目地址此插件在 React 项目中的运用项目简陋，不足之处在所难免，欢迎留下你们宝贵的意见。]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>瀑布流</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM 框架解析之双向绑定]]></title>
    <url>%2Fposts%2F384a97b3%2F</url>
    <content type="text"><![CDATA[MVVM 框架近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。MVVM 框架基本概念在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的，在它们之间存在着 ViewModel 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model(数据) 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。这个一来一回的过程就是我们所熟知的双向绑定。MVVM 框架的应用场景MVVM 框架的好处显而易见：当前端对数据进行操作的时候，可以通过 Ajax 请求对数据持久化，只需改变 dom 里需要改变的那部分数据内容，而不必刷新整个页面。特别是在移动端，刷新页面的代价太昂贵。虽然有些资源会被缓存，但是页面的 dom、css、js 都会被浏览器重新解析一遍，因此移动端页面通常会被做成 SPA 单页应用。由此在这基础上诞生了很多 MVVM 框架，比如 React.js、Vue.js、Angular.js 等等。MVVM 框架的简单实现模拟 Vue 的双向绑定流，实现了一个简单的 MVVM 框架，从上图中可以看出虚线方形中就是之前提到的 ViewModel 中间介层，它充当着观察者的角色。另外可以发现双向绑定流中的 View 到 Model 其实是通过 input 的事件监听函数实现的，如果换成 React(单向绑定流) 的话，它在这一步交给状态管理工具(比如 Redux)来实现。另外双向绑定流中的 Model 到 View 其实各个 MVVM 框架实现的都是大同小异的，都用到的核心方法是 Object.defineProperty()，通过这个方法可以进行数据劫持，当数据发生变化时可以捕捉到相应变化，从而进行后续的处理。Mvvm(入口文件) 的实现一般会这样调用 Mvvm 框架1234567const vm = new Mvvm(&#123; el: '#app', data: &#123; title: 'mvvm title', name: 'mvvm name' &#125;, &#125;)但是这样子的话，如果要得到 title 属性就要形如 vm.data.title 这样取得，为了让 vm.title 就能获得 title 属性，从而在 Mvvm 的 prototype 上加上一个代理方法，代码如下：12345678910111213141516171819202122function Mvvm (options) &#123; this.data = options.data const self = this Object.keys(this.data).forEach(key =&gt; self.proxyKeys(key) )&#125;Mvvm.prototype = &#123; proxyKeys: function(key) &#123; const self = this Object.defineProperty(this, key, &#123; get: function () &#123; // 这里的 get 和 set 实现了 vm.data.title 和 vm.title 的值同步 return self.data[key] &#125;, set: function (newValue) &#123; self.data[key] = newValue &#125; &#125;) &#125;&#125;实现了代理方法后，就步入主流程的实现123456function Mvvm (options) &#123; this.data = options.data // ... observe(this.data) new Compile(options.el, this)&#125;observer(观察者) 的实现observer 的职责是监听 Model(JS 对象) 的变化，最核心的部分就是用到了 Object.defineProperty() 的 get 和 set 方法，当要获取 Model(JS 对象) 的值时，会自动调用 get 方法；当改动了 Model(JS 对象) 的值时，会自动调用 set 方法；从而实现了对数据的劫持，代码如下所示。1234567891011121314151617181920212223242526272829303132let data = &#123; number: 0&#125;observe(data)data.number = 1 // 值发生变化function observe(data) &#123; if (!data || typeof(data) !== 'object') &#123; return &#125; const self = this Object.keys(data).forEach(key =&gt; self.defineReactive(data, key, data[key]) )&#125;function defineReactive(data, key, value) &#123; observe(value) // 遍历嵌套对象 Object.defineProperty(data, key, &#123; get: function() &#123; return value &#125;, set: function(newValue) &#123; if (value !== newValue) &#123; console.log('值发生变化', 'newValue:' + newValue + ' ' + 'oldValue:' + value) value = newValue &#125; &#125; &#125;)&#125;运行代码，可以看到控制台输出 值发生变化 newValue:1 oldValue:0，至此就完成了 observer 的逻辑。Dep(订阅者数组) 和 watcher(订阅者) 的关系观测到变化后，我们总要通知给特定的人群，让他们做出相应的处理吧。为了更方便地理解，我们可以把订阅当成是订阅了一个微信公众号，当微信公众号的内容有更新时，那么它会把内容推送(update) 到订阅了它的人。那么订阅了同个微信公众号的人有成千上万个，那么首先想到的就是要 new Array() 去存放这些人(html 节点)吧。于是就有了如下代码：12345678910111213141516171819202122232425262728293031323334353637// observer.jsfunction Dep() &#123; this.subs = [] // 存放订阅者&#125;Dep.prototype = &#123; addSub: function(sub) &#123; // 添加订阅者 this.subs.push(sub) &#125;, notify: function() &#123; // 通知订阅者更新 this.subs.forEach(function(sub) &#123; sub.update() &#125;) &#125;&#125;function observe(data) &#123;...&#125;function defineReactive(data, key, value) &#123; var dep = new Dep() observe(value) // 遍历嵌套对象 Object.defineProperty(data, key, &#123; get: function() &#123; if (Dep.target) &#123; // 往订阅器添加订阅者 dep.addSub(Dep.target) &#125; return value &#125;, set: function(newValue) &#123; if (value !== newValue) &#123; console.log('值发生变化', 'newValue:' + newValue + ' ' + 'oldValue:' + value) value = newValue dep.notify() &#125; &#125; &#125;)&#125;初看代码也比较顺畅了，但可能会卡在 Dep.target 和 sub.update，由此自然而然地将目光移向 watcher，123456789101112131415161718192021222324252627// watcher.jsfunction Watcher(vm, exp, cb) &#123; this.vm = vm this.exp = exp this.cb = cb this.value = this.get()&#125;Watcher.prototype = &#123; update: function() &#123; this.run() &#125;, run: function() &#123; // ... if (value !== oldVal) &#123; this.cb.call(this.vm, value) // 触发 compile 中的回调 &#125; &#125;, get: function() &#123; Dep.target = this // 缓存自己 const value = this.vm.data[this.exp] // 强制执行监听器里的 get 函数 Dep.target = null // 释放自己 return value &#125;&#125;从代码中可以看到当构造 Watcher 实例时，会调用 get() 方法，接着重点关注 const value = this.vm.data[this.exp] 这句，前面说了当要获取 Model(JS 对象) 的值时，会自动调用 Object.defineProperty 的 get 方法，也就是当执行完这句的时候，Dep.target 的值传进了 observer.js 中的 Object.defineProperty 的 get 方法中。同时也一目了然地在 Watcher.prototype 中发现了 update 方法，其作用即触发 compile 中绑定的回调来更新界面。至此解释了 Observer 中 Dep.target 和 sub.update 的由来。来归纳下 Watcher 的作用，其充当了 observer 和 compile 的桥梁。1 在自身实例化的过程中，往订阅器(dep) 中添加自己2 当 model 发生变动，dep.notify() 通知时，其能调用自身的 update 函数，并触发 compile 绑定的回调函数实现视图更新最后再来看下生成 Watcher 实例的 compile.js 文件。compile(编译) 的实现首先遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成 fragment(文档碎片) 进行解析编译，解析完成，再将 fragment 添加回原来的真实 dom 节点中。代码如下：1234567891011121314151617181920212223242526function Compile(el, vm) &#123; this.vm = vm this.el = document.querySelector(el) this.fragment = null this.init()&#125;Compile.prototype = &#123; init: function() &#123; if (this.el) &#123; this.fragment = this.nodeToFragment(this.el) // 将节点转为 fragment 文档碎片 this.compileElement(this.fragment) // 对 fragment 进行编译解析 this.el.appendChild(this.fragment) &#125; &#125;, nodeToFragment: function(el) &#123; const fragment = document.createDocumentFragment() let child = el.firstChild // △ 第一个 firstChild 是 text while(child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileElement: function(el) &#123;...&#125;,&#125;这个简单的 mvvm 框架在对 fragment 编译解析的过程中对 {{}} 文本元素、v-on:click 事件指令、v-model 指令三种类型进行了相应的处理。1234567891011121314151617181920212223242526272829303132333435363738Compile.prototype = &#123; init: function() &#123; if (this.el) &#123; this.fragment = this.nodeToFragment(this.el) // 将节点转为 fragment 文档碎片 this.compileElement(this.fragment) // 对 fragment 进行编译解析 this.el.appendChild(this.fragment) &#125; &#125;, nodeToFragment: function(el) &#123;...&#125;, compileElement: function(el) &#123;...&#125;, compileText: function (node, exp) &#123; // 对文本类型进行处理，将 &#123;&#123;abc&#125;&#125; 替换掉 const self = this const initText = this.vm[exp] this.updateText(node, initText) // 初始化 new Watcher(this.vm, exp, function(value) &#123; // 实例化订阅者 self.updateText(node, value) &#125;) &#125;, compileEvent: function (node, vm, exp, dir) &#123; // 对事件指令进行处理 const eventType = dir.split(':')[1] const cb = vm.methods &amp;&amp; vm.methods[exp] if (eventType &amp;&amp; cb) &#123; node.addEventListener(eventType, cb.bind(vm), false) &#125; &#125;, compileModel: function (node, vm, exp) &#123; // 对 v-model 进行处理 let val = vm[exp] const self = this this.modelUpdater(node, val) node.addEventListener('input', function (e) &#123; const newValue = e.target.value self.vm[exp] = newValue // 实现 view 到 model 的绑定 &#125;) &#125;,&#125;在上述代码的 compileTest 函数中看到了期盼已久的 Watcher 实例化，对 Watcher 作用模糊的朋友可以往上回顾下 Watcher 的作用。另外在 compileModel 函数中看到了本文最开始提到的双向绑定流中的 View 到 Model 是借助 input 监听事件变化实现的。项目地址本文记录了些阅读 mvvm 框架源码关于双向绑定的心得，并动手实践了一个简版的 mvvm 框架，不足之处在所难免，欢迎指正。项目演示项目地址]]></content>
      <categories>
        <category>Mvvm</category>
      </categories>
      <tags>
        <tag>Mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结 —— 在路上]]></title>
    <url>%2Fposts%2Fb9cd3f63%2F</url>
    <content type="text"><![CDATA[不久前年会主题征集活动中，我提交的主题是《在路上》，和骑手们一样，我们亦不是在路上呢？恰逢踏入社会一年之际写下第一篇年终总结，百感交集，有初融入团队的喜悦、有独自完成需求的兴奋、有一次次团建的畅饮也有过为自己能力不足的懊恼以及与好友离别的感伤。通过这篇总结，希望能记录些琐事，并给 2018 年的自己定下 promise。启程按捺不住走出校园的兴奋，走入我达新世界的大门。当时未进公司的时候，在朋友圈中看到的小伙伴们的照片，当时心中一阵惊叹，”这么帅！！要拖后腿了”，不曾想到后来几个月和每个人发生的故事，已然成为生命中不可或缺的色彩了。时隔一年当再次回味这张照片时，似乎里面藏着初心。春节结束后公司如期举行了年会，我在倒数第二个节目中独奏了二胡~，前端部门的年会中奖率也是全公司最高的，一度让其他部门的人说是改了脚本o(╯□╰)o。运气也是实力的一部分吧，不过我没有中奖。再接着是为期 15 天的小黑屋封闭式开发快递模块，这也是我第一次感觉到了挫败感，让林师傅帮填了好多坑。期间李开复老师来参观我们公司，我也跑去趁了张合照。同时迎来了陪我渡过短暂岁月的小伙伴虾球。一只可爱的猫咪。现在在新主人家过得很好。batman &amp;&amp; hawkeye在往后的一段时间，前端部门内部进行了更细致的分工划分，我被划分到了直营业务组，主要负责 batman(客服关系系统) 以及 hawkeye(运维系统)的开发与维护，期间经历了并参与了 batman、hawkeye 的技术栈迭代，从老鹰眼的 reflux 到 redux，以及 batman 网关独立抽离成一个 ts 项目。为了更好的熟悉 react 全家桶的工作流程，五月份的时候在仿照 batman 和 hawkeye 写了个 demo，现在收获了几百的 Star，也算今年的一大收获吧。o(╯□╰)o下面谈谈今年在做项目的收获和成长：首先是带我进入了奇妙的 React 技术栈 和 ES6 世界，对相关的知识点进行了实践；能合理对组件进行拆分；对 JS 异步流程有了一定认知；对底层组件的设计有了一定的认知；对 git 多人合作的流程有了一定的实践；在遇到不懂的知识时学会进行翻相关文档以及阅读源码；最后在 npm 上尝试发布了第一个包，并用到了 batman 中;谈完收获再来谈谈不足：知识点体系没有梳理成网，比较零散；知识面广度和深度都还欠缺;在项目优化的层面没有特别上心;在和别人交谈时，抓重点能力以及逻辑整合能力有待加强；效率不足，容易被琐事影响；高山仰止分享一位同行的博客中让我感慨良多的话：行远自迩，登高自卑。在写这篇总结前我曾以为这句话是说当你登高的途中看到比你站在更高更远处的人的时候会产生自卑感，现在不经莞尔一笑，风起于青萍之末，浪成于微澜之间，那些让我高高仰望的人不正是有着一颗常人难能企及的大毅力和大心脏吗？而我呢，希望能离那群人能近一点是一点吧。想到现在负责的项目名为 batman，突然谐音想到了 better-man。新年计划做一个让别人靠得住的 better-man。番外随笔今年刷了好多动漫，整体偏热血、玄幻类型，也入了 B 站刷了几部小清新动漫，如四月是你的谎言、宝石之国~，和朋友一起刷了几部有意义的电影，比如爱乐之城、寻梦环游记~；另外从 4 月份开始使用网易云音乐来，累计听了七八千首歌吧，基本码代码的时候都会带着耳机~，以英文歌、民谣为主，我的歌单如下；在游戏方面发挥稳定，王者荣耀上了最强王者以及为团队拿下个冠军，不过感觉花了太多时间在上面，浪费了不少原定的计划~，不过也算是青春的成长吧。公司年假即将会去曼巴玩上一段时间，也将算是我第一次出国。看书方面主要是技术类的，大概阅读了 6、7 本，这个比较尴尬了，看书看得慢而且看过的知识点也不是完全吃透了，新年期待改善。个人产出方面也比较低产，翻译文章和原创文章加起来十几篇~，我把它们集合在了 blog这个项目里。不过也有值得高兴的事，搭建了自己的博客，并且写文章的深度自己感觉有所提高(虽然依然菜)。然后很遗憾的是今年的技术交流会一场也没参加成，怪自己的消息不灵通加上水平的不足。总结展望篇这部分是对自己打算要成为一个 better-man 的一个 promise 吧。就结合文章中提到的不足点进行相应的改善(自己想到解决方案的先记下来了)，也就是新年的计划。望监督。problenflag知识点碎片化对已有的知识点进行思维脑图的整理，对将来的知识点也采取思维脑图的方式进行学习知识面广度和深度欠缺参与到一个千星 Star 的开源项目的改善，提高阅读源码的能力，阅读 6 本技术书籍，阅读 1 本非技术书籍项目优化方面没有用心课外学习积累相关方面知识并尝试用到公司项目中没去成技术交流会带有目的性地参加 1 到 2 场前端技术交流会沟通能力不足避免讲话结巴，加强语言组织能力和逻辑能力，没想清楚问题之前不要轻易回答效率不足加强自己的自控能力，规定的时间做规定的事情，做到按时起睡，不晚于 8 点半起床]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试造了个工具类库，名为 Diana]]></title>
    <url>%2Fposts%2F4490810f%2F</url>
    <content type="text"><![CDATA[项目地址: diana文档地址: http://muyunyun.cn/diana/造轮子的意义为啥已经有如此多的前端工具类库还要自己造轮子呢？个人认为有以下几个观点吧：定制性强，能根据自己的需求为主导延伸开发。万一一不小心还能帮到别人（比如 React 库）；纸上得来终觉浅，很多流行的库，只是照着它们的 API 进行使用，其实这些库里蕴含着大量的知识、技巧，最好的办法就是仿照它们来写些小 demo，从而体会这些库的精髓；造轮子的过程中能让自己体会到与平常业务开发不一样的乐趣；比如和日常业务开发中很大的一个区别是会对测试用例具有比较严格的要求；而且写文档能力提升了。就先瞎编到这里了。。。抛开内部方法(写相应的专题效果可能会更好，所以这里先略过)，下面分享一些开发 diana 库 时的一些心得：项目目录结构1234567891011121314151617181920212223242526272829303132├── LICENSE 开源协议├── README-zh_en.md 英文说明文档├── README.md 中文说明文档├── coverage 代码覆盖率文件├── docs 文档目录│ └── static-parts│ ├── index-end.html 静态文档目录结尾文件│ └── index-start.html 静态文档目录开头文件├── karma.conf.js karma 配置文件├── lib│ ├── diana.back.js 服务端引用入口│ └── diana.js 浏览器引用入口├── package.json├── script│ ├── build.js 构建文件│ ├── check.js 结合 pre-commit 进行 eslint 校验│ ├── tag-script.js 自动生成文档的标签│ ├── web-script.js 自动生成文档│ ├── webpack.browser.js 浏览器端 webpack 配置文件│ └── webpack.node.js 服务器端 webpack 配置文件├── snippets├── src│ ├── browser 浏览器端方法│ ├── common 共用方法│ ├── node node 端方法│ └── util.js 库内通用方法├── tag_database 文档标签└── test 测试文件 ├── browserTest ├── commonTest ├── index.js └── nodeTest目录结构也随着方法的增多在不停迭代当中，建议直接到库中查看最新的目录结构。相应地，具体的方法会随着时间迭代，所以首先推荐查看文档，点击如下图的 Ⓢ 就能查看源码。让模块同时在 Node.js 与浏览器中运行我们可以通过如下方法来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现我们的功能。12// Only Node.JS has a process variable that is of [[Class]] processconst isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的提议，目前 webpack 和 rollup 都已经支持这个字段了。给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 main 字段 和 module 字段会被忽略，但是这会导致打包工具不会优化你的代码。详细信息请参考这个问题。在 diana 库 为了在不同环境中使用适当的文件，在 package.json 中进行了如下声明：12"browser": "lib/diana.js","main": "lib/diana.back.js", // 或者 "module": "lib/diana.back.js",这样一来，在 node 环境中，引用的是 lib/diana.back.js 文件，在浏览器环境中，引用的是 lib/diana.js 文件。然后就能愉快地在浏览器端和 node 端愉快地使用自己特有的 api 了。常见模块规范比较另外为了使 diana 库 的打包文件兼容 node 端、以及浏览器端的引用，选择了 UMD 规范进行打包，那么为什么要选择 UMD 规范呢？让我们看下以下几种规范之间的异同：CommonJSCommonJs 是服务器端模块的规范，Node.js 采用了这个规范。这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、服务器网关接口、包管理等。根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象。CommonJS 加载模块是同步的。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD、CMD 解决方案。AMD、CMDAMD 是 RequireJS 在推广过程中对模块定义的规范化产物。AMD 推崇提前执行。123456 // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; a.doSomething() b.doSomething() ...&#125;)CMD 是 SeaJS 在推广过程中对模块定义的规范化产物。CMD 推崇依赖就近。12345678// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') b.doSomething() ...&#125;)UMDUMD 是 AMD 和 CommonJS 的结合。因为 AMD 是以浏览器为出发点的异步加载模块，CommonJS 是以服务器为出发点的同步加载模块，所以人们想出了另一个更通用的模式 UMD，来解决跨平台的问题。diana 库 选择了以 umd 方式进行输出，来看下 UMD 做了啥：123456789101112(function (root, factory) &#123; if (typeof exports === 'object' &amp;&amp; typeof module === 'object') &#123; // UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 CommonJS 模式 module.exports = factory() &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // 接着判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。 define([], factory) &#125; else if (typeof exports === 'object') &#123; // CommonJS 的另一种形式 exports['diana'] = factory() &#125; else root['diana'] = factory() // Window&#125;)(this, function() &#123; return module&#125;)测试踩坑之路代码覆盖率单元测试的代码覆盖率统计，是衡量测试用例好坏的一个的方法。但凡是线上用的库，基本上都少不了高质量的代码覆盖率的检测。如下图为 diana 库的测试覆盖率展示。可以看到覆盖率分为以下 4 种类型，行覆盖率（line coverage）：是否每一行都执行了？函数覆盖率（function coverage）：是否每个函数都调用了？分支覆盖率（branch coverage）：是否每个if代码块都执行了？语句覆盖率（statement coverage）：是否每个语句都执行了？番外：github 上显示的覆盖率是根据行覆盖率来展示的。mocha + istanbul最初的版本, 仅仅用到 mocha 进行测试 *.test.js 文件，然后在 codecov 得到测试覆盖率。引人 karma如果仅仅测试 es5、es6 的语法，其实用 mocha 就已经够用了，但是涉及到测试 Dom 操作的语法等就必须建立一个浏览器，在上面进行测试。karma 的作用其实就是自动帮我们建立一个测试用的浏览器环境。为了让浏览器支持 Common.js 规范，中间用了 karma + browserify，尽管测试用例都跑通了，但是最后的代码覆盖率的文件里只有各个方法的引用路径。最后只能又回到 karma + webpack 来，这里又踩到一个坑，打包编译JS代码覆盖率问题，踩了一些坑后，终于实现了可以查看编译前代码的覆盖率。图如下：通过这幅图我们能清晰地看到源代码中测试用例跑过各行代码的次数(左侧的数字)，以及测试用例没有覆盖到的代码(图中红色所示)。然后我们就能改善相应的测试用例从而提高测试覆盖率。配置文件，核心部分如下:12345678910111213141516171819202122232425262728293031module.exports = function(config) &#123; config.set(&#123; files: ['test/index.js'], // 需载入浏览器的文件 preprocessors: &#123; // 预处理 'test/index.js': ['webpack', 'coverage'] &#125;, webpack: &#123; module: &#123; rules: [&#123; test: /\.js$/, use: &#123; loader: 'sourcemap-istanbul-instrumenter-loader' &#125;, // 这里用 istanbul-instrumenter-loader 插件的 0.0.2 版本，其它版本有坑~ exclude: [/node_modules/, /\.spec.js$/], &#125;], &#125; &#125;, coverageReporter: &#123; type: 'lcov', // 貌似只能支持这种类型的读取 dir: 'coverage/' &#125;, remapIstanbulReporter: &#123; // 生成 coverage 文件 reports: &#123; 'text-summary': null, json: 'coverage/coverage.json', lcovonly: 'coverage/lcov.info', html: 'coverage/html/', &#125; &#125;, reporters: ['progress', 'karma-remap-istanbul'], // remap-isbanbul 也报了一个未找到 sourcemap 的 error，直接注释了 remap-istanbul 包的 CoverageTransformer.js 文件的 169 行，以后有机会再捣鼓吧。（心累） ... &#125;)&#125;总结本文围绕 diana 库 对造轮子的意义，模块兼容性，测试用例进行了思考总结。后续会对该库流程自动化以及性能上做些分享。该库参考学习了很多优秀的库，感谢 underscore、outils、ec-do、30-seconds-of-code 等库对我的帮助。最后欢迎各位大佬在 issues 尽情吐槽。]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走近 Python (类比 JS)]]></title>
    <url>%2Fposts%2Fa9d08041%2F</url>
    <content type="text"><![CDATA[本文首发在 个人博客Python 是一门运用很广泛的语言，自动化脚本、爬虫，甚至在深度学习领域也都有 Python 的身影。作为一名前端开发者，也了解 ES6 中的很多特性借鉴自 Python (比如默认参数、解构赋值、Decorator等)，同时本文会对 Python 的一些用法与 JS 进行类比。不管是提升自己的知识广度，还是更好地迎接 AI 时代，Python 都是一门值得学习的语言。数据类型在 Python 中，最常用的能够直接处理的数据类型有以下几种：数字[整数(int)、浮点型(float)、长整型(long)、复数(complex)]字符串(str)布尔值(bool)空值(None)除此之外，Python 还提供了列表[list]、字典[dict] 等多种数据类型，这在下文中会介绍。类型转换与类型判断与 JS 十分类似，python 也能实现不同数据类型间的强制与隐式转换，例子如下：强制类型转换:1234567int('3') # 3str(3.14) # '3.14'float('3.14') # 3.14# 区别于 JS 只有 Number 一种类型，Python 中数字中的不同类型也能相互强制转换float(3) # 3.0bool(3) # Truebool(0) # False隐式类型转换:123451 + 1.0 # 2.01 + False # 11.0 + True # 2.0# 区别于 JS 的 String + Number = String, py 中 str + int 会报错1 + '1' # TypeError: cannot concatenate 'str' and 'int' objects此外写代码的时候经常会需要判断值的类型，可以 使用 python 提供的 type() 函数获取变量的类型，或者使用 isinstance(x, type) 来判断 x 是否属于相应的 type 类型。123456type(1.3) == float # Trueisinstance('a', str) # Trueisinstance(1.3, int) # Falseisinstance(True, bool) # Trueisinstance([], list) # Trueisinstance(&#123;&#125;, dict) # True有序集合类型集合是指包含一组元素的数据结构，有序集合即集合里面的元素是是按照顺序排列的，Python 中的有序集合大概有以下几类：list, tuple, str, unicode。list 类型Python 中 List 类型类似于 JS 中的 Array,1234567891011L = [1, 2, 3]print L[-1] # '3'L.append(4) # 末尾添加元素print L # [1, 2, 3, 4]L.insert(0, 'hi') # 指定索引位置添加元素print L # ['hi', 1, 2, 3, 4]L.pop() # 末尾移除元素 L.pop(2) ?????? 2 ???print L # ['hi', 1, 2, 3]tuple 类型tuple 类型是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple 一旦创建完毕，就不能修改了。123456789t = (1, 2, 3)print t[0] # 1t[0] = 11 # TypeError: 'tuple' object does not support item assignmentt = (1)print t # 1 t 的结果是整数 1t = (1,) # 为了避免出现如上有歧义的单元素 tuple，所以 Python 规定，单元素 tuple 要多加一个逗号“,”print t # (1,)无序集合类型dict 类型Python 中的 dict 类型类似于 JS 中的 {} (最大的不同是它是没有顺序的), 它有如下特点:查找速度快 (无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样)占用内存大 (与 list 类型相反)dict 中的 key 不能重复dict 中存储的 key-value 序对是没有顺序的1234567891011121314d = &#123; 'a': 1, 'b': 2, 'c': 3&#125;print d # &#123;'a': 1, 'c': 3, 'b': 2&#125; 可以看出打印出的序对没有按正常的顺序打出# 遍历 dictfor key,value in d.items(): print('%s: %s' % (key,value))# a: 1# c: 3# b: 2set 类型有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，而且要保证这个集合的元素不会重复，这时，set 类型就派上用场了。set 类型有如下特点：set 存储的元素和 dict 的 key 类似，必须是不变对象set 存储的元素也是没有顺序的12345678s = set(['A', 'B', 'C', 'C'])print s # set(['A', 'C', 'B'])s.add('D')print s # set(['A', 'C', 'B', 'D'])s.remove('D')print s # set(['A', 'C', 'B'])Python 中的迭代在介绍完 Python 中的有序集合和无序集合类型后，必然存在遍历集合的 for 循环。但是和其它语言的标准 for 循环不同，Python 中的所有迭代是通过 for … in 来完成的。以下给出一些常用的迭代 demos:索引迭代：1234567L = ['apple', 'banana', 'orange']for index, name in enumerate(L): # enumerate() 函数把 ['apple', 'banana', 'orange'] 变成了类似 [(0, 'apple), (1, 'banana'), (2, 'orange')] 的形式 print index, '-', name# 0 - apple# 1 - banana# 2 - orange迭代 dict 的 value:1234567d = &#123; 'apple': 6, 'banana': 8, 'orange': 5 &#125;print d.values() # [6, 8, 5]for v in d.values() print v# 6# 8# 5迭代 dict 的 key 和 value:123456d = &#123; 'apple': 6, 'banana': 8, 'orange': 5 &#125;for key, value in d.items() print key, ':', value# apple : 6# banana: 8# orange: 5切片操作符Python 提供的切片操作符类似于 JS 提供的原生函数 slice()。有了切片操作符，大大简化了一些原来得用循环的操作。12345L = ['apple', 'banana', 'orange', 'pear']L[0:2] # ['apple', 'banana'] 取前 2 个元素L[:2] # ['apple', 'banana'] 如果第一个索引是 0，可以省略L[:] # ['apple', 'banana', 'orange', 'pear'] 只用一个 : ，表示从头到尾L[::2] # ['apple', 'orange'] 第三个参数表示每 N 个取一个，这里表示从头开始，每 2 个元素取出一个来列表生成器如果要生成 [1x1, 2x2, 3x3, …, 10x10] 怎么做？方法一是循环：123L = []for x in range(1, 11): L.append(x * x)但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的 list：123# 把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来[x * x for x in range(1, 11)]# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]列表生成式的 for 循环后面还可以加上 if 判断(类似于 JS 中的 filter() 函数)，示例如下：12[x * x for x in range(1, 11) if x % 2 == 0]# [4, 16, 36, 64, 100]for 循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。12[m + n for m in 'ABC' for n in '123']# ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']Python 函数默认参数JS 中 ES6 的 默认参数正是借鉴于 Python，用法如下：12345def greet(name='World'): print 'Hello, ' + name + '.'greet() # Hello, World.greet('Python') # Hello, Python.可变参数类似于 JS 函数中自动识别传入参数的个数，Python 也提供了定义可变参数，即在可变参数的名字前面带上个 * 号。123456def fn(*args): print argsfn() # ()fn('a') # ('a',)fn('a', 'b') # ('a', 'b')Python 解释器会把传入的一组参数组装成一个 tuple 传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。常用高阶函数Python 中常用的函数 (map、reduce、filter) 的作用和 JS 中一致，只是用法稍微不同。map 函数: 接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。123def f(x): return x * xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # [1, 4, 9, 16, 25, 36, 49, 64, 81]reduce 函数: 接收一个函数 f 和一个 list(可以接受第三个值作为初始值)，reduce() 对 list 的每个元素反复调用函数 f，并返回最终结果值。1234def f(x, y): return x * yreduce(f, [1, 3, 5]) # 15filter 函数: 接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter() 根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。1234def is_odd(x): return x % 2 == 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17]) # [1, 7, 9, 17]匿名函数和 JS 的匿名函数不同的地方是，Python 的匿名函数中只能有一个表达式，且不能写 return。拿 map() 函数为例：1map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]) # [1, 4, 9, 16, 25, 36, 49, 64, 81]关键词 lambda 表示匿名函数，冒号前面的 x 表示函数参数，可以看出匿名函数 lambda x: x* x 实际上就是:12def f(x): return x * x闭包之前写过一些关于 JS 闭包的文章，比如 深入浅出JavaScript之闭包（Closure）、以及 读书笔记-你不知道的 JavaScript (上)，Python 中闭包的定义和 JS 中的是一致的即：内层函数引用了外层函数的变量，然后返回内层函数。下面来看下 Py 中闭包之 for 循环经典问题：1234567891011# 希望一次返回3个函数，分别计算1x1,2x2,3x3:def count(): fs = [] for i in range(1, 4): def f(): return i * i fs.append(f) return fsf1, f2, f3 = count() # 这种写法相当于 ES6 中的解构赋值print f1(), f2(), f3() # 9 9 9老问题了，f1(), f2(), f3() 结果不应该是 1, 4, 9 吗，实际结果为什么都是 9 呢？原因就是当 count() 函数返回了 3 个函数时，这 3 个函数所引用的变量 i 的值已经变成了 3。由于 f1、f2、f3 并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时，i 已经变为 3 了。要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。代码修改如下:方法一: 可以理解为创建了一个封闭的作用域，i 的 值传给 j 之后，就和 i 没任何关系了。每次循环形成的闭包都存进了内存中。12345678910111213def count(): fs = [] for i in range(1, 4): def f(j): def g(): # 方法一 return j * j return g r = f(i) fs.append(r) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 1 4 9方法二：思路比较巧妙，用到了默认参数 j 在函数定义时可以获取到 i 的值，虽然没有用到闭包，但是和方法一有异曲同工之处。12345678910def count(): fs = [] for i in range(1, 4): def f(j = i): # 方法二 return j * j fs.append(f) return fsf1, f2, f3 = count()print f1(), f2(), f3() # 1 4 9decorator 装饰器ES6 的语法中的 decorator 正是借鉴了 Python 的 decorator。decorator 本质上就是一个高阶函数，它接收一个函数作为参数，然后返回一个新函数。那装饰器的作用在哪呢？先上一段日常项目中用 ts 写的网关代码：12345678910@Post('/rider/detail') // URL 路由@log() // 打印日志 @ResponseBody public async getRiderBasicInfo( @RequestBody('riderId') riderId: number, @RequestBody('cityId') cityId: number, ) &#123; const result = await this.riderManager.findDetail(cityId, riderId) return result &#125;可以看出使用装饰器可以极大地简化代码，避免每个函数(比如日志、路由、性能检测)编写重复性代码。回到 Python 上，Python 提供的 @ 语法来使用 decorator，@ 等价于 f = decorate(f)。下面来看看 @log() 在 Python 中的实现:123456789101112131415161718# 我们想把调用的函数名字给打印出来@log()def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print factorial(10)# 来看看 @log() 的定义def log(): def log_decorator(f): def fn(x): print '调用了函数' + f.__name__ + '()' return f(x) return fn return log_decorator# 结果# 调用了函数 factorial()# 3628800class面向对象编程面向对象编程是一种程序设计范式，基本思想是：用类定义抽象类型，然后根据类的定义创建出实例。在掌握其它语言的基础上，还是比较容易理解这块知识点的，比如从下面两种写法可以看出不同语言的语言特性间竟然有如此多的共性。es6: (附：本文的主题是 python，所以只是初略展示下 js 中类的定义以及实例的创建，为了说明写法的相似性)12345678class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125;&#125;const child1 = new Person('Xiao Ming', 10)Python: (核心要点写在注释中)12345678910111213141516# 定义一个 Person 类：根据 Person 类就可以造成很多 child 实例class Person(object): address = 'Earth' # 类属性 (实例公有) def __init__(self, name, age): # 创建实例时，__init__()方法被自动调用 self.name = name self.age = age def get_age(self): # 定义实例方法，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和普通函数是一样的 return self.agechild1 = Person('Xiao Ming', 10)child2 = Person('Xiao Hong', 9)print child1.name # 'Xiao Ming'print child2.get_age() # 9print child1.address # 'Earth'print child2.address # 'Earth'继承child 属于 Student 类，Student 类属于 People 类，这就引出了继承: 即获得了父类的方法属性后又能添加自己的方法属性。12345678910111213class Person(object): def __init__(self, name, age): self.name = name self.age = ageclass Student(Person): def __init__(self, name, age, grade): super(Student, self).__init__(name, age) # 这里也能写成 Person.__init__(self, name, age) self.grade = grades = Student('Xiao Ming', 10, 90)print s.name # 'Xiao Ming'print s.grade # 90可以看到子类在父类的基础上又增加了 grade 属性。我们可以再来看看 s 的类型。12isinstance(s, Person)isinstance(s, Student)可以看出，Python 中在一条继承链上，一个实例可以看成它本身的类型，也可以看成它父类的类型。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 异步异闻录]]></title>
    <url>%2Fposts%2F7b9fdc87%2F</url>
    <content type="text"><![CDATA[提到 Node.js, 我们脑海就会浮现异步、非阻塞、单线程等关键词，进一步我们还会想到 buffer、模块机制、事件循环、进程、V8、libuv 等知识点。本文起初旨在理顺 Node.js 以上易混淆概念，然而一入异步深似海，本文尝试基于 Node.js 的异步展开讨论，其他的主题只能日后慢慢补上了。(附：亦可以把本文当作是朴灵老师所著的《深入浅出 Node.js》一书的小结)。异步 I/ONode.js 正是依靠构建了一套完善的高性能异步 I/O 框架，从而打破了 JavaScript 在服务器端止步不前的局面。异步 I/O VS 非阻塞 I/O听起来异步和非阻塞，同步和阻塞是相互对应的，从实际效果而言，异步和非阻塞都达到了我们并行 I/O 的目的，但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。注意，操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。调用阻塞 I/O 的过程：调用非阻塞 I/O 的过程：在此先引人一个叫作轮询的技术。轮询不同于回调，举个生活例子，你有事去隔壁寝室找同学，发现人不在，你怎么办呢？方法1，每隔几分钟再去趟隔壁寝室，看人在不；方法2，拜托与他同寝室的人，看到他回来时叫一下你；那么前者是轮询，后者是回调。再回到主题，阻塞 I/O 造成 CPU 等待浪费，非阻塞 I/O 带来的麻烦却是需要轮询去确认是否完全完成数据获取。从操作系统的这个层面上看，对于应用程序而言，不管是阻塞 I/O 亦或是 非阻塞 I/O，它们都只能是一种同步，因为尽管使用了轮询技术，应用程序仍然需要等待 I/O 完全返回。Node 的异步 I/O完成整个异步 I/O 环节的有事件循环、观察者、请求对象以及 I/O 线程池。事件循环在进程启动的时候，Node 会创建一个类似于 whlie(true) 的循环，每一次执行循环体的过程我们称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在相关的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。伪代码如下：12345678while(ture) &#123; const event = eventQueue.pop() if (event &amp;&amp; event.handler) &#123; event.handler.execute() // execute the callback in Javascript thread &#125; else &#123; sleep() // sleep some time to release the CPU do other stuff &#125;&#125;观察者每个 Tick 的过程中，如何判断是否有事件需要处理，这里就需要引入观察者这个概念。每个事件循环中有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件都有对应的观察者。请求对象对于 Node 中的异步 I/O 而言，回调函数不由开发者来调用，在 JavaScript 发起调用到内核执行完 id 操作的过渡过程中，存在一种中间产物，它叫作请求对象。请求对象是异步 I/O 过程中的重要中间产物，所有状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完后的回调处理以 fs.open() 为例：12345678fs.open = function(path, flags, mode, callback) &#123; bingding.open( pathModule._makeLong(path), stringToFlags(flags), mode, callback )&#125;fs.open 的作用就是根据指定路径和参数去打开一个文件，从而得到一个文件描述符。从前面的代码中可以看到，JavaScript 层面的代码通过调用 C++ 核心模块进行下层的操作。从 JavaScript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在 uv_fs_open 的调用过程中，会创建一个 FSReqWrap 请求对象，从 JavaScript 层传入的参数和当前方法都被封装在这个请求对象中。回调函数则被设置在这个对象的 oncomplete_sym 属性上。1req_wrap -&gt; object_ -&gt; Set(oncomplete_sym, callback)对象包装完毕后，在 Windows 下，则调用 QueueUserWorkItem() 方法将这个 FSReqWrap 对象推人线程池中等待执行。至此，JavaScript 调用立即返回，由 JavaScript 层面发起的异步调用的第一阶段就此结束(即上图所注释的异步 I/O 第一部分)。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响到 JavaScript 线程的后续操作，如此达到了异步的目的。执行回调组装好请求对象、送入 I/O 线程池等待执行，实际上是完成了异步 I/O 的第一部分，回调通知是第二部分。线程池中的 I/O 操作调用完毕之后，会将获取的结果储存在 req -&gt; result 属性上，然后调用 PostQueuedCompletionStatus() 通知 IOCP，告知当前对象操作已经完成，并将线程归还线程池。在这个过程中，我们动用了事件循环的 I/O 观察者，在每次 Tick 的执行过程中，它会调用 IOCP 相关的 GetQueuedCompletionStatus 方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当做事件处理。I/O 观察者回调函数的行为就是取出请求对象的 result 属性作为参数，取出 oncomplete_sym 属性作为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。小结通过介绍完整个异步 I/O 后，有个需要重视的观点是 JavaScript 是单线程的，Node 本身其实是多线程的，只是 I/O 线程使用的 CPU 比较少；还有个重要的观点是，除了用户的代码无法并行执行外，所有的 I/O (磁盘 I/O 和网络 I/O) 则是可以并行起来的。异步编程Node 是首个将异步大规模带到应用层面的平台。通过上文所述我们了解了 Node 如何通过事件循环实现异步 I/O，有异步 I/O 必然存在异步编程。异步编程的路经历了太多坎坷，从回调函数、发布订阅模式、Promise 对象，到 generator、asycn/await。趁着异步编程这个主题刚好把它们串起来理理。异步 VS 回调对于刚接触异步的新人，很大几率会混淆回调 (callback) 和异步 (asynchronous) 的概念。先来看看维基的 Callback) 条目:In computer programming, a callback is any executable code that is passed as an argument to other code因此，回调本质上是一种设计模式，并且 jQuery (包括其他框架)的设计原则遵循了这个模式。在 JavaScript 中，回调函数具体的定义为：函数 A 作为参数(函数引用)传递到另一个函数 B 中，并且这个函数 B 执行函数 A。我们就说函数 A 叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。因此 callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。讲了这么多让我们来看下同步回调和异步回调的例子：同步回调：12345678910function f2() &#123; console.log('f2 finished')&#125;function f1(cb) &#123; cb() console.log('f1 finished')&#125;f1(f2) // 得到的结果是 f2 finished, f1 finished异步回调：12345678910function f2() &#123; console.log('f2 finished')&#125;function f1(cb) &#123; setTimeout(cb, 1000) // 通过 setTimeout() 来模拟耗时操作 console.log('f1 finished')&#125;f1(f2) // 得到的结果是 f1 finished, f2 finished小结：回调可以进行同步也可以异步调用，但是 Node.js 提供的 API 大多都是异步回调的，比如 buffer、http、cluster 等模块。发布/订阅模式事件发布/订阅模式 (PubSub) 自身并无同步和异步调用的问题，但在 Node 的 events 模块的调用中多半伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。它的应用非常广泛，可以在异步编程中帮助我们完成更松的解耦，甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。以 jQuery 事件监听为例12345$('#btn').on('myEvent', function(e) &#123; // 触发事件 console.log('I am an Event')&#125;)$('#btn').trigger('myEvent') // 订阅事件可以看到，订阅事件就是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。下面我们来看看发布/订阅模式的简易实现。1234567891011121314151617181920212223242526var PubSub = function() &#123; this.handlers = &#123;&#125;&#125;PubSub.prototype.subscribe = function(eventType, handler) &#123; // 注册函数逻辑 if (!(eventType in this.handlers)) &#123; this.handlers[eventType] = [] &#125; this.handlers[eventType].push(handler) // 添加事件监听器 return this // 返回上下文环境以实现链式调用&#125;PubSub.prototype.publish = function(eventType) &#123; // 发布函数逻辑 var _args = Array.prototype.slice.call(arguments, 1) for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) &#123; // 遍历事件监听器 _handlers[i].apply(this, _args) // 调用事件监听器 &#125;&#125;var event = new PubSub // 构造 PubSub 实例event.subscribe('name', function(msg) &#123; console.log('my name is ' + msg) // my name is muyy&#125;)event.publish('name', 'muyy')至此，一个简易的订阅发布模式就实现了。然而发布/订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。Promise/Deferred 模式想象一下，如果某个操作需要经过多个非阻塞的 IO 操作，每一个结果都是通过回调，程序有可能会看上去像这个样子。这样的代码很难维护。这样的情况更多的会发生在 server side 的情况下。代码片段如下：123456789operation1(function(err, result1) &#123; operation2(result1, function(err, result2) &#123; operation3(result2, function(err, result3) &#123; operation4(result3, function(err, result4) &#123; callback(result4) // do something useful &#125;) &#125;) &#125;)&#125;)这时候，Promise 出现了，其出现的目的就是为了解决所谓的回调地狱的问题。让我们看下使用 Promise 后的代码片段：1234567891011promise() .then(operation1) .then(operation2) .then(operation3) .then(operation4) .then(function(value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done()可以看到，使用了第二种编程模式后能极大地提高我们的编程体验，接着就让我们自己动手实现一个支持序列执行的 Promise。(附：为了直观的在浏览器上也能感受到 Promise，为此也写了一段浏览器上的 Promise 用法示例)在此之前，我们先要了解 Promise/A 提议中对单个异步操作所作的抽象定义，定义具体如下所示：Promise 操作只会处在 3 种状态的一种：未完成态、完成态和失败态。Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能相互转化。Promise 的状态一旦转化，将不能被更改。Promise 的状态转化示意图如下：除此之外，Promise 对象的另一个关键就是需要具备 then() 方法，对于 then() 方法，有以下简单的要求:接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。可选地支持 progress 事件回调作为第三个方法。then() 方法只接受 function 对象，其余对象将被忽略。then() 方法继续返回 Promise 对象，已实现链式调用。then() 方法的定义如下：1then(fulfilledHandler, errorHandler, progressHandler)有了这些核心知识，接着进入 Promise/Deferred 核心代码环节：1234567891011121314151617var Promise = function() &#123; // 构建 Promise 对象 // 队列用于存储执行的回调函数 this.queue = [] this.isPromise = true&#125;Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; // 构建 Progress 的 then 方法 var handler = &#123;&#125; if (typeof fulfilledHandler === 'function') &#123; handler.fulfilled = fulfilledHandler &#125; if (typeof errorHandler === 'function') &#123; handler.error = errorHandler &#125; this.queue.push(handler) return this&#125;如上 Promise 的代码就完成了，但是别忘了 Promise/Deferred 中的后者 Deferred，为了完成 Promise 的整个流程，我们还需要触发执行上述回调函数的地方，实现这些功能的对象就叫作 Deferred，即延迟对象。Promise 和 Deferred 的整体关系如下图所示，从中可知，Deferred 主要用于内部来维护异步模型的状态；而 Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。接着来看 Deferred 代码部分的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546var Deferred = function() &#123; this.promise = new Promise()&#125;// 完成态Deferred.prototype.resolve = function(obj) &#123; var promise = this.promise var handler while(handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.fulfilled) &#123; var ret = handler.fulfilled(obj) if (ret &amp;&amp; ret.isPromise) &#123; // 这一行以及后面3行的意思是：一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它 ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 失败态Deferred.prototype.reject = function(err) &#123; var promise = this.promise var handler while (handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.error) &#123; var ret = handler.error(err) if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue this.promise = ret return &#125; &#125; &#125;&#125;// 生成回调函数Deferred.prototype.callback = function() &#123; var that = this return function(err, file) &#123; if(err) &#123; return that.reject(err) &#125; that.resolve(file) &#125;&#125;接着我们以两次文件读取作为例子，来验证该设计的可行性。这里假设第二个文件读取依赖于第一个文件中的内容，相关代码如下：1234567891011121314151617var readFile1 = function(file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;var readFile2 = function(file, encoding) &#123; var deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;readFile1('./file1.txt', 'utf8').then(function(file1) &#123; // 这里通过 then 把两个回调存进队列中 return readFile2(file1, 'utf8')&#125;).then(function(file2) &#123; console.log(file2) // I am file2.&#125;)最后可以看到控制台输出 I am file2，验证成功~，这个案例的完整代码可以点这里查看，并建议使用 node-inspector 进行断点观察，(这段代码里面有些逻辑确实很绕，通过断点调试就能较容易理解了)。从 Promise 链式调用可以清晰地看到队列(先进先出)的知识，其有如下两个核心步骤：将所有的回调都存到队列中；Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它；至此，实现了 Promise/Deferred 的完整逻辑，Promise 的其他知识未来也会继续探究。Generator尽管 Promise 一定程度解决了回调地狱的问题，但是对于喜欢简洁的程序员来说，一大堆的模板代码 .then(data =&gt; {...}) 显得不是很友好。所以爱折腾的开发者们在 ES6 中引人了 Generator 这种数据类型。仍然以读取文件为例，先上一段非常简洁的 Generator + co 的代码：123456co(function* () &#123; const file1 = yield readFile('./file1.txt') const file2 = yield readFile('./file2.txt') console.log(file1) console.log(file2)&#125;)可以看到比 Promise 的写法简洁了许多。后文会给出 co 库的实现原理。在此之前，先归纳下什么是 Generator。可以把 Generator 理解为一个可以遍历的状态机，调用 next 就可以切换到下一个状态，其最大特点就是可以交出函数的执行权（即暂停执行），让我们看如下代码：1234567891011121314151617function* gen(x) &#123; yield (function() &#123;return 1&#125;)() var y = yield x + 2 return y&#125;// 调用方式一var g = gen(1)g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125;// 调用方式二var g = gen(1)g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 3, done: false &#125;g.next(10) // &#123; value: 10, done: true &#125;由此我们归纳下 Generator 的基础知识：Generator 生成迭代器后，等待迭代器的 next() 指令启动。启动迭代器后，代码会运行到 yield 处停止。并返回一个 {value: AnyType, done: Boolean} 对象，value 是这次执行的结果，done 是迭代是否结束。并等待下一次的 next() 指令。next() 再次启动，若 done 的属性不为 true，则可以继续从上一次停止的地方继续迭代。一直重复 2，3 步骤，直到 done 为 true。通过调用方式二，我们可看到 next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。另外我们注意到，上述代码中的第一种调用方式中的 y 值是 undefined，如果我们真想拿到 y 值，就需要通过 g.next(); g.next().value 这种方式取出。可以看出，Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。这时候用于 Generator 函数的自动执行的 co 函数库 登场了。为什么 co 可以自动执行 Generator 函数呢？我们知道，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点：Thunk 函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。co 函数库其实就是将两种自动自动执行器(Thunk 函数和 Promise 对象)，包装成一个库。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或者是 Promise 对象。下面分别用以上两种方法对 co 进行一个简单的实现。基于 Thunk 函数的自动执行在 JavaScript 中，Thunk 函数就是指将多参数函数替换成单参数的形式，并且其只接受回调函数作为参数的函数。Thunk 函数的例子如下：123456789// 正常版本的 readFile(多参数)fs.readFile(filename, 'utf8', callback)// Thunk 版本的 readFile(单参数)function readFile(filename) &#123; return function(callback) &#123; fs.readFile(filename, 'utf8', callback); &#125;;&#125;在基于 Thunk 函数和 Generator 的知识上，接着我们来看看 co 基于 Thunk 函数的实现。(附：代码参考自co最简版实现)1234567891011121314151617function co(generator) &#123; return function(fn) &#123; var gen = generator() function next(err, result) &#123; if(err) &#123; return fn(err) &#125; var step = gen.next(result) if (!step.done) &#123; step.value(next) // 这里可以把它联想成递归；将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 &#125; else &#123; fn(null, step.value) &#125; &#125; next() &#125;&#125;用法如下：12345678910co(function* () &#123; // 把 function*() 作为参数 generator 传入 co 函数 var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt') console.log(file1) // I'm file1 console.log(file2) // I'm file2 return 'done'&#125;)(function(err, result) &#123; // 这部分的 function 作为 co 函数内的 fn 的实参传入 console.log(result) // done&#125;)上述部分关键代码已进行注释，下面对 co 函数里的几个难点进行说明：var step = gen.next(result), 前文提到的一句话在这里就很有用处了：next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值;在上述代码的运行中一共会经过这个地方 3 次，result 的值第一次是空值，第二次是 file1.txt 的内容 I’m file1，第三次是 file2.txt 的内容 I’m file2。根据上述关键语句的提醒，所以第二次的内容会作为 file1 的值(当作上一个yield语句的返回值)，同理第三次的内容会作为 file2 的值。另一处是 step.value(next), step.value 就是前面提到的 thunk 函数返回的 function(callback) {}, next 就是传入 thunk 函数的 callback。这句代码是条递归语句，是这个简易版 co 函数能自动调用 Generator 的关键语句。建议亲自跑一遍代码，多打断点，从而更好地理解，代码已上传github。基于 Promise 对象的自动执行基于 Thunk 函数的自动执行中，yield 后面需跟上 Thunk 函数，在基于 Promise 对象的自动执行中，yield 后面自然要跟 Promise 对象了，让我们先构建一个 readFile 的Promise 对象：12345678function readFile(fileName) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) reject(error) resolve(data) &#125;) &#125;)&#125;在基于前文 Promise 对象和 Generator 的知识上，接着我们来看看 co 基于 Promise 函数的实现:123456789101112function co(generator) &#123; var gen = generator() function next(data) &#123; var result = gen.next(data) // 同上，经历了 3 次，第一次是 undefined，第二次是 I'm file1，第三次是 I'm file2 if (result.done) return result.value result.value.then(function(data) &#123; // 将异步操作包装成 Promise 对象，用 then 方法交回执行权 next(data) &#125;) &#125; next()&#125;用法如下：1234567co(function* generator() &#123; var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt') console.log(file1.toString()) // I'm file1 console.log(file2.toString()) // I'm file2&#125;)这一部分的代码上传在这里，通过观察可以发现基于 Thunk 函数和基于 Promise 对象的自动执行方案的 co 函数设计思路几乎一致，也因此呼应了它们共同的本质 —— 当异步操作有了结果，自动交回执行权。async看上去 Generator 已经足够好用了，但是使用 Generator 处理异步必须得依赖 tj/co，于是 asycn 出来了。本质上 async 函数就是 Generator 函数的语法糖，这样说是因为 async 函数的实现，就是将 Generator 函数和自动执行器，包装进一个函数中。伪代码如下，(注：其中 automatic 的实现可以参考 async 函数的含义和用法中的实现)1234567891011async function fn(args)&#123; // ...&#125;// 等同于function fn(args) &#123; return automatic(function*() &#123; // automatic 函数就是自动执行器，其的实现可以仿照 co 库自动运行方案来实现，这里就不展开了 // ... &#125;)&#125;接着仍然以上文的读取文件为例，来比较 Generator 和 async 函数的写法差异：1234567891011// Generatorvar genReadFile = co(function*() &#123; var file1 = yield readFile('./file1.txt') var file2 = yield readFile('./file2.txt')&#125;)// 改用 async 函数var asyncReadFile = async function() &#123; var file1 = await readFile('./file1.txt') var file2 = await 1 // 等同于同步操作（如果跟上原始类型的值）&#125;总体来说 async/await 看上去和使用 co 库后的 generator 看上去很相似，不过相较于 Generator，可以看到 Async 函数更优秀的几点：内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样；更好的语义。async 和 await 相较于 * 和 yield 更加语义化；更广的适用性。前文提到的 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面则可以是 Promise 或者原始类型的值；返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，因此可以直接使用 then() 方法进行调用；参考资料深入浅出 Node.js理解回调函数JavaScript之异步编程简述理解co执行逻辑co 函数库的含义和用法async 函数的含义和用法]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Node.js 把玩一番 Alfred Workflow]]></title>
    <url>%2Fposts%2F4c23be51%2F</url>
    <content type="text"><![CDATA[插件地址(集成Github、掘金、知乎、淘宝等搜索)作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。一些安利附上一张个人装着的插件的截图。Caffeinate 插件能在指定时间使电脑不黑屏；在 Dash 插件上能轻松查任何文档；Youdao Translate 插件比系统自带的翻译方便许多。插件也是因人而异，大家可以在 Workflow List 上逛逛，各取所需。在用了别人的插件感觉高大上后，便萌发了也写一个插件的想法，计划把自己常逛的网站集合成一个插件，使用特定的缩略词便可快速进行搜索数据，又看了官方称可以使用 bash, zsh, PHP, Ruby, Python, Perl, Apple Script 开发 Alfred Workflow。于是我选择了 Node.js 作为开发语言，开发了一款 commonSearch, 开发完效果如下(集成了Github、掘金、知乎、淘宝等搜索)。开发阶段在开发前，得先对一些特定的操作步骤和知识点有一定的认知，这样开发时就基本上没有大碍了。前置步骤可以先参考 如何去写一个第三方的 workflow 的开始部分, 完成基本工作流的搭建，如下图是我搭建好的基本工作流连线。在 Script 中，可以看到 /usr/local/bin/node common_search.js 相当于就是在调用该插件的时候起了一个 node 服务，后面的 1 是为了区分当前调用的是哪个搜索手动传入 common_search.js 的，{query} 则是用户查询的名称。使用 Node.js 调用 JSON API最初开发参考了 知乎搜索 这个项目，它是基于 cheerio 这个模块对请求到的网页数据进行分析爬取，但是引入了 cheerio 后，插件体积多了 2M 多，这对于一个插件来说太不友好了，所以这可能是 python 之类的语言更适合开发类似插件的原因吧(猜想:python 不需要引人第三方库就能进行爬虫)，于是我开始选择提供 JSON API 的接口，比如找寻掘金返回数据的接口。首先打开 chrome 控制台，这可能对前端工程师比较熟悉了。从而找到了掘金返回搜索数据的接口是 https://search-merger-ms.juejin.im/v1/search?query={query}&amp;page=0&amp;raw_result=false&amp;src=web接着愉快地使用 node 提供的 https 模块，这里有一个注意点，http.get() 回调中的 res 参数不是正文，而是 http.ClientResponse 对象，所以我们需要组装内容。12345678910111213141516171819202122232425262728293031var options = &#123; host: 'search-merger-ms.juejin.im', path: '/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web' &#125; https.get(options, function (res) &#123; res.on('data', (chunk) =&gt; &#123; var content += chunk &#125;).on('end', function () &#123; var jsonContent = JSON.parse(content) &amp;&amp; JSON.parse(content).d var result_array = [] for (var i = 0; i &lt; jsonContent.length; i++) &#123; if (jsonContent[i].user.jobTitle === '') &#123; result_array.push(&#123; title: subtitle: arg: icon: &#123; path: join(__dirname, 'xx.png'), &#125;, mods: &#123; cmd: &#123;&#125; &#125; &#125;) &#125; &#125; content = '' console.log(JSON.stringify(&#123; items: result_array &#125;)) &#125;) &#125;)这种方法应该是最直接的调用 JSON API 的方案了，当然也可以引人第三方模块 request 后解析 JSON，示例如下：123456789101112131415161718var request = require('request')var url = 'search-merger-ms.juejin.im/v1/search?query=' + encodeURI(keyword) + '&amp;page=0&amp;raw_result=false&amp;src=web'request.get(&#123; url: url, json: true, headers: &#123;'User-Agent': 'request'&#125; &#125;, (err, res, data) =&gt; &#123; if (err) &#123; console.log('Error:', err); &#125; else if (res.statusCode !== 200) &#123; console.log('Status:', res.statusCode); &#125; else &#123; // data is already parsed as JSON: console.log(data.html_url); &#125;&#125;);还有一点要注意的是返回值的字段是固定的，具体可以参考它的官方解释，琢磨了好久才把 JS 中的 Icon 自定义的格式找出来。12345title: 主标题subtitle: 内容行arg: 跳转链接icons: 图标mods：定制键盘按键的方法对于 Github、掘金、知乎、淘宝的搜索都是基于以上思路进行开发的，就是对于具体返回的 JSON 数据进行了不同处理，虽然粗糙，但也算完成了第一个 Alfred Workflow 插件的开发。尾声本文的知识点写的不是特别丰满，一是就是对开发这个插件的小结，另外就是抛砖引玉了，能让更多的小伙伴了解开发一个插件并不是难事，同时让更多的朋友开发出更多有意义，有趣的 alfred-workflow 插件也算是本文分享的一个初衷了。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>alfred workflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 JavaScript 到 TypeScript]]></title>
    <url>%2Fposts%2F66a54fc2%2F</url>
    <content type="text"><![CDATA[文中的案例代码已经上传到 TypeScriptTypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。TypeScript 简介TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。使用 TypeScript 的原因JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~)数据类型String 类型一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。12let name: string = 'muyy'let name2: String = 'muyy'Boolen 类型boolean是 true 或 false 的值，所以 let isBool3: boolean = new Boolean(1) 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。1let isBool1: boolean = falseNumber 类型1let number: number = 10;Array 类型数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 Array&lt;type&gt; or type[] 语法为数组内的元素指定类型12345let arr:number[] = [1, 2, 3, 4, 5];let arr2:Array&lt;number&gt; = [1, 2, 3, 4, 5];let arr3:string[] = ["1","2"];let arr4:Array&lt;string&gt; = ["1","2"];Enums 类型列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：123enum Role &#123;Employee = 3, Manager, Admin&#125;let role: Role = Role.Employeeconsole.log(role) // 3Any 类型any 是默认的类型，其类型的变量允许任何类型的值：12let notSure:any = 10;let notSure2:any[] = [1,"2",false];Void 类型JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：123function alertName(): void &#123; console.log('My name is muyy')&#125;函数为函数定义类型我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。1234567891011function add(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add2 = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125;let add3: (x: string, y: string) =&gt; string = function(x: string, y: string): string&#123; return "Hello TypeScript";&#125;可选参数和默认参数JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：1234567function buildName(firstName: string, lastname?: string)&#123; console.log(lastname ? firstName + "" + lastname : firstName)&#125;let res1 = buildName("鸣","人"); // 鸣人let res2 = buildName("鸣"); // 鸣let res3 = buildName("鸣", "人", "君"); // Supplied parameters do not match any signature of call target.如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：123456function buildName2(firstName = "鸣", lastName?: string)&#123; console.log(firstName + "" + lastName)&#125;let res4 = buildName2("人"); // undefined人let res5 = buildName2(undefined, "人"); // 鸣人类传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。类1234567891011121314class Person&#123; name:string; // 这个是对后文this.name类型的定义 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; print()&#123; return this.name + this.age; &#125;&#125;let person:Person = new Person('muyy',23)console.log(person.print()) // muyy23我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。继承12345678910111213141516171819202122232425class Person&#123; public name:string; // public、private、static 是 typescript 中的类访问修饰符 age:number; constructor(name:string,age:number)&#123; this.name = name; this.age = age; &#125; tell()&#123; console.log(this.name + this.age); &#125;&#125;class Student extends Person&#123; gender:string; constructor(gender:string)&#123; super("muyy",23); this.gender = gender; &#125; tell()&#123; console.log(this.name + this.age + this.gender); &#125;&#125;var student = new Student("male");student.tell(); // muyy23male这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。存储器TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。对于存取器有下面几点需要注意的：首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。12345678910111213141516171819202122232425class Hello&#123; private _name: string; private _age: number; get name(): string &#123; return this._name; &#125; set name(value: string) &#123; this._name = value; &#125; get age(): number&#123; return this._age; &#125; set age(age: number) &#123; if(age&gt;0 &amp;&amp; age&lt;100)&#123; console.log("年龄在0-100之间"); // 年龄在0-100之间 return; &#125; this._age = age; &#125;&#125;let hello = new Hello();hello.name = "muyy";hello.age = 23console.log(hello.name); // muyy接口接口TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。123456789101112interface LabelValue&#123; label: string;&#125;function printLabel(labelObj: LabelValue)&#123; console.log(labelObj.label);&#125;let myObj = &#123; "label":"hello Interface"&#125;;printLabel(myObj);LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。可选属性带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。123456789101112131415161718192021interface Person&#123; name?:string; age?:number;&#125;function printInfo(info:Person)&#123; console.log(info);&#125;let info = &#123; "name":"muyy", "age":23&#125;;printInfo(info); // &#123;"name": "muyy", "age": 23&#125;let info2 = &#123; "name":"muyy"&#125;;printInfo(info2); // &#123;"name": "muyy"&#125;函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。1234567891011interface SearchFunc&#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string,subString: string)&#123; return source.search(subString) !== -1;&#125;;console.log(mySearch("鸣人","鸣")); // trueconsole.log(mySearch("鸣人","缨")); // false可索引类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[&quot;daniel&quot;]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：1234567interface StringArray&#123; [index: number]: string;&#125;let MyArray: StringArray;MyArray = ["是","云","随","风"];console.log(MyArray[2]); // 随类类型与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。我们可以在接口中描述一个方法，在类里实现它，如同下面的 setTime 方法一样：123456789101112interface ClockInterface&#123; currentTime: Date; setTime(d: Date);&#125;class Clock implements ClockInterface&#123; currentTime: Date; setTime(d: Date)&#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125;继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。12345678910111213141516interface Shape&#123; color: string;&#125;interface PenStroke&#123; penWidth: number;&#125;interface Square extends Shape,PenStroke&#123; sideLength: number;&#125;let s = &lt;Square&gt;&#123;&#125;;s.color = "blue";s.penWidth = 100;s.sideLength = 10;模块TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。123456789101112131415161718export interface StringValidator&#123; isAcceptable(s:string): boolean;&#125;var strReg = /^[A-Za-z]+$/;var numReg = /^[0-9]+$/;export class letterValidator implements StringValidator&#123; isAcceptable(s:string): boolean&#123; return strReg.test(s); &#125;&#125;export class zipCode implements StringValidator&#123; isAcceptable(s: string): boolean&#123; return s.length == 5 &amp;&amp; numReg.test(s); &#125;&#125;泛型软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。初探泛型如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 output 和 output2 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：123456789function Hello&lt;T&gt;(arg:T):T&#123; return arg;&#125;let outPut = Hello&lt;string&gt;('Hello Generic');let output2 = Hello('Hello Generic')console.log(outPut);console.log(outPut2);参考资料TypeScript 中文文档TypeScriptTypeScript for Angular 2 - Part 1 (An Introduction)]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 在服务端渲染的实现]]></title>
    <url>%2Fposts%2F2d678a6%2F</url>
    <content type="text"><![CDATA[原文地址：Server-Side React RenderingReact是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？React 在服务端渲染的实现假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。服务端渲染的优势可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。入门接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了相关代码，您可以在其中看到完整的示例。提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 ButterCMS 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以使用你的 GitHub 账号登入 ButterCMS。1234567891011121314151617181920212223242526272829303132333435import React from 'react';import Butter from 'buttercms'const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; getInitialState: function() &#123; return &#123;loaded: false&#125;; &#125;, componentWillMount: function() &#123; butter.post.list().then((resp) =&gt; &#123; this.setState(&#123; loaded: true, resp: resp.data &#125;) &#125;); &#125;, render: function() &#123; if (this.state.loaded) &#123; return ( &lt;div&gt; &#123;this.state.resp.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Hello;启动器代码中包含以下内容：package.json - 依赖项Webpack 和 Babel 配置index.html - app 的 HTML 文件index.js - 加载 React 并渲染 Hello 组件要使应用运行，请先克隆资源库：12git clone ...cd ..安装依赖:1npm install然后启动服务器:1npm run start浏览器输入 http://localhost:8000 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：&quot;start&quot;: webpack-dev-server --watch)如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取:增加服务器端渲染接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看GitHub上的差异。To get started, we’ll install Express, a Node.js server side application framework:开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架：1npm install express --save我们要创建一个渲染我们的 React 组件的服务器：123456789101112131415161718192021222324252627282930313233import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';function handleRender(req, res) &#123; // 把 Hello 组件渲染成 HTML 字符串 const html = ReactDOMServer.renderToString(&lt;Hello /&gt;); // 加载 index.html 的内容 fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; // 把渲染后的 React HTML 插入到 div 中 const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`); // 把响应传回给客户端 res.send(document); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000);让我们分解下程序看看发生了什么事情…handleRender 函数处理所有请求。在文件顶部导入的 ReactDOMServer 类提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法1ReactDOMServer.renderToString(&lt;Hello /&gt;);这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。1const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/,`&lt;div id="app"&gt;$&#123;html&#125;&lt;/div&gt;`);To start the server, update the start script in package.json and then run npm run start:要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 npm run start :123"scripts": &#123; "start": "webpack &amp;&amp; babel-node server.js"&#125;,浏览 http://localhost:3000 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，React repo 有一个 issue，超过 100 条评论讨论了这个问题和各种解决方法。在渲染之前获取数据要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在GitHub上查看完整的差异。To move data fetching before rendering, we’ll install react-transmit:要在渲染之前获取数据，我们需安装 react-transmit：1npm install react-transmit --saveReact Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。这是我们使用 react-transmit 后的组件的代码：12345678910111213141516171819202122232425262728293031323334import React from 'react';import Butter from 'buttercms'import Transmit from 'react-transmit';const butter = Butter('b60a008584313ed21803780bc9208557b3b49fbb');var Hello = React.createClass(&#123; render: function() &#123; if (this.props.posts) &#123; return ( &lt;div&gt; &#123;this.props.posts.data.map((post) =&gt; &#123; return ( &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt; ) &#125;)&#125; &lt;/div&gt; ); &#125; else &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; &#125;&#125;);export default Transmit.createContainer(Hello, &#123; // 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错 initialVariables: &#123;&#125;, // 定义的方法名将成为 Transmit props 的名称 fragments: &#123; posts() &#123; return butter.post.list().then((resp) =&gt; resp.data); &#125; &#125;&#125;);我们已经使用 Transmit.createContainer 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 Transmit.renderToString 而不是 ReactDOM.renderToString 方法12345678910111213141516171819202122232425262728293031import express from 'express';import fs from 'fs';import path from 'path';import React from 'react';import ReactDOMServer from 'react-dom/server';import Hello from './Hello.js';import Transmit from 'react-transmit';function handleRender(req, res) &#123; Transmit.renderToString(Hello).then((&#123;reactString, reactData&#125;) =&gt; &#123; fs.readFile('./index.html', 'utf8', function (err, data) &#123; if (err) throw err; const document = data.replace(/&lt;div id="app"&gt;&lt;\/div&gt;/, `&lt;div id="app"&gt;$&#123;reactString&#125;&lt;/div&gt;`); const output = Transmit.injectIntoMarkup(document, reactData, ['/build/client.js']); res.send(document); &#125;); &#125;);&#125;const app = express();// 服务器使用 static 中间件构建 build 路径app.use('/build', express.static(path.join(__dirname, 'build')));// 使用我们的 handleRender 中间件处理服务端请求app.get('*', handleRender);// 启动服务器app.listen(3000);重新启动服务器浏览到 http://localhost：3000。查看页面源代码，您将看到该页面现在完全呈现在服务器上！更进一步我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 Electrode 或 Next.js。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 Hypernova 。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 React 全家桶搭建一个后台管理系统]]></title>
    <url>%2Fposts%2F9bfbdbf4%2F</url>
    <content type="text"><![CDATA[使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。项目地址以及局部展示项目地址小模块展示：redux在项目中的运用demo展示项目目录结构1234567891011121314151617181920212223242526272829303132├── build.js 项目打包后的文件├── config webpack配置文件│ ├──...│ ├──webpack.config.dev.js 开发环境配置│ ├──webpack.config.prod.js 生产环境配置├── node_modules node模块目录├── public│ └──index.html├── scripts│ ├── build.js 打包项目文件│ ├── start.js 启动项目文件│ └── test.js 测试项目文件├── src│ ├── client 汇聚(入口)目录│ ├── common 核心目录│ │ ├── actions redux中的action│ │ ├── components 通用功能组件│ │ ├── container 通用样式组件│ │ ├── images│ │ ├── pages 页面模块│ │ ├── reducers redux中的reducer│ │ ├── utils 工具类│ │ │ ├── config.js 通用配置│ │ │ ├── menu.js 菜单配置│ │ │ └── ajax.js ajax模块(日后用到)│ │ └── routes.js 前端路由│ └── server 服务端目录(日后用到)│ └── controller├── .gitignore├── package.json├── README.md└── yarn.lock项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。下面对目录结构作以下说明项目最初始是用 create-react-app 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;client 作为入口目录，到时候可以把第三方中间件也放在此处;container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。containercomponent目的如何工作(数据获取,状态更新)如何显示(样式，布局)是否在 Redux 数据流中是否读取数据从 Redux 获取 state从 props 获取数据修改数据向 Redux 派发 actions从 props 调用回调函数实现方式向react-redux生成手写ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。server 层就是作为网关层，日后计划用来写 node 的。技术栈相关虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;webpack(2.x)4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。按需加载babel-plugin-import 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:123456789101112&#123; test: /\.(js|jsx)$/, include: paths.appSrc, loader: require.resolve('babel-loader'), options: &#123; plugins: [ "transform-decorators-legacy", // 引人 ES7 的装饰器 @ ['import', [&#123; libraryName: 'antd', style: true &#125;]], ], cacheDirectory: true, &#125;, &#125;,引人less首先引人 less-loader 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件12345678910111213141516171819202122232425262728293031 test: /\.less$/, use: [ require.resolve('style-loader'), require.resolve('css-loader'), &#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', //https://webpack.js.org/guides/migrating/#complex-options plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader'), options: &#123; modifyVars: &#123; "@primary-color": "#1DA57A" &#125;, // 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。 &#125;, &#125;, ],&#125;,一键发布到 gh-pages用到了 gh-pages ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。引用路径的缩写1234567891011alias: &#123; 'react-native': 'react-native-web', components: path.resolve(__dirname, '..') + '/src/common/components', container: path.resolve(__dirname, '..') + '/src/common/container', images: path.resolve(__dirname, '..') + '/src/common/images', pages: path.resolve(__dirname, '..') + '/src/common/pages', utils: path.resolve(__dirname, '..') + '/src/common/utils', data: path.resolve(__dirname, '..') + '/src/server/data', actions: path.resolve(__dirname, '..') + '/src/common/actions', reducers: path.resolve(__dirname, '..') + '/src/common/reducers', &#125;,配置了引用路径的缩写后，就可以在任意地方如这样引用，比如1import Table from 'components/table'Antd(2.x)antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的设计理念也学到了很多关于UI、UX的知识。该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。React-router(4.x)react-router 4.x和2.x的差异又是特别的大，召唤文档,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。2.x:1234&lt;Route path="/" component=&#123;App&#125;&gt; &lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt; &lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;&lt;/Route&gt;4.x:123&lt;Route path="/" component=&#123;App&#125; /&gt;&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;Fetchfetch 使用比较简单，基本的 promise 用法如下123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log("Oops, error", e))此外还能这样用1234567try &#123; let response = await fetch(url); let data = await response.json(); console.log(data);&#125; catch(e) &#123; console.log("Oops, error", e);&#125;但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 fetch-jsonp 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下123fetchJsonp(url,&#123;method: 'GET'&#125;) .then((res) =&gt;res.json()) .then((data) =&gt; &#123;&#125;)Redux使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇深入Redux架构下面通过把 代办事项 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。首先，在入口目录创建 store12345678const store = createStore(rootReducer)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &#123; routes &#125; &lt;/Provider&gt;, document.getElementById('root'));接着，我使用了 redux-actions 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):123import &#123; createAction &#125; from 'redux-actions'export const setVisibility = createAction('SET_VISIBILITY')没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，123456export const setVisibility = (filter) =&gt; &#123; return &#123; type: "SET_VISIBILITY", filter &#125;&#125;相应的代办事项的 reducers 文件片段:12345export const setVisibility = handleActions(&#123; 'SET_VISIBILITY'(state, action) &#123; return &#123; ...state, ...action.payload&#125; &#125;&#125;, 'SHOW_ALL')使用 redux-actions 后，只要进行如下调用,reducers文件里的SET_VISIBILITY的 action 就能捕获到SHOW_ALL这个状态。12345678import &#123; setVisibility &#125; from 'actions/todoList'@connect( (state) =&gt; (&#123; setVisibility: state.setVisibility, // 这个 setVisibility 是取自 reducers 的 &#125;))dispatch(this.props.dispatch(setVisibility('SHOW_ALL')))connect 来自 react-redux，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 mapStateToProps、mapDispatchToProps。项目的一些扩展计划计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，点我 Star。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-你不知道的 JavaScript (上)]]></title>
    <url>%2Fposts%2F4a895cbd%2F</url>
    <content type="text"><![CDATA[《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。什么是作用域作用域是一套规则，用于确定在何处以及如何查找变量。编译原理JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。分词/词法分析将字符串分解成有意义的代码块，代码块又称词法单元。比如程序var a = 2;会被分解为var、a、=、2、;解析/语法分析将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。代码生成将抽象语法树转换为机器能够识别的指令。理解作用域作用域 分别与编译器、引擎进行配合完成代码的解析引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。编译器负责语法分析以及生成代码。作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。对于 var a = 2 这条语句，首先编译器会将其分为两部分，一部分是 var a，一部分是 a = 2。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！异常对于 var a = 10 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 LHS 查询。 对于 console.log(a) 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 RHS 查询。为什么区分 LHS 和 RHS 是一件重要的事情？在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。作用域的工作模式作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。词法作用域词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:123456789101112function foo() &#123; console.log(a); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar()词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。动态作用域而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。123456789101112function foo() &#123; console.log(a); // 3&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar()函数作用域匿名与具名对于函数表达式一个最熟悉的场景可能就是回调函数了，比如123setTimeout( function() &#123; console.log("I waited 1 second!")&#125;, 1000 )这叫作匿名函数表达式。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。始终给函数表达式命名是一个最佳实践:123setTimeout( function timeoutHandler() &#123; // 我有名字了 console.log("I waited 1 second!")&#125;, 1000 )提升先有声明还是先有赋值考虑以下代码：12345a = 2;var a;console.log(a); // 2考虑另外一段代码123console.log(a); // undefinedvar a = 2;我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。可以看出，先有声明后有赋值。再来看以下代码：123456foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;;这个代码片段经过提升后，实际上会被理解为以下形式:123456789var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123; var bar = ...self... // ...&#125;;这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不是函数表达式就会赋值)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。闭包之前写过关于闭包的一篇文章深入浅出JavaScript之闭包(Closure)循环和闭包要说明闭包，for 循环是最常见的例子。12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125;正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：12345678for (var i = 1; i &lt;= 5; i++) &#123; (function() &#123; var j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)();&#125;还可以对这段代码进行一些改进：1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 ) &#125;)(i);&#125;在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。重返块作用域我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout( function timer() &#123; console.log(j); &#125;, j*1000 )&#125;本质上这是将一个块转换成一个可以被关闭的作用域。此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 )&#125;this全面解析之前写过一篇深入浅出JavaScript之this。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。this词法来看下面这段代码的问题：123456789101112var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log(this.id); &#125;&#125;;var id = "not awesome";obj.cool(); // awesomesetTimeout( obj.cool, 100); // not awesomeobj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;123456789101112131415var obj = &#123; count: 0, cool: function coolFn() &#123; var self = this; if (self.count &lt; 1) &#123; setTimeout( function timer()&#123; self.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome?这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。ES6 中的箭头函数引人了一个叫作 this 词法的行为：12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("awesome?"); &#125;, 100) &#125; &#125;&#125;obj.cool(); // awesome?箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; this.count++; console.log("more awesome"); &#125;.bind( this ), 100) &#125; &#125;&#125;obj.cool(); // more awesome绑定规则函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。默认绑定独立函数调用隐式绑定当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象显示绑定call/applybind（本质是对call/apply函数的封装 fn.apply( obj, arguments )）第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 thisnew 绑定JavaScript 中的 new 机制实际上和面向类的语言完全不同实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。被忽略的 this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：12345678910function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;// 把数组"展开"成参数foo.apply(null, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2);bar(3); // a:2, b:3其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。123456789101112function foo(a, b) &#123; console.log( "a:" + a + ", b:" + b );&#125;var ø = Object.create(null);// 把数组"展开"成参数foo.apply( ø, [2, 3]); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2);bar(3); // a:2, b:3对象JavaScript中的对象有字面形式（比如var a = { .. })和构造形式（比如var a = new Array(..)）。字面形式更常用，不过有时候构造形式可以提供更多选择。作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。复制对象首先看下这个对象：1234let a = &#123; name: 'XiaoMing', habits: ['a', 'b']&#125;从这个对象，先抛出下面几个概念：普通的 = 赋值：b = a，如果修改了 b.name，那么 a.name 也会改变浅复制：如果修改了 b.name, a.name 不会改变，但是修改 b.habits 数组中的值，a.habits 的值也会改变深复制：b 的值改变，不会对 a 产生任何影响再来看下这个对象：12345678910111213141516function anotherFunction() &#123; /*..*/ &#125;var anotherObject = &#123; c: true&#125;;var anotherArray = [];var myObject = &#123; a: 2, b: anotherObject, // 引用，不是复本！ c: anotherArray, // 另一个引用！ d: anotherFunction&#125;;anotherArray.push( myObject )如何准确地表示 myObject 的复制呢？这个例子中除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的深复制方法：1var newObj = JSON.parse( JSON.stringify(someObj) )相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：123456var newObj = Object.assign( &#123;&#125;, myObject );newObj.a; // 2newObj.b === anotherObject; // truenewObj.c === anotherArray; // truenewObj.d === anotherFunction; // true类JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。检查“类”关系思考下面的代码：1234567function Foo() &#123; // ...&#125;Foo.prototype.blah = ...;var a = new Foo();我们如何找出 a 的“祖先”（委托关系）呢？方法一：a instanceof Foo; // true (对象 instanceof 函数)方法二: Foo.prototype.isPrototypeOf(a); // true (对象 isPrototypeOf 对象)方法三: Object.getPrototypeOf(a) === Foo.prototype; // true (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;方法四: a.__proto__ == Foo.prototype; // true构造函数函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。对象关联来看下面的代码：123456789var foo = &#123; something: function() &#123; console.log("Tell me something good..."); &#125;&#125;;var bar = Object.create(foo);bar.something(); // Tell me something good...Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。此书的第二章第6部分就把面对类和继承和行为委托两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到Object.create()的强大。ES6中的Class来看一段 ES6中Class 的例子123456789101112131415161718192021222324252627282930class Widget &#123; constructor(width, height) &#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if (this.$elem) &#123; this.$elem.css(&#123; width: this.width + "px"， height: this.height + "px" &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget &#123; constructor(width, height, label) &#123; super(width, height); this.label = label || "Default"; this.$elem = $("&lt;button&gt;").text(this.label) &#125; render($where) &#123; super($where); this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt) &#123; console.log("Button '" + this.label + "' clicked!") &#125;&#125;除了语法更好看之外，ES6还有以下优点基本上不再引用杂乱的 .prototype 了。Button 声明时直接 “继承” 了 Widget。可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。可以通过 extends 很自然地扩展对象(子)类型。但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。这也是本书作者希望我们思考的问题。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 摸爬滚打之进阶教程]]></title>
    <url>%2Fposts%2Ff55182c5%2F</url>
    <content type="text"><![CDATA[写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了hexo。本文有以下内容:快速实现博客压缩文章链接唯一化添加酷炫的打赏二维码自定义JS和CSS添加酷炫的歌单模块以及播放器github分支管理博客思路秒传图片到七牛云并展现在博客中将博客同时部署到github和coding快速实现博客压缩项目压缩也叫代码丑化, 分别对 html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把 images 进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。蛮多朋友使用了gulp对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块hexo-all-minifier，这个模块集成了对 html、css、js、image 的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。12345678910111213141516171819202122232425html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章链接唯一化也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装1npm install hexo-abbrlink --save在站点配置文件中查找代码permalink，将其更改为:1permalink: posts/:abbrlink/ # “posts/” 可自行更换这里有个知识点：百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。然后在站点配置文件中添加如下代码:1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex可选择模式：crc16 &amp; hexcrc16 &amp; deccrc32 &amp; hexcrc32 &amp; dec添加酷炫的打赏二维码看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)实现这个酷炫二维码的流程如下：首先，分别获得支付宝和微信的收款码接着到芝麻二维码里将两张二维码合并最后到第九工场生成自己喜欢的造型讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上1alipay: /pay.png打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下：123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/自定义JS和CSS博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的添加自定义js样式首先把js文件放在\themes\next\source\js\src文件目录下然后找到\themes\next\layout目录下的布局文件_layout.swig把script引用代码加入到该文件中即可&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;添加自定义css样式添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在\themes\next\source\css\_custom\custom.styl文件中进行样式的添加。添加酷炫的歌单模块以及播放器这个模块借鉴了@小胡子哥。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：核心代码在\themes\next\source\js\src\music\nmlist中，点击看源码，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)解决了这个bug。再接着玩的话，可以给播放器加上歌词的功能。这里有一篇相关文章, 有机会可以去把玩一番。github分支管理博客思路有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件 push 到 user.github.io 的其他分支。我选择了后者。创建muyy(任意)分支创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制12git initgit remote add origin &lt;server&gt;&lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传至muyy分支.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public/_config.yml.deploy_git是hexo默认的.git配置文件夹，不需要同步public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去依次执行123git add .git commit -m "..."git push origin muyy秒传图片到七牛云并展现在博客中在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具qiniu-image-tool，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac 是基于 Alfred 的，其 windows 也有相应版本windows版本。按照其要求配置好以后，用截图软件截图后，或者本地图片后 copy，然后直接按设置好的 command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。将博客同时部署到 github 和 coding通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。coding 上创建一个新项目这里只介绍 coding 上面如何创建项目，以及把本地 hexo 部署到 coding 上面同步本地 hexo 到 coding 上把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用 coding 的话，需要设置SSH公钥，生成的方法可以参考coding帮助中心, 其实和 github 配置一模一样的。本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。添加后，在git bash命令输入：1ssh -T git@git.coding.net如果得到下面提示就表示公钥添加成功了：1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ]想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式123456deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch]所以我是这样的12345deploy:- type: git repo: github: https://github.com/MuYunyun/MuYunyun.github.io.git,master coding: git@git.coding.net:muyunyun/muyunyun.git,master最后使用部署命令就能把博客同步到coding上面：1hexo deploy -gpages服务方式部署将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了设置域名解析现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：参考资料小胡子哥Hexo Next主题设置和优化Hexo 博客补丁Water Sister’s BlogHexo+NexT主题配置备忘Cherry’s BlogHexo 3.1.1 静态博客搭建指南hexo的next主题个性化教程:打造炫酷网站将hexo博客同时托管到github和coding]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>