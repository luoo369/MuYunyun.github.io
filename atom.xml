<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牧之</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://muyunyun.cn/"/>
  <updated>2017-11-04T11:54:01.000Z</updated>
  <id>http://muyunyun.cn/</id>
  
  <author>
    <name>牧云云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>走近 Python (类比 JS)</title>
    <link href="http://muyunyun.cn/posts/a9d08041/"/>
    <id>http://muyunyun.cn/posts/a9d08041/</id>
    <published>2017-10-31T00:53:14.000Z</published>
    <updated>2017-11-04T11:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/c5438d5b79ea49066234e0328fde04e1.jpg-muyy" alt=""></p><blockquote><p>本文首发在 <a href="http://muyunyun.cn/posts/a9d08041/">个人博客</a></p></blockquote><p>Python 是一门运用很广泛的语言，自动化脚本、爬虫，甚至在深度学习领域也都有 Python 的身影。作为一名前端开发者，也了解 ES6 中的很多特性借鉴自 Python (比如默认参数、解构赋值、Decorator等)，同时本文会对 Python 的一些用法与 JS 进行类比。不管是提升自己的知识广度，还是更好地迎接 AI 时代，Python 都是一门值得学习的语言。</p><a id="more"></a><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 Python 中，最常用的能够直接处理的数据类型有以下几种：</p><ul><li>数字[整数(int)、浮点型(float)、长整型(long)、复数(complex)]</li><li>字符串(str)</li><li>布尔值(bool)</li><li>空值(None)</li></ul><p>除此之外，Python 还提供了列表[list]、字典[dict] 等多种数据类型，这在下文中会介绍。</p><h4 id="类型转换与类型判断"><a href="#类型转换与类型判断" class="headerlink" title="类型转换与类型判断"></a>类型转换与类型判断</h4><p>与 JS 十分类似，python 也能实现不同数据类型间的强制与隐式转换，例子如下：</p><p>强制类型转换:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int(<span class="string">'3'</span>) <span class="comment"># 3</span></div><div class="line">str(<span class="number">3.14</span>) <span class="comment"># '3.14'</span></div><div class="line">float(<span class="string">'3.14'</span>) <span class="comment"># 3.14</span></div><div class="line"><span class="comment"># 区别于 JS 只有 Number 一种类型，Python 中数字中的不同类型也能相互强制转换</span></div><div class="line">float(<span class="number">3</span>) <span class="comment"># 3.0</span></div><div class="line">bool(<span class="number">3</span>) <span class="comment"># True</span></div><div class="line">bool(<span class="number">0</span>) <span class="comment"># False</span></div></pre></td></tr></table></figure><p></p><p>隐式类型转换:<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> + <span class="number">1.0</span> <span class="comment"># 2.0</span></div><div class="line"><span class="number">1</span> + <span class="keyword">False</span> <span class="comment"># 1</span></div><div class="line"><span class="number">1.0</span> + <span class="keyword">True</span> <span class="comment"># 2.0</span></div><div class="line"><span class="comment"># 区别于 JS 的 String + Number = String, py 中 str + int 会报错</span></div><div class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment"># TypeError: cannot concatenate 'str' and 'int' objects</span></div></pre></td></tr></table></figure><p></p><p>此外写代码的时候经常会需要判断值的类型，可以 使用 python 提供的 type() 函数获取变量的类型，或者使用 isinstance(x, type) 来判断 x 是否属于相应的 type 类型。<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">type(<span class="number">1.3</span>) == float <span class="comment"># True</span></div><div class="line">isinstance(<span class="string">'a'</span>, str) <span class="comment"># True</span></div><div class="line">isinstance(<span class="number">1.3</span>, int) <span class="comment"># False</span></div><div class="line">isinstance(<span class="keyword">True</span>, bool) <span class="comment"># True</span></div><div class="line">isinstance([], list) <span class="comment"># True</span></div><div class="line">isinstance(&#123;&#125;, dict) <span class="comment"># True</span></div></pre></td></tr></table></figure><p></p><h3 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h3><p>集合是指包含一组元素的数据结构，有序集合即集合里面的元素是是按照顺序排列的，Python 中的有序集合大概有以下几类：list, tuple, str, unicode。</p><h4 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h4><p>Python 中 List 类型类似于 JS 中的 Array,</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">print</span> L[<span class="number">-1</span>] <span class="comment"># '3'</span></div><div class="line"></div><div class="line">L.append(<span class="number">4</span>) <span class="comment"># 末尾添加元素</span></div><div class="line"><span class="keyword">print</span> L <span class="comment"># [1, 2, 3, 4]</span></div><div class="line"></div><div class="line">L.insert(<span class="number">0</span>, <span class="string">'hi'</span>) <span class="comment"># 指定索引位置添加元素</span></div><div class="line"><span class="keyword">print</span> L <span class="comment"># ['hi', 1, 2, 3, 4]</span></div><div class="line"></div><div class="line">L.pop() <span class="comment"># 末尾移除元素 L.pop(2) ?????? 2 ???</span></div><div class="line"><span class="keyword">print</span> L <span class="comment"># ['hi', 1, 2, 3]</span></div></pre></td></tr></table></figure><h4 id="tuple-类型"><a href="#tuple-类型" class="headerlink" title="tuple 类型"></a>tuple 类型</h4><p>tuple 类型是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple 一旦创建完毕，就不能修改了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">print</span> t[<span class="number">0</span>] <span class="comment"># 1</span></div><div class="line">t[<span class="number">0</span>] = <span class="number">11</span> <span class="comment"># TypeError: 'tuple' object does not support item assignment</span></div><div class="line"></div><div class="line">t = (<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> t <span class="comment"># 1  t 的结果是整数 1</span></div><div class="line"></div><div class="line">t = (<span class="number">1</span>,) <span class="comment"># 为了避免出现如上有歧义的单元素 tuple，所以 Python 规定，单元素 tuple 要多加一个逗号“,”</span></div><div class="line"><span class="keyword">print</span> t <span class="comment"># (1,)</span></div></pre></td></tr></table></figure><h3 id="无序集合类型"><a href="#无序集合类型" class="headerlink" title="无序集合类型"></a>无序集合类型</h3><h4 id="dict-类型"><a href="#dict-类型" class="headerlink" title="dict 类型"></a>dict 类型</h4><p>Python 中的 dict 类型类似于 JS 中的 {} (最大的不同是它是没有顺序的), 它有如下特点:</p><ul><li>查找速度快 (无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样)</li><li>占用内存大 (与 list 类型相反)</li><li>dict 中的 key 不能重复</li><li>dict 中存储的 key-value 序对是没有顺序的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">d = &#123;</div><div class="line">    <span class="string">'a'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'b'</span>: <span class="number">2</span>,</div><div class="line">    <span class="string">'c'</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">print</span> d <span class="comment"># &#123;'a': 1, 'c': 3, 'b': 2&#125;  可以看出打印出的序对没有按正常的顺序打出</span></div><div class="line"></div><div class="line"><span class="comment"># 遍历 dict</span></div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</div><div class="line">    print(<span class="string">'%s: %s'</span> % (key,value))</div><div class="line"><span class="comment"># a: 1</span></div><div class="line"><span class="comment"># c: 3</span></div><div class="line"><span class="comment"># b: 2</span></div></pre></td></tr></table></figure><h4 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h4><p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，而且要保证这个集合的元素不会重复，这时，set 类型就派上用场了。set 类型有如下特点：</p><ul><li>set 存储的元素和 dict 的 key 类似，必须是不变对象</li><li>set 存储的元素也是没有顺序的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">s = set([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>])</div><div class="line"><span class="keyword">print</span> s <span class="comment"># set(['A', 'C', 'B'])</span></div><div class="line"></div><div class="line">s.add(<span class="string">'D'</span>)</div><div class="line"><span class="keyword">print</span> s <span class="comment"># set(['A', 'C', 'B', 'D'])</span></div><div class="line"></div><div class="line">s.remove(<span class="string">'D'</span>)</div><div class="line"><span class="keyword">print</span> s <span class="comment"># set(['A', 'C', 'B'])</span></div></pre></td></tr></table></figure><h3 id="Python-中的迭代"><a href="#Python-中的迭代" class="headerlink" title="Python 中的迭代"></a>Python 中的迭代</h3><p>在介绍完 Python 中的有序集合和无序集合类型后，必然存在遍历集合的 for 循环。但是和其它语言的标准 for 循环不同，Python 中的所有迭代是通过 for … in 来完成的。以下给出一些常用的迭代 demos:</p><p>索引迭代：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">L = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>]</div><div class="line"><span class="keyword">for</span> index, name <span class="keyword">in</span> enumerate(L):  <span class="comment"># enumerate() 函数把 ['apple', 'banana', 'orange'] 变成了类似 [(0, 'apple), (1, 'banana'), (2, 'orange')] 的形式</span></div><div class="line">    <span class="keyword">print</span> index, <span class="string">'-'</span>, name</div><div class="line"></div><div class="line"><span class="comment"># 0 - apple</span></div><div class="line"><span class="comment"># 1 - banana</span></div><div class="line"><span class="comment"># 2 - orange</span></div></pre></td></tr></table></figure><p>迭代 dict 的 value:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">d = &#123; <span class="string">'apple'</span>: <span class="number">6</span>, <span class="string">'banana'</span>: <span class="number">8</span>, <span class="string">'orange'</span>: <span class="number">5</span> &#125;</div><div class="line"><span class="keyword">print</span> d.values() <span class="comment"># [6, 8, 5]</span></div><div class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values()</div><div class="line">    <span class="keyword">print</span> v</div><div class="line"><span class="comment"># 6</span></div><div class="line"><span class="comment"># 8</span></div><div class="line"><span class="comment"># 5</span></div></pre></td></tr></table></figure><p>迭代 dict 的 key 和 value:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d = &#123; <span class="string">'apple'</span>: <span class="number">6</span>, <span class="string">'banana'</span>: <span class="number">8</span>, <span class="string">'orange'</span>: <span class="number">5</span> &#125;</div><div class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items()</div><div class="line">    <span class="keyword">print</span> key, <span class="string">':'</span>, value</div><div class="line"><span class="comment"># apple : 6</span></div><div class="line"><span class="comment"># banana: 8</span></div><div class="line"><span class="comment"># orange: 5</span></div></pre></td></tr></table></figure><h3 id="切片操作符"><a href="#切片操作符" class="headerlink" title="切片操作符"></a>切片操作符</h3><p>Python 提供的切片操作符类似于 JS 提供的原生函数 slice()。有了切片操作符，大大简化了一些原来得用循环的操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">L = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>, <span class="string">'pear'</span>]</div><div class="line">L[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># ['apple', 'banana'] 取前 2 个元素</span></div><div class="line">L[:<span class="number">2</span>] <span class="comment"># ['apple', 'banana'] 如果第一个索引是 0，可以省略</span></div><div class="line">L[:] <span class="comment"># ['apple', 'banana', 'orange', 'pear'] 只用一个 : ，表示从头到尾</span></div><div class="line">L[::<span class="number">2</span>] <span class="comment"># ['apple', 'orange'] 第三个参数表示每 N 个取一个，这里表示从头开始，每 2 个元素取出一个来</span></div></pre></td></tr></table></figure><h3 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h3><p>如果要生成 [1x1, 2x2, 3x3, …, 10x10] 怎么做？方法一是循环：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">L = []</div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</div><div class="line">    L.append(x * x)</div></pre></td></tr></table></figure><p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的 list：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来</span></div><div class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</div><div class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></div></pre></td></tr></table></figure><p>列表生成式的 for 循环后面还可以加上 if 判断(类似于 JS 中的 filter() 函数)，示例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line"><span class="comment"># [4, 16, 36, 64, 100]</span></div></pre></td></tr></table></figure><p>for 循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'123'</span>]</div><div class="line"><span class="comment"># ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']</span></div></pre></td></tr></table></figure><h3 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>JS 中 ES6 的 默认参数正是借鉴于 Python，用法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name=<span class="string">'World'</span>)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Hello, '</span> + name + <span class="string">'.'</span></div><div class="line"></div><div class="line">greet() <span class="comment"># Hello, World.</span></div><div class="line">greet(<span class="string">'Python'</span>) <span class="comment"># Hello, Python.</span></div></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>类似于 JS 函数中自动识别传入参数的个数，Python 也提供了定义可变参数，即在可变参数的名字前面带上个 <code>*</code> 号。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="keyword">print</span> args</div><div class="line"></div><div class="line">fn()  <span class="comment"># ()</span></div><div class="line">fn(<span class="string">'a'</span>) <span class="comment"># ('a',)</span></div><div class="line">fn(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment"># ('a', 'b')</span></div></pre></td></tr></table></figure><p>Python 解释器会把传入的一组参数组装成一个 tuple 传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p><h4 id="常用高阶函数"><a href="#常用高阶函数" class="headerlink" title="常用高阶函数"></a>常用高阶函数</h4><p>Python 中常用的函数 (map、reduce、filter) 的作用和 JS 中一致，只是用法稍微不同。</p><ul><li>map 函数: 接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x * x</div><div class="line"><span class="keyword">print</span> map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure><ul><li>reduce 函数: 接收一个函数 f 和一个 list(可以接受第三个值作为初始值)，reduce() 对 list 的每个元素反复调用函数 f，并返回最终结果值。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x * y</div><div class="line"></div><div class="line">reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]) <span class="comment"># 15</span></div></pre></td></tr></table></figure><ul><li>filter 函数: 接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter() 根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></div><div class="line"></div><div class="line">filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>]) <span class="comment"># [1, 7, 9, 17]</span></div></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>和 JS 的匿名函数不同的地方是，Python 的匿名函数中只能有一个表达式，且不能写 return。拿 map() 函数为例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure><p>关键词 lambda 表示匿名函数，冒号前面的 x 表示函数参数，可以看出匿名函数 <code>lambda x: x* x</code> 实际上就是:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x * x</div></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>之前写过一些关于 JS 闭包的文章，比如 <a href="http://www.cnblogs.com/MuYunyun/p/5930703.html" target="_blank" rel="external">深入浅出JavaScript之闭包（Closure）</a>、以及 <a href="http://muyunyun.cn/posts/4a895cbd/">读书笔记-你不知道的 JavaScript (上)</a>，Python 中闭包的定义和 JS 中的是一致的即：内层函数引用了外层函数的变量，然后返回内层函数。下面来看下 Py 中闭包之 for 循环经典问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 希望一次返回3个函数，分别计算1x1,2x2,3x3:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></div><div class="line">            <span class="keyword">return</span> i * i</div><div class="line">        fs.append(f)</div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count() <span class="comment"># 这种写法相当于 ES6 中的解构赋值</span></div><div class="line"><span class="keyword">print</span> f1(), f2(), f3() <span class="comment"># 9 9 9</span></div></pre></td></tr></table></figure><p>老问题了，f1(), f2(), f3() 结果不应该是 1, 4, 9 吗，实际结果为什么都是 9 呢？</p><p>原因就是当 count() 函数返回了 3 个函数时，这 3 个函数所引用的变量 i 的值已经变成了 3。由于 f1、f2、f3 并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时，i 已经变为 3 了。</p><p>要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。代码修改如下:</p><p>方法一: 可以理解为创建了一个封闭的作用域，i 的 值传给 j 之后，就和 i 没任何关系了。每次循环形成的闭包都存进了内存中。<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span> <span class="comment"># 方法一</span></div><div class="line">                <span class="keyword">return</span> j * j</div><div class="line">            <span class="keyword">return</span> g</div><div class="line">        r = f(i)</div><div class="line">        fs.append(r)</div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count()</div><div class="line"><span class="keyword">print</span> f1(), f2(), f3() <span class="comment"># 1 4 9</span></div></pre></td></tr></table></figure><p></p><p>方法二：思路比较巧妙，用到了默认参数 j 在函数定义时可以获取到 i 的值，虽然没有用到闭包，但是和方法一有异曲同工之处。<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></div><div class="line">    fs = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j = i)</span>:</span> <span class="comment"># 方法二</span></div><div class="line">            <span class="keyword">return</span> j * j</div><div class="line">        fs.append(f)</div><div class="line">    <span class="keyword">return</span> fs</div><div class="line"></div><div class="line">f1, f2, f3 = count()</div><div class="line"><span class="keyword">print</span> f1(), f2(), f3() <span class="comment"># 1 4 9</span></div></pre></td></tr></table></figure><p></p><h4 id="decorator-装饰器"><a href="#decorator-装饰器" class="headerlink" title="decorator 装饰器"></a>decorator 装饰器</h4><p>ES6 的语法中的 decorator 正是借鉴了 Python 的 decorator。decorator 本质上就是<code>一个高阶函数，它接收一个函数作为参数，然后返回一个新函数</code>。</p><p>那装饰器的作用在哪呢？先上一段日常项目中用 ts 写的网关代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Post(<span class="string">'/rider/detail'</span>)  <span class="comment">// URL 路由</span></div><div class="line">@log()                   <span class="comment">// 打印日志</span></div><div class="line">  @ResponseBody</div><div class="line">  public <span class="keyword">async</span> getRiderBasicInfo(</div><div class="line">    @RequestBody(<span class="string">'riderId'</span>) riderId: number,</div><div class="line">    @RequestBody(<span class="string">'cityId'</span>) cityId: number,</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.riderManager.findDetail(cityId, riderId)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>可以看出使用装饰器可以极大地简化代码，避免每个函数(比如日志、路由、性能检测)编写重复性代码。</p><p>回到 Python 上，Python 提供的 @ 语法来使用 decorator，<code>@ 等价于 f = decorate(f)</code>。下面来看看 @log() 在 Python 中的实现:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 我们想把调用的函数名字给打印出来</span></div><div class="line"><span class="meta">@log()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</div><div class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment"># 来看看 @log() 的定义</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'调用了函数'</span> + f.__name__ + <span class="string">'()'</span></div><div class="line">            <span class="keyword">return</span> f(x)</div><div class="line">        <span class="keyword">return</span> fn</div><div class="line">    <span class="keyword">return</span> log_decorator</div><div class="line"></div><div class="line"><span class="comment"># 结果</span></div><div class="line"><span class="comment"># 调用了函数 factorial()</span></div><div class="line"><span class="comment"># 3628800</span></div></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>面向对象编程是一种程序设计范式，基本思想是：用类定义抽象类型，然后根据类的定义创建出实例。在掌握其它语言的基础上，还是比较容易理解这块知识点的，比如从下面两种写法可以看出不同语言的语言特性间竟然有如此多的共性。</p><p>es6: (附：本文的主题是 python，所以只是初略展示下 js 中类的定义以及实例的创建，为了说明写法的相似性)<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, age) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name</div><div class="line">        <span class="keyword">this</span>.age = age</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Person(<span class="string">'Xiao Ming'</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure><p></p><p>Python: (核心要点写在注释中)<br></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义一个 Person 类：根据 Person 类就可以造成很多 child 实例</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    address = <span class="string">'Earth'</span> <span class="comment"># 类属性 (实例公有)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span> <span class="comment"># 创建实例时，__init__()方法被自动调用</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span><span class="params">(self)</span>:</span> <span class="comment"># 定义实例方法，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和普通函数是一样的</span></div><div class="line">        <span class="keyword">return</span> self.age</div><div class="line"></div><div class="line">child1 = Person(<span class="string">'Xiao Ming'</span>, <span class="number">10</span>)</div><div class="line">child2 = Person(<span class="string">'Xiao Hong'</span>, <span class="number">9</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> child1.name <span class="comment"># 'Xiao Ming'</span></div><div class="line"><span class="keyword">print</span> child2.get_age() <span class="comment"># 9</span></div><div class="line"><span class="keyword">print</span> child1.address <span class="comment"># 'Earth'</span></div><div class="line"><span class="keyword">print</span> child2.address <span class="comment"># 'Earth'</span></div></pre></td></tr></table></figure><p></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>child 属于 Student 类，Student 类属于 People 类，这就引出了继承: 即获得了父类的方法属性后又能添加自己的方法属性。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.age = age</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, grade)</span>:</span></div><div class="line">        super(Student, self).__init__(name, age) <span class="comment"># 这里也能写成 Person.__init__(self, name, age)</span></div><div class="line">        self.grade = grade</div><div class="line"></div><div class="line">s = Student(<span class="string">'Xiao Ming'</span>, <span class="number">10</span>, <span class="number">90</span>)</div><div class="line"><span class="keyword">print</span> s.name <span class="comment"># 'Xiao Ming'</span></div><div class="line"><span class="keyword">print</span> s.grade <span class="comment"># 90</span></div></pre></td></tr></table></figure><p>可以看到子类在父类的基础上又增加了 grade 属性。我们可以再来看看 s 的类型。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">isinstance(s, Person)</div><div class="line">isinstance(s, Student)</div></pre></td></tr></table></figure><p>可以看出，Python 中在一条继承链上，一个实例可以看成它本身的类型，也可以看成它父类的类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/c5438d5b79ea49066234e0328fde04e1.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在 &lt;a href=&quot;http://muyunyun.cn/posts/a9d08041/&quot;&gt;个人博客&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Python 是一门运用很广泛的语言，自动化脚本、爬虫，甚至在深度学习领域也都有 Python 的身影。作为一名前端开发者，也了解 ES6 中的很多特性借鉴自 Python (比如默认参数、解构赋值、Decorator等)，同时本文会对 Python 的一些用法与 JS 进行类比。不管是提升自己的知识广度，还是更好地迎接 AI 时代，Python 都是一门值得学习的语言。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://muyunyun.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://muyunyun.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 异步异闻录</title>
    <link href="http://muyunyun.cn/posts/7b9fdc87/"/>
    <id>http://muyunyun.cn/posts/7b9fdc87/</id>
    <published>2017-09-21T16:01:17.000Z</published>
    <updated>2017-11-04T08:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/d2867e4c299fe6b1f84d9610a6af1eb5.jpg-muyy" alt=""></p><p>提到 Node.js, 我们脑海就会浮现异步、非阻塞、单线程等关键词，进一步我们还会想到 buffer、模块机制、事件循环、进程、V8、libuv 等知识点。本文起初旨在理顺 Node.js 以上易混淆概念，然而一入异步深似海，本文尝试基于 Node.js 的异步展开讨论，其他的主题只能日后慢慢补上了。(附：亦可以把本文当作是朴灵老师所著的《深入浅出 Node.js》一书的小结)。</p><a id="more"></a><h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>Node.js 正是依靠构建了一套完善的高性能异步 I/O 框架，从而打破了 JavaScript 在服务器端止步不前的局面。</p><h3 id="异步-I-O-VS-非阻塞-I-O"><a href="#异步-I-O-VS-非阻塞-I-O" class="headerlink" title="异步 I/O VS 非阻塞 I/O"></a>异步 I/O VS 非阻塞 I/O</h3><p>听起来异步和非阻塞，同步和阻塞是相互对应的，从实际效果而言，异步和非阻塞都达到了我们并行 I/O 的目的，但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。</p><p>注意，操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。</p><p>调用阻塞 I/O 的过程：</p><p><img src="http://oqhtscus0.bkt.clouddn.com/886fcdd67d943f63951b0e3bb6dd6e43.jpg-200" alt=""></p><p>调用非阻塞 I/O 的过程：</p><p><img src="http://oqhtscus0.bkt.clouddn.com/38f95c2e0b80e6edb511cf32b8973b90.jpg-200" alt=""></p><p>在此先引人一个叫作<code>轮询</code>的技术。轮询不同于回调，举个生活例子，你有事去隔壁寝室找同学，发现人不在，你怎么办呢？方法1，每隔几分钟再去趟隔壁寝室，看人在不；方法2，拜托与他同寝室的人，看到他回来时叫一下你；那么前者是轮询，后者是回调。</p><p>再回到主题，阻塞 I/O 造成 CPU 等待浪费，非阻塞 I/O 带来的麻烦却是需要轮询去确认是否完全完成数据获取。<code>从操作系统的这个层面上看，对于应用程序而言，不管是阻塞 I/O 亦或是 非阻塞 I/O，它们都只能是一种同步</code>，因为尽管使用了轮询技术，应用程序仍然需要等待 I/O 完全返回。</p><h3 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h3><p>完成整个异步 I/O 环节的有事件循环、观察者、请求对象以及 I/O 线程池。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/34ce4a4c1e2f298811565f15cd2318be.jpg-300" alt=""></p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>在进程启动的时候，Node 会创建一个类似于 whlie(true) 的循环，每一次执行循环体的过程我们称为 Tick。</p><p>每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在相关的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。</p><p>伪代码如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(ture) &#123;</div><div class="line">  <span class="keyword">const</span> event = eventQueue.pop()</div><div class="line">  <span class="keyword">if</span> (event &amp;&amp; event.handler) &#123;</div><div class="line">    event.handler.execute()  <span class="comment">// execute the callback in Javascript thread</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sleep() <span class="comment">// sleep some time to release the CPU do other stuff</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>每个 Tick 的过程中，如何判断是否有事件需要处理，这里就需要引入观察者这个概念。</p><p>每个事件循环中有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</p><p>在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件都有对应的观察者。</p><h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>对于 Node 中的异步 I/O 而言，回调函数不由开发者来调用，在 JavaScript 发起调用到内核执行完 id 操作的过渡过程中，存在一种中间产物，它叫作请求对象。</p><blockquote><p>请求对象是异步 I/O 过程中的重要中间产物，所有状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完后的回调处理</p></blockquote><p>以 <code>fs.open()</code> 为例：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fs.open = <span class="function"><span class="keyword">function</span>(<span class="params">path, flags, mode, callback</span>) </span>&#123;</div><div class="line">  bingding.open(</div><div class="line">    pathModule._makeLong(path),</div><div class="line">    stringToFlags(flags),</div><div class="line">    mode,</div><div class="line">    callback</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>fs.open</code> 的作用就是根据指定路径和参数去打开一个文件，从而得到一个文件描述符。</p><p>从前面的代码中可以看到，JavaScript 层面的代码通过调用 C++ 核心模块进行下层的操作。</p><p>从 JavaScript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。</p><p>libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在 uv_fs_open 的调用过程中，会创建一个 FSReqWrap 请求对象，从 JavaScript 层传入的参数和当前方法都被封装在这个请求对象中。回调函数则被设置在这个对象的 oncomplete_sym 属性上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req_wrap -&gt; object_ -&gt; Set(oncomplete_sym, callback)</div></pre></td></tr></table></figure><p>对象包装完毕后，在 Windows 下，则调用 QueueUserWorkItem() 方法将这个 FSReqWrap 对象推人线程池中等待执行。</p><p>至此，JavaScript 调用立即返回，由 JavaScript 层面发起的异步调用的第一阶段就此结束(即上图所注释的异步 I/O 第一部分)。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响到 JavaScript 线程的后续操作，如此达到了异步的目的。</p><h4 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h4><p>组装好请求对象、送入 I/O 线程池等待执行，实际上是完成了异步 I/O 的第一部分，回调通知是第二部分。</p><p>线程池中的 I/O 操作调用完毕之后，会将获取的结果储存在 <code>req -&gt; result</code> 属性上，然后调用 <code>PostQueuedCompletionStatus()</code> 通知 <code>IOCP</code>，告知当前对象操作已经完成，并将线程归还线程池。</p><p>在这个过程中，我们动用了事件循环的 I/O 观察者，在每次 <code>Tick</code> 的执行过程中，它会调用 <code>IOCP</code> 相关的 <code>GetQueuedCompletionStatus</code> 方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当做事件处理。</p><p>I/O 观察者回调函数的行为就是取出请求对象的 <code>result</code> 属性作为参数，取出 <code>oncomplete_sym</code> 属性作为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通过介绍完整个异步 I/O 后，有个需要重视的观点是 JavaScript 是单线程的，<code>Node 本身其实是多线程的</code>，只是 I/O 线程使用的 CPU 比较少；还有个重要的观点是，除了用户的代码无法并行执行外，所有的 I/O (磁盘 I/O 和网络 I/O) 则是可以并行起来的。</p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>Node 是首个将异步大规模带到应用层面的平台。通过上文所述我们了解了 Node 如何通过事件循环实现异步 I/O，有异步 I/O 必然存在异步编程。异步编程的路经历了太多坎坷，从回调函数、发布订阅模式、Promise 对象，到 generator、asycn/await。趁着异步编程这个主题刚好把它们串起来理理。</p><h3 id="异步-VS-回调"><a href="#异步-VS-回调" class="headerlink" title="异步 VS 回调"></a>异步 VS 回调</h3><p>对于刚接触异步的新人，很大几率会混淆回调 (callback) 和异步 (asynchronous) 的概念。先来看看维基的 <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming" target="_blank" rel="external">Callback</a>) 条目:</p><blockquote><p>In computer programming, a callback is any executable code that is passed as an argument to other code</p></blockquote><p>因此，回调本质上是一种设计模式，并且 jQuery (包括其他框架)的设计原则遵循了这个模式。</p><p>在 JavaScript 中，回调函数具体的定义为：函数 A 作为参数(函数引用)传递到另一个函数 B 中，并且这个函数 B 执行函数 A。我们就说函数 A 叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。</p><p>因此 callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。讲了这么多让我们来看下同步回调和异步回调的例子：</p><p>同步回调：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'f2 finished'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">  cb()</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'f1 finished'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">f1(f2)  <span class="comment">// 得到的结果是 f2 finished, f1 finished</span></div></pre></td></tr></table></figure><p></p><p>异步回调：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'f2 finished'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">  setTimeout(cb, <span class="number">1000</span>) <span class="comment">// 通过 setTimeout() 来模拟耗时操作</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'f1 finished'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">f1(f2)  <span class="comment">// 得到的结果是 f1 finished, f2 finished</span></div></pre></td></tr></table></figure><p></p><p><img src="http://oqhtscus0.bkt.clouddn.com/43197a40f5c53e8a248f5c8de68e1e81.jpg-200" alt=""></p><p>小结：回调可以进行同步也可以异步调用，但是 Node.js 提供的 API 大多都是异步回调的，比如 buffer、http、cluster 等模块。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>事件发布/订阅模式 (PubSub) 自身并无同步和异步调用的问题，但在 Node 的 events 模块的调用中多半伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。它的应用非常广泛，可以在异步编程中帮助我们完成更松的解耦，甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。</p><p>以 jQuery 事件监听为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'myEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;  <span class="comment">// 触发事件</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'I am an Event'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">$(<span class="string">'#btn'</span>).trigger(<span class="string">'myEvent'</span>)           <span class="comment">// 订阅事件</span></div></pre></td></tr></table></figure><p>可以看到，订阅事件就是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。下面我们来看看发布/订阅模式的简易实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PubSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.handlers = &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PubSub.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, handler</span>) </span>&#123; <span class="comment">// 注册函数逻辑</span></div><div class="line">  <span class="keyword">if</span> (!(eventType <span class="keyword">in</span> <span class="keyword">this</span>.handlers)) &#123;</div><div class="line">    <span class="keyword">this</span>.handlers[eventType] = []</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.handlers[eventType].push(handler)  <span class="comment">// 添加事件监听器</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// 返回上下文环境以实现链式调用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">PubSub.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">eventType</span>) </span>&#123;  <span class="comment">// 发布函数逻辑</span></div><div class="line">  <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, _handlers = <span class="keyword">this</span>.handlers[eventType]; i &lt; _handlers.length; i++) &#123;  <span class="comment">// 遍历事件监听器</span></div><div class="line">    _handlers[i].apply(<span class="keyword">this</span>, _args) <span class="comment">// 调用事件监听器</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> PubSub <span class="comment">// 构造 PubSub 实例</span></div><div class="line"></div><div class="line">event.subscribe(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + msg)  <span class="comment">// my name is muyy</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line">event.publish(<span class="string">'name'</span>, <span class="string">'muyy'</span>)</div></pre></td></tr></table></figure><p>至此，一个简易的订阅发布模式就实现了。然而发布/订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p><h3 id="Promise-Deferred-模式"><a href="#Promise-Deferred-模式" class="headerlink" title="Promise/Deferred 模式"></a>Promise/Deferred 模式</h3><p>想象一下，如果某个操作需要经过多个非阻塞的 IO 操作，每一个结果都是通过回调，程序有可能会看上去像这个样子。这样的代码很难维护。这样的情况更多的会发生在 server side 的情况下。代码片段如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">operation1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result1</span>) </span>&#123;</div><div class="line">  operation2(result1, <span class="function"><span class="keyword">function</span>(<span class="params">err, result2</span>) </span>&#123;</div><div class="line">    operation3(result2, <span class="function"><span class="keyword">function</span>(<span class="params">err, result3</span>) </span>&#123;</div><div class="line">      operation4(result3, <span class="function"><span class="keyword">function</span>(<span class="params">err, result4</span>) </span>&#123;</div><div class="line">        callback(result4) <span class="comment">// do something useful</span></div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这时候，Promise 出现了，其出现的目的就是为了解决所谓的回调地狱的问题。让我们看下使用 Promise 后的代码片段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">promise()</div><div class="line">  .then(operation1)</div><div class="line">  .then(operation2)</div><div class="line">  .then(operation3)</div><div class="line">  .then(operation4)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</div><div class="line">    <span class="comment">// Do something with value4</span></div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// Handle any error from step1 through step4</span></div><div class="line">  &#125;)</div><div class="line">  .done()</div></pre></td></tr></table></figure><p>可以看到，使用了第二种编程模式后能极大地提高我们的编程体验，接着就让我们自己动手实现一个支持序列执行的 Promise。(附：为了直观的在浏览器上也能感受到 Promise，为此也写了一段<a href="https://github.com/MuYunyun/demos-of-node.js/blob/master/promise/browser.js" target="_blank" rel="external">浏览器上的 Promise 用法示例</a>)</p><p>在此之前，我们先要了解 Promise/A 提议中对单个异步操作所作的抽象定义，定义具体如下所示：</p><ul><li>Promise 操作只会处在 3 种状态的一种：未完成态、完成态和失败态。</li><li>Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能相互转化。</li><li>Promise 的状态一旦转化，将不能被更改。</li></ul><p>Promise 的状态转化示意图如下：</p><p><img src="http://oqhtscus0.bkt.clouddn.com/e1a0c15c44f9b014aa78d7b7620db474.jpg-200" alt=""></p><p>除此之外，Promise 对象的另一个关键就是需要具备 then() 方法，对于 then() 方法，有以下简单的要求:</p><ul><li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li><li>可选地支持 progress 事件回调作为第三个方法。</li><li>then() 方法只接受 function 对象，其余对象将被忽略。</li><li>then() 方法继续返回 Promise 对象，已实现链式调用。</li></ul><p>then() 方法的定义如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">then(fulfilledHandler, errorHandler, progressHandler)</div></pre></td></tr></table></figure><p></p><p>有了这些核心知识，接着进入 Promise/Deferred 核心代码环节：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 构建 Promise 对象</span></div><div class="line">  <span class="comment">// 队列用于存储执行的回调函数</span></div><div class="line">  <span class="keyword">this</span>.queue = []</div><div class="line">  <span class="keyword">this</span>.isPromise = <span class="literal">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123; <span class="comment">// 构建 Progress 的 then 方法</span></div><div class="line">  <span class="keyword">var</span> handler = &#123;&#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fulfilledHandler === <span class="string">'function'</span>) &#123;</div><div class="line">    handler.fulfilled = fulfilledHandler</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> errorHandler === <span class="string">'function'</span>) &#123;</div><div class="line">    handler.error = errorHandler</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>.queue.push(handler)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上 Promise 的代码就完成了，但是别忘了 Promise/Deferred 中的后者 Deferred，为了完成 Promise 的整个流程，我们还需要触发执行上述回调函数的地方，实现这些功能的对象就叫作 Deferred，即延迟对象。</p><p>Promise 和 Deferred 的整体关系如下图所示，从中可知，Deferred 主要用于内部来维护异步模型的状态；而 Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/f461de8674e1268ec19470534a07320a.jpg-400" alt=""></p><p>接着来看 Deferred 代码部分的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 完成态</span></div><div class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise</div><div class="line">  <span class="keyword">var</span> handler</div><div class="line">  <span class="keyword">while</span>(handler = promise.queue.shift()) &#123;</div><div class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.fulfilled) &#123;</div><div class="line">      <span class="keyword">var</span> ret = handler.fulfilled(obj)</div><div class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123; <span class="comment">// 这一行以及后面3行的意思是：一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它</span></div><div class="line">        ret.queue = promise.queue</div><div class="line">        <span class="keyword">this</span>.promise = ret</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 失败态</span></div><div class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise</div><div class="line">  <span class="keyword">var</span> handler</div><div class="line">  <span class="keyword">while</span> (handler = promise.queue.shift()) &#123;</div><div class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.error) &#123;</div><div class="line">      <span class="keyword">var</span> ret = handler.error(err)</div><div class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123;</div><div class="line">        ret.queue = promise.queue</div><div class="line">        <span class="keyword">this</span>.promise = ret</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成回调函数</span></div><div class="line">Deferred.prototype.callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">      <span class="keyword">return</span> that.reject(err)</div><div class="line">    &#125;</div><div class="line">    that.resolve(file)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着我们以两次文件读取作为例子，来验证该设计的可行性。这里假设第二个文件读取依赖于第一个文件中的内容，相关代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> readFile1 = <span class="function"><span class="keyword">function</span>(<span class="params">file, encoding</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred()</div><div class="line">  fs.readFile(file, encoding, deferred.callback())</div><div class="line">  <span class="keyword">return</span> deferred.promise</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> readFile2 = <span class="function"><span class="keyword">function</span>(<span class="params">file, encoding</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred()</div><div class="line">  fs.readFile(file, encoding, deferred.callback())</div><div class="line">  <span class="keyword">return</span> deferred.promise</div><div class="line">&#125;</div><div class="line"></div><div class="line">readFile1(<span class="string">'./file1.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">file1</span>) </span>&#123; <span class="comment">// 这里通过 then 把两个回调存进队列中</span></div><div class="line">  <span class="keyword">return</span> readFile2(file1, <span class="string">'utf8'</span>)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">file2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(file2)   <span class="comment">// I am file2.</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>最后可以看到控制台输出 <code>I am file2</code>，验证成功~，这个案例的完整代码可以<a href="https://github.com/MuYunyun/demos-of-node.js/blob/master/promise/sequence.js" target="_blank" rel="external">点这里查看</a>，并建议使用 <a href="https://github.com/node-inspector/node-inspector" target="_blank" rel="external">node-inspector</a> 进行断点观察，(这段代码里面有些逻辑确实很绕，通过断点调试就能较容易理解了)。</p><p>从 Promise 链式调用可以清晰地看到队列(先进先出)的知识，其有如下两个核心步骤：</p><ul><li>将所有的回调都存到队列中；</li><li>Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它；</li></ul><p>至此，实现了 Promise/Deferred 的完整逻辑，Promise 的其他知识未来也会继续探究。</p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>尽管 Promise 一定程度解决了回调地狱的问题，但是对于喜欢简洁的程序员来说，一大堆的模板代码 <code>.then(data =&gt; {...})</code> 显得不是很友好。所以爱折腾的开发者们在 ES6 中引人了 Generator 这种数据类型。仍然以读取文件为例，先上一段非常简洁的 Generator + co 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./file1.txt'</span>)</div><div class="line">  <span class="keyword">const</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./file2.txt'</span>)</div><div class="line">  <span class="built_in">console</span>.log(file1)</div><div class="line">  <span class="built_in">console</span>.log(file2)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>可以看到比 Promise 的写法简洁了许多。后文会给出 co 库的实现原理。在此之前，先归纳下什么是 Generator。可以把 Generator 理解为一个可以遍历的状态机，调用 next 就可以切换到下一个状态，其最大特点就是可以交出函数的执行权（即暂停执行），让我们看如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">1</span>&#125;)()</div><div class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span></div><div class="line">  <span class="keyword">return</span> y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用方式一</span></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>)</div><div class="line">g.next()  <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.next()  <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line">g.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 调用方式二</span></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>)</div><div class="line">g.next()  <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.next()  <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line">g.next(<span class="number">10</span>)  <span class="comment">// &#123; value: 10, done: true &#125;</span></div></pre></td></tr></table></figure><p>由此我们归纳下 Generator 的基础知识：</p><ol><li>Generator 生成迭代器后，等待迭代器的 <code>next()</code> 指令启动。</li><li>启动迭代器后，代码会运行到 <code>yield</code> 处停止。并返回一个 {value: AnyType, done: Boolean} 对象，value 是这次执行的结果，done 是迭代是否结束。并等待下一次的 next() 指令。</li><li>next() 再次启动，若 done 的属性不为 true，则可以继续从上一次停止的地方继续迭代。</li><li>一直重复 2，3 步骤，直到 done 为 true。</li><li>通过调用方式二，我们可看到 next 方法可以带一个参数，该参数就会被当作<code>上一个 yield 语句的返回值</code>。</li></ol><p>另外我们注意到，上述代码中的第一种调用方式中的 y 值是 undefined，如果我们真想拿到 y 值，就需要通过 <code>g.next(); g.next().value</code> 这种方式取出。可以看出，Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。这时候用于 Generator 函数的自动执行的 <a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="external">co 函数库</a> 登场了。为什么 co 可以自动执行 Generator 函数呢？我们知道，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点：</p><ul><li>Thunk 函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li><li>Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</li></ul><p>co 函数库其实就是将两种自动自动执行器(Thunk 函数和 Promise 对象)，包装成一个库。使用 co 的前提条件是，<code>Generator 函数的 yield 命令后面，只能是 Thunk 函数或者是 Promise 对象</code>。下面分别用以上两种方法对 co 进行一个简单的实现。</p><h4 id="基于-Thunk-函数的自动执行"><a href="#基于-Thunk-函数的自动执行" class="headerlink" title="基于 Thunk 函数的自动执行"></a>基于 Thunk 函数的自动执行</h4><p>在 JavaScript 中，Thunk 函数就是指将多参数函数替换成单参数的形式，并且其只接受回调函数作为参数的函数。Thunk 函数的例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 正常版本的 readFile(多参数)</span></div><div class="line">fs.readFile(filename, <span class="string">'utf8'</span>, callback)</div><div class="line"></div><div class="line"><span class="comment">// Thunk 版本的 readFile(单参数)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">        fs.readFile(filename, <span class="string">'utf8'</span>, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在基于 Thunk 函数和 Generator 的知识上，接着我们来看看 co 基于 Thunk 函数的实现。(附：代码参考自<a href="https://cnodejs.org/topic/53474cd19e21582e740117df" target="_blank" rel="external">co最简版实现</a>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> gen = generator()</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span>(err) &#123;</div><div class="line">        <span class="keyword">return</span> fn(err)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">var</span> step = gen.next(result)</div><div class="line">      <span class="keyword">if</span> (!step.done) &#123;</div><div class="line">        step.value(next) <span class="comment">// 这里可以把它联想成递归；将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fn(<span class="literal">null</span>, step.value)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    next()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用法如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;  <span class="comment">// 把 function*() 作为参数 generator 传入 co 函数</span></div><div class="line">  <span class="keyword">var</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./file1.txt'</span>)</div><div class="line">  <span class="keyword">var</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./file2.txt'</span>)</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(file1) <span class="comment">// I'm file1</span></div><div class="line">  <span class="built_in">console</span>.log(file2) <span class="comment">// I'm file2</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'done'</span></div><div class="line">&#125;)(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;  <span class="comment">// 这部分的 function 作为 co 函数内的 fn 的实参传入</span></div><div class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// done</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>上述部分关键代码已进行注释，下面对 co 函数里的几个难点进行说明：</p><ul><li><code>var step = gen.next(result)</code>, 前文提到的一句话在这里就很有用处了：<code>next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值</code>;在上述代码的运行中一共会经过这个地方 3 次，result 的值第一次是空值，第二次是 file1.txt 的内容 I’m file1，第三次是 file2.txt 的内容 I’m file2。根据上述关键语句的提醒，所以第二次的内容会作为 file1 的值(当作上一个yield语句的返回值)，同理第三次的内容会作为 file2 的值。</li><li>另一处是 <code>step.value(next)</code>, step.value 就是前面提到的 thunk 函数返回的 function(callback) {}, next 就是传入 thunk 函数的 callback。这句代码是条递归语句，是这个简易版 co 函数能自动调用 Generator 的关键语句。</li></ul><p>建议亲自跑一遍代码，多打断点，从而更好地理解，代码已上传<a href="https://github.com/MuYunyun/demos-of-node.js/blob/master/generator/thunk.js" target="_blank" rel="external">github</a>。</p><h4 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h4><p>基于 Thunk 函数的自动执行中，yield 后面需跟上 Thunk 函数，在基于 Promise 对象的自动执行中，yield 后面自然要跟 Promise 对象了，让我们先构建一个 readFile 的<br>Promise 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (error) reject(error)</div><div class="line">      resolve(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在基于前文 Promise 对象和 Generator 的知识上，接着我们来看看 co 基于 Promise 函数的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">generator</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> gen = generator()</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = gen.next(data) <span class="comment">// 同上，经历了 3 次，第一次是 undefined，第二次是 I'm file1，第三次是 I'm file2</span></div><div class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value</div><div class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 将异步操作包装成 Promise 对象，用 then 方法交回执行权</span></div><div class="line">      next(data)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  next()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用法如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./file1.txt'</span>)</div><div class="line">  <span class="keyword">var</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./file2.txt'</span>)</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(file1.toString())  <span class="comment">// I'm file1</span></div><div class="line">  <span class="built_in">console</span>.log(file2.toString())  <span class="comment">// I'm file2</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>这一部分的代码上传在<a href="https://github.com/MuYunyun/demos-of-node.js/blob/master/generator/promiseGen.js" target="_blank" rel="external">这里</a>，通过观察可以发现基于 Thunk 函数和基于 Promise 对象的自动执行方案的 co 函数设计思路几乎一致，也因此呼应了它们共同的本质 —— 当异步操作有了结果，自动交回执行权。</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>看上去 Generator 已经足够好用了，但是使用 Generator 处理异步必须得依赖 tj/co，于是 asycn 出来了。本质上 async 函数就是 Generator 函数的语法糖，这样说是因为 async 函数的实现，就是将 Generator 函数和自动执行器，包装进一个函数中。伪代码如下，(注：其中 automatic 的实现可以参考 <a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="external">async 函数的含义和用法</a>中的实现)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> automatic(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;  <span class="comment">// automatic 函数就是自动执行器，其的实现可以仿照 co 库自动运行方案来实现，这里就不展开了</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着仍然以上文的读取文件为例，来比较 Generator 和 async 函数的写法差异：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Generator</span></div><div class="line"><span class="keyword">var</span> genReadFile = co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> file1 = <span class="keyword">yield</span> readFile(<span class="string">'./file1.txt'</span>)</div><div class="line">  <span class="keyword">var</span> file2 = <span class="keyword">yield</span> readFile(<span class="string">'./file2.txt'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 改用 async 函数</span></div><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> file1 = <span class="keyword">await</span> readFile(<span class="string">'./file1.txt'</span>)</div><div class="line">  <span class="keyword">var</span> file2 = <span class="keyword">await</span> <span class="number">1</span>  <span class="comment">// 等同于同步操作（如果跟上原始类型的值）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总体来说 async/await 看上去和使用 co 库后的 generator 看上去很相似，不过相较于 Generator，可以看到 Async 函数更优秀的几点：</p><ul><li>内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样；</li><li>更好的语义。async 和 await 相较于 * 和 yield 更加语义化；</li><li>更广的适用性。前文提到的 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面则可以是 Promise 或者原始类型的值；</li><li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，因此可以直接使用 then() 方法进行调用；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/JacksonTian" target="_blank" rel="external">深入浅出 Node.js</a></li><li><a href="https://segmentfault.com/q/1010000000140970" target="_blank" rel="external">理解回调函数</a></li><li><a href="http://blog.codingplayboy.com/2016/01/20/js_async_intro/" target="_blank" rel="external">JavaScript之异步编程简述</a></li><li><a href="http://www.html-js.com/article/Nodejs-study-notes-to-understand-co-execution-logic" target="_blank" rel="external">理解co执行逻辑</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="external">co 函数库的含义和用法</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="external">async 函数的含义和用法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/d2867e4c299fe6b1f84d9610a6af1eb5.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;提到 Node.js, 我们脑海就会浮现异步、非阻塞、单线程等关键词，进一步我们还会想到 buffer、模块机制、事件循环、进程、V8、libuv 等知识点。本文起初旨在理顺 Node.js 以上易混淆概念，然而一入异步深似海，本文尝试基于 Node.js 的异步展开讨论，其他的主题只能日后慢慢补上了。(附：亦可以把本文当作是朴灵老师所著的《深入浅出 Node.js》一书的小结)。&lt;/p&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://muyunyun.cn/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://muyunyun.cn/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>用 Node.js 把玩一番 Alfred Workflow</title>
    <link href="http://muyunyun.cn/posts/4c23be51/"/>
    <id>http://muyunyun.cn/posts/4c23be51/</id>
    <published>2017-08-08T18:51:57.000Z</published>
    <updated>2017-08-08T22:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/f27594afeda6b513ffec98c3e60ccbb0.jpg-muyy" alt=""></p><blockquote><p><a href="https://github.com/MuYunyun/commonSearch" target="_blank" rel="external">插件地址</a>(集成Github、掘金、知乎、淘宝等搜索)</p></blockquote><p>作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。<br><a id="more"></a></p><h2 id="一些安利"><a href="#一些安利" class="headerlink" title="一些安利"></a>一些安利</h2><p><img src="http://oqhtscus0.bkt.clouddn.com/482ccbbbcfb8f302851617a86dd6a5de.jpg-400" alt=""></p><p>附上一张个人装着的插件的截图。Caffeinate 插件能在指定时间使电脑不黑屏；在 Dash 插件上能轻松查任何文档；Youdao Translate 插件比系统自带的翻译方便许多。插件也是因人而异，大家可以在 <a href="http://alfredworkflow.com/" target="_blank" rel="external">Workflow List</a> 上逛逛，各取所需。</p><p>在用了别人的插件感觉高大上后，便萌发了也写一个插件的想法，计划把自己常逛的网站集合成一个插件，使用特定的缩略词便可快速进行搜索数据，又看了官方称可以使用 bash, zsh, PHP, Ruby, Python, Perl, Apple Script 开发 Alfred Workflow。于是我选择了 Node.js 作为开发语言，开发了一款 <a href="https://github.com/MuYunyun/commonSearch" target="_blank" rel="external">commonSearch</a>, 开发完效果如下(集成了Github、掘金、知乎、淘宝等搜索)。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/40a83edf9552b4a071dd2ff5093a445b.gif" alt=""></p><h2 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h2><p>在开发前，得先对一些特定的操作步骤和知识点有一定的认知，这样开发时就基本上没有大碍了。</p><h3 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h3><p>可以先参考 <a href="http://allenwu.itscoder.com/how-to-write-a-workflow-for-mac" target="_blank" rel="external">如何去写一个第三方的 workflow</a> 的开始部分, 完成基本工作流的搭建，如下图是我搭建好的基本工作流连线。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/f27594afeda6b513ffec98c3e60ccbb0.jpg-400" alt=""></p><p>在 Script 中，可以看到 <code>/usr/local/bin/node common_search.js</code> 相当于就是在调用该插件的时候起了一个 node 服务，后面的 <code>1</code> 是为了区分当前调用的是哪个搜索手动传入 <code>common_search.js</code> 的，<code>{query}</code> 则是用户查询的名称。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/39ab06f7fbd80e5723e9abc4b595b930.jpg-400" alt=""></p><h3 id="使用-Node-js-调用-JSON-API"><a href="#使用-Node-js-调用-JSON-API" class="headerlink" title="使用 Node.js 调用 JSON API"></a>使用 Node.js 调用 JSON API</h3><p>最初开发参考了 <a href="https://github.com/RebeccaHanjw/zhihu_search_alfred_workflow" target="_blank" rel="external">知乎搜索</a> 这个项目，它是基于 <a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a> 这个模块对请求到的网页数据进行分析爬取，但是引入了 cheerio 后，插件体积多了 2M 多，这对于一个插件来说太不友好了，所以这可能是 python 之类的语言更适合开发类似插件的原因吧(猜想:python 不需要引人第三方库就能进行爬虫)，于是我开始选择提供 JSON API 的接口，比如找寻掘金返回数据的接口。首先打开 chrome 控制台，这可能对前端工程师比较熟悉了。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/6151c3ab055e196ac43e63377940bfdb.jpg-muyy" alt=""></p><p>从而找到了掘金返回搜索数据的接口是 <code>https://search-merger-ms.juejin.im/v1/search?query={query}&amp;page=0&amp;raw_result=false&amp;src=web</code></p><p>接着愉快地使用 node 提供的 https 模块，这里有一个注意点，http.get() 回调中的 res 参数不是正文，而是 http.ClientResponse 对象，所以我们需要组装内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">    <span class="attr">host</span>: <span class="string">'search-merger-ms.juejin.im'</span>,</div><div class="line">    <span class="attr">path</span>: <span class="string">'/v1/search?query='</span> + <span class="built_in">encodeURI</span>(keyword) + <span class="string">'&amp;page=0&amp;raw_result=false&amp;src=web'</span></div><div class="line">  &#125;</div><div class="line">  https.get(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    res.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</div><div class="line">      <span class="keyword">var</span> content += chunk</div><div class="line">    &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> jsonContent = <span class="built_in">JSON</span>.parse(content) &amp;&amp; <span class="built_in">JSON</span>.parse(content).d</div><div class="line">      <span class="keyword">var</span> result_array = []</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonContent.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (jsonContent[i].user.jobTitle === <span class="string">''</span>) &#123;</div><div class="line">          result_array.push(&#123;</div><div class="line">            <span class="attr">title</span>:</div><div class="line">            subtitle:</div><div class="line">            arg:</div><div class="line">            icon: &#123;</div><div class="line">              <span class="attr">path</span>: join(__dirname, <span class="string">'xx.png'</span>),</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">mods</span>: &#123;</div><div class="line">              <span class="attr">cmd</span>: &#123;&#125;</div><div class="line">            &#125;</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      content = <span class="string">''</span></div><div class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(&#123;</div><div class="line">        <span class="attr">items</span>: result_array</div><div class="line">      &#125;))</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>这种方法应该是最直接的调用 JSON API 的方案了，当然也可以引人第三方模块 request 后解析 JSON，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> url = <span class="string">'search-merger-ms.juejin.im/v1/search?query='</span> + <span class="built_in">encodeURI</span>(keyword) + <span class="string">'&amp;page=0&amp;raw_result=false&amp;src=web'</span></div><div class="line"></div><div class="line">request.get(&#123;</div><div class="line">    <span class="attr">url</span>: url,</div><div class="line">    <span class="attr">json</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">headers</span>: &#123;<span class="string">'User-Agent'</span>: <span class="string">'request'</span>&#125;</div><div class="line">  &#125;, (err, res, data) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Error:'</span>, err);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.statusCode !== <span class="number">200</span>) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'Status:'</span>, res.statusCode);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// data is already parsed as JSON:</span></div><div class="line">      <span class="built_in">console</span>.log(data.html_url);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>还有一点要注意的是返回值的字段是固定的，具体可以参考它的<a href="https://www.alfredapp.com/help/workflows/inputs/script-filter/xml/" target="_blank" rel="external">官方解释</a>，琢磨了好久才把 JS 中的 Icon 自定义的格式找出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: 主标题</div><div class="line">subtitle: 内容行</div><div class="line">arg: 跳转链接</div><div class="line">icons: 图标</div><div class="line">mods：定制键盘按键的方法</div></pre></td></tr></table></figure><p>对于 Github、掘金、知乎、淘宝的搜索都是基于以上思路进行开发的，就是对于具体返回的 JSON 数据进行了不同处理，虽然粗糙，但也算完成了第一个 Alfred Workflow 插件的开发。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>本文的知识点写的不是特别丰满，一是就是对开发这个插件的小结，另外就是抛砖引玉了，能让更多的小伙伴了解开发一个插件并不是难事，同时让更多的朋友开发出更多有意义，有趣的 alfred-workflow 插件也算是本文分享的一个初衷了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/f27594afeda6b513ffec98c3e60ccbb0.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/commonSearch&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插件地址&lt;/a&gt;(集成Github、掘金、知乎、淘宝等搜索)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。&lt;br&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://muyunyun.cn/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://muyunyun.cn/tags/Node-js/"/>
    
      <category term="alfred workflow" scheme="http://muyunyun.cn/tags/alfred-workflow/"/>
    
  </entry>
  
  <entry>
    <title>从 JavaScript 到 TypeScript</title>
    <link href="http://muyunyun.cn/posts/66a54fc2/"/>
    <id>http://muyunyun.cn/posts/66a54fc2/</id>
    <published>2017-07-02T05:40:33.000Z</published>
    <updated>2017-08-08T22:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/5e7b640325806920160f538d7c50f5d7.jpg-muyy" alt=""></p><blockquote><p>文中的案例代码已经上传到 <a href="https://github.com/MuYunyun/TypeScript" target="_blank" rel="external">TypeScript</a></p></blockquote><p>TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。<br><a id="more"></a></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><p>TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/da62039bf146c2ebd615ef1d11a1a808.jpg" alt=""></p><h2 id="使用-TypeScript-的原因"><a href="#使用-TypeScript-的原因" class="headerlink" title="使用 TypeScript 的原因"></a>使用 TypeScript 的原因</h2><p>JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。</p><p>此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。</p><p>对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~)</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'muyy'</span></div><div class="line"><span class="keyword">let</span> name2: <span class="built_in">String</span> = <span class="string">'muyy'</span></div></pre></td></tr></table></figure><p></p><h3 id="Boolen-类型"><a href="#Boolen-类型" class="headerlink" title="Boolen 类型"></a>Boolen 类型</h3><p>boolean是 true 或 false 的值，所以 <code>let isBool3: boolean = new Boolean(1)</code> 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> isBool1: <span class="built_in">boolean</span> = <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">number</span>: <span class="built_in">number</span> = <span class="number">10</span>;</div></pre></td></tr></table></figure><h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><p>数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 <code>Array&lt;type&gt;</code> or <code>type[]</code> 语法为数组内的元素指定类型<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr3:<span class="built_in">string</span>[] = [<span class="string">"1"</span>,<span class="string">"2"</span>];</div><div class="line"><span class="keyword">let</span> arr4:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">"1"</span>,<span class="string">"2"</span>];</div></pre></td></tr></table></figure><p></p><h3 id="Enums-类型"><a href="#Enums-类型" class="headerlink" title="Enums 类型"></a>Enums 类型</h3><p>列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Role &#123;Employee = <span class="number">3</span>, Manager, Admin&#125;</div><div class="line"><span class="keyword">let</span> role: Role = Role.Employee</div><div class="line"><span class="built_in">console</span>.log(role) <span class="comment">// 3</span></div></pre></td></tr></table></figure><p></p><h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h3><p>any 是默认的类型，其类型的变量允许任何类型的值：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure:<span class="built_in">any</span> = <span class="number">10</span>;</div><div class="line"><span class="keyword">let</span> notSure2:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">"2"</span>,<span class="literal">false</span>];</div></pre></td></tr></table></figure><p></p><h3 id="Void-类型"><a href="#Void-类型" class="headerlink" title="Void 类型"></a>Void 类型</h3><p>JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'My name is muyy'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add3: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastname?: <span class="built_in">string</span></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(lastname ? firstName + <span class="string">""</span> + lastname : firstName)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> res1 = buildName(<span class="string">"鸣"</span>,<span class="string">"人"</span>); <span class="comment">// 鸣人</span></div><div class="line"><span class="keyword">let</span> res2 = buildName(<span class="string">"鸣"</span>); <span class="comment">// 鸣</span></div><div class="line"><span class="keyword">let</span> res3 = buildName(<span class="string">"鸣"</span>, <span class="string">"人"</span>, <span class="string">"君"</span>); <span class="comment">// Supplied parameters do not match any signature of call target.</span></div></pre></td></tr></table></figure><p></p><p>如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function buildName2(firstName = "鸣", lastName?: string)&#123;</div><div class="line">    console.log(firstName + "" + lastName)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let res4 = buildName2("人"); // undefined人</div><div class="line">let res5 = buildName2(undefined, "人"); // 鸣人</div></pre></td></tr></table></figure><p></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    name:<span class="built_in">string</span>; <span class="comment">// 这个是对后文this.name类型的定义</span></div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    print()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person:Person = <span class="keyword">new</span> Person(<span class="string">'muyy'</span>,<span class="number">23</span>)</div><div class="line"><span class="built_in">console</span>.log(person.print()) <span class="comment">// muyy23</span></div></pre></td></tr></table></figure><p>我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;  <span class="comment">// public、private、static 是 typescript 中的类访问修饰符</span></div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    tell()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</div><div class="line">    gender:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">gender:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"muyy"</span>,<span class="number">23</span>);</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">    &#125;</div><div class="line">    tell()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="keyword">this</span>.gender);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">"male"</span>);</div><div class="line">student.tell();  <span class="comment">// muyy23male</span></div></pre></td></tr></table></figure><p>这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>对于存取器有下面几点需要注意的：<br>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Hello&#123;</div><div class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</div><div class="line">    <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> name(value: <span class="built_in">string</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._name = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">get</span> age(): <span class="built_in">number</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> age(age: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(age&gt;<span class="number">0</span> &amp;&amp; age&lt;<span class="number">100</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"年龄在0-100之间"</span>); <span class="comment">// 年龄在0-100之间</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>._age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> hello = <span class="keyword">new</span> Hello();</div><div class="line">hello.name = <span class="string">"muyy"</span>;</div><div class="line">hello.age = <span class="number">23</span></div><div class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// muyy</span></div></pre></td></tr></table></figure><p></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> LabelValue&#123;</div><div class="line">    label: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelObj: LabelValue</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;</div><div class="line">    <span class="string">"label"</span>:<span class="string">"hello Interface"</span></div><div class="line">&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure><p></p><p>LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。</p><p>另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Person&#123;</div><div class="line">    name?:<span class="built_in">string</span>;</div><div class="line">    age?:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">info:Person</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(info);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> info = &#123;</div><div class="line">    <span class="string">"name"</span>:<span class="string">"muyy"</span>,</div><div class="line">    <span class="string">"age"</span>:<span class="number">23</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">printInfo(info); <span class="comment">// &#123;"name": "muyy", "age": 23&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> info2 = &#123;</div><div class="line">    <span class="string">"name"</span>:<span class="string">"muyy"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">printInfo(info2); <span class="comment">// &#123;"name": "muyy"&#125;</span></div></pre></td></tr></table></figure><p></p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SearchFunc&#123;</div><div class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>,subString: <span class="built_in">string</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mySearch(<span class="string">"鸣人"</span>,<span class="string">"鸣"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(mySearch(<span class="string">"鸣人"</span>,<span class="string">"缨"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> StringArray&#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> MyArray: StringArray;</div><div class="line">MyArray = [<span class="string">"是"</span>,<span class="string">"云"</span>,<span class="string">"随"</span>,<span class="string">"风"</span>];</div><div class="line"><span class="built_in">console</span>.log(MyArray[<span class="number">2</span>]); <span class="comment">// 随</span></div></pre></td></tr></table></figure><p></p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><p>我们可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface&#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface&#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.currentTime = d;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape&#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> PenStroke&#123;</div><div class="line">    penWidth: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape,PenStroke&#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> s = &lt;Square&gt;&#123;&#125;;</div><div class="line">s.color = <span class="string">"blue"</span>;</div><div class="line">s.penWidth = <span class="number">100</span>;</div><div class="line">s.sideLength = <span class="number">10</span>;</div></pre></td></tr></table></figure><p></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator&#123;</div><div class="line">    isAcceptable(s:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> strReg = <span class="regexp">/^[A-Za-z]+$/</span>;</div><div class="line"><span class="keyword">var</span> numReg = <span class="regexp">/^[0-9]+$/</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> letterValidator <span class="keyword">implements</span> StringValidator&#123;</div><div class="line">    isAcceptable(s:<span class="built_in">string</span>): <span class="built_in">boolean</span>&#123;</div><div class="line">        <span class="keyword">return</span> strReg.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> zipCode <span class="keyword">implements</span> StringValidator&#123;</div><div class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>&#123;</div><div class="line">        <span class="keyword">return</span> s.length == <span class="number">5</span> &amp;&amp; numReg.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><h3 id="初探泛型"><a href="#初探泛型" class="headerlink" title="初探泛型"></a>初探泛型</h3><p>如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 <code>output</code> 和 <code>output2</code> 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> outPut = Hello&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello Generic'</span>);</div><div class="line"><span class="keyword">let</span> output2 = Hello(<span class="string">'Hello Generic'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(outPut);</div><div class="line"><span class="built_in">console</span>.log(outPut2);</div></pre></td></tr></table></figure><p></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.gitbook.com/book/zhongsp/typescript-handbook/details" target="_blank" rel="external">TypeScript 中文文档</a></li><li><a href="http://pinggod.com/2016/Typescript/" target="_blank" rel="external">TypeScript</a></li><li><a href="http://naywinmyint.com/typescript-for-angular-2-part-1/" target="_blank" rel="external">TypeScript for Angular 2 - Part 1 (An Introduction)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/5e7b640325806920160f538d7c50f5d7.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;文中的案例代码已经上传到 &lt;a href=&quot;https://github.com/MuYunyun/TypeScript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TypeScript&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。&lt;br&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://muyunyun.cn/categories/TypeScript/"/>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://muyunyun.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>React 在服务端渲染的实现</title>
    <link href="http://muyunyun.cn/posts/2d678a6/"/>
    <id>http://muyunyun.cn/posts/2d678a6/</id>
    <published>2017-07-01T07:41:05.000Z</published>
    <updated>2017-07-02T05:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/f82f7765b1171459d9fa593df836c658.jpg-muyy" alt=""></p><blockquote><ul><li>原文地址：<a href="https://css-tricks.com/server-side-react-rendering/" target="_blank" rel="external">Server-Side React Rendering</a></li></ul></blockquote><p>React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？<br><a id="more"></a></p><h2 id="React-在服务端渲染的实现"><a href="#React-在服务端渲染的实现" class="headerlink" title="React 在服务端渲染的实现"></a>React 在服务端渲染的实现</h2><p>假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？</p><p>您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。</p><p>在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。<br>在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。</p><h2 id="服务端渲染的优势"><a href="#服务端渲染的优势" class="headerlink" title="服务端渲染的优势"></a>服务端渲染的优势</h2><p>可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。</p><p>更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了<a href="https://github.com/ButterCMS/react-ssr-example/releases/tag/starter-code" target="_blank" rel="external">相关代码</a>，您可以在其中看到完整的示例。</p><p>提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 <a href="https://buttercms.com/" target="_blank" rel="external">ButterCMS</a> 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以<a href="https://buttercms.com/home/" target="_blank" rel="external">使用你的 GitHub 账号登入 ButterCMS</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Butter <span class="keyword">from</span> <span class="string">'buttercms'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> butter = Butter(<span class="string">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">loaded</span>: <span class="literal">false</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentWillMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    butter.post.list().then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">loaded</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">resp</span>: resp.data</div><div class="line">      &#125;)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.loaded) &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">          &#123;this.state.resp.data.map((post) =&gt; &#123;</div><div class="line">            return (</div><div class="line">              &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt;</div><div class="line">            )</div><div class="line">          &#125;)&#125;</div><div class="line">        &lt;/div&gt;</div><div class="line">      );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> &lt;div&gt;Loading...&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Hello;</div></pre></td></tr></table></figure><p>启动器代码中包含以下内容：</p><ul><li>package.json - 依赖项</li><li>Webpack 和 Babel 配置</li><li>index.html - app 的 HTML 文件</li><li>index.js - 加载 React 并渲染 Hello 组件</li></ul><p>要使应用运行，请先克隆资源库：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">git</span></span> clone ...</div><div class="line"><span class="function"><span class="title">cd</span></span> ..</div></pre></td></tr></table></figure><p>安装依赖:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure><p>然后启动服务器:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> start</span></div></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a> 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：<code>&quot;start&quot;: webpack-dev-server --watch</code>)</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358286/localhost_r84tot.png" alt=""></p><p>如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取:</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358332/some-html_mrmpfj.png" alt=""></p><h2 id="增加服务器端渲染"><a href="#增加服务器端渲染" class="headerlink" title="增加服务器端渲染"></a>增加服务器端渲染</h2><p>接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看<a href="https://github.com/ButterCMS/react-ssr-example/commit/525c625b0f65489050983ed03b52bb7770ce6b7a" target="_blank" rel="external">GitHub上的差异</a>。</p><p>To get started, we’ll install Express, a Node.js server side application framework:<br>开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install <span class="built_in">express</span> --<span class="built_in">save</span></div></pre></td></tr></table></figure><p>我们要创建一个渲染我们的 React 组件的服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./Hello.js'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="comment">// 把 Hello 组件渲染成 HTML 字符串</span></div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span>);</span></div><div class="line"></div><div class="line">  // 加载 index.html 的内容</div><div class="line">  fs.readFile('./index.html', 'utf8', function (err, data) &#123;</div><div class="line">    if (err) throw err;</div><div class="line"></div><div class="line">    // 把渲染后的 React HTML 插入到 div 中</div><div class="line">    const document = data.replace(/<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">\</span>/<span class="attr">div</span>&gt;</span>/, `<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>$&#123;html&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`);</div><div class="line"></div><div class="line">    // 把响应传回给客户端</div><div class="line">    res.send(document);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const app = express();</div><div class="line"></div><div class="line">// 服务器使用 static 中间件构建 build 路径</div><div class="line">app.use('/build', express.static(path.join(__dirname, 'build')));</div><div class="line"></div><div class="line">// 使用我们的 handleRender 中间件处理服务端请求</div><div class="line">app.get('*', handleRender);</div><div class="line"></div><div class="line">// 启动服务器</div><div class="line">app.listen(3000);</div></pre></td></tr></table></figure><p>让我们分解下程序看看发生了什么事情…</p><p><code>handleRender</code> 函数处理所有请求。在文件顶部导入的 <a href="https://facebook.github.io/react/docs/react-dom-server.html" target="_blank" rel="external">ReactDOMServer 类</a>提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span>);</span></div></pre></td></tr></table></figure><p></p><p>这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">document</span> = data.replace(<span class="regexp">/&lt;div id="app"&gt;&lt;\/div&gt;/</span>,<span class="string">`&lt;div id="app"&gt;<span class="subst">$&#123;html&#125;</span>&lt;/div&gt;`</span>);</div></pre></td></tr></table></figure><p>To start the server, update the start script in package.json and then run npm run start:<br>要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 <code>npm run start</code> :</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"start"</span>: <span class="string">"webpack &amp;&amp; babel-node server.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>浏览 <code>http://localhost:3000</code> 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，<br>如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358447/devtools_qx5y1o.png" alt=""></p><p>虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，<a href="https://github.com/facebook/react/issues/1739" target="_blank" rel="external">React repo 有一个 issue</a>，超过 100 条评论讨论了这个问题和各种解决方法。</p><h2 id="在渲染之前获取数据"><a href="#在渲染之前获取数据" class="headerlink" title="在渲染之前获取数据"></a>在渲染之前获取数据</h2><p>要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在<a href="https://github.com/ButterCMS/react-ssr-example/commit/5fdd453e31ab08dfdc8b44261696d4ed89fbb719" target="_blank" rel="external">GitHub上查看完整的差异</a>。</p><p>To move data fetching before rendering, we’ll install react-transmit:<br>要在渲染之前获取数据，我们需安装 <a href="https://github.com/RickWong/react-transmit" target="_blank" rel="external">react-transmit</a>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> react-transmit <span class="comment">--save</span></div></pre></td></tr></table></figure><p>React Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。</p><p>这是我们使用 react-transmit 后的组件的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Butter <span class="keyword">from</span> <span class="string">'buttercms'</span></div><div class="line"><span class="keyword">import</span> Transmit <span class="keyword">from</span> <span class="string">'react-transmit'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> butter = Butter(<span class="string">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.posts) &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">          &#123;this.props.posts.data.map((post) =&gt; &#123;</div><div class="line">            return (</div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;post.slug&#125;</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            )</div><div class="line">          &#125;)&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Transmit.createContainer(Hello, &#123;</div><div class="line">  <span class="comment">// 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错</span></div><div class="line">  initialVariables: &#123;&#125;,</div><div class="line">  <span class="comment">// 定义的方法名将成为 Transmit props 的名称</span></div><div class="line">  fragments: &#123;</div><div class="line">    posts() &#123;</div><div class="line">      <span class="keyword">return</span> butter.post.list().then(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.data);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们已经使用 <code>Transmit.createContainer</code> 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。</p><p>为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 <code>Transmit.renderToString</code> 而不是 <code>ReactDOM.renderToString</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./Hello.js'</span>;</div><div class="line"><span class="keyword">import</span> Transmit <span class="keyword">from</span> <span class="string">'react-transmit'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  Transmit.renderToString(Hello).then(<span class="function">(<span class="params">&#123;reactString, reactData&#125;</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(<span class="string">'./index.html'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="built_in">document</span> = data.replace(<span class="regexp">/&lt;div id="app"&gt;&lt;\/div&gt;/</span>, <span class="string">`&lt;div id="app"&gt;<span class="subst">$&#123;reactString&#125;</span>&lt;/div&gt;`</span>);</div><div class="line">      <span class="keyword">const</span> output = Transmit.injectIntoMarkup(<span class="built_in">document</span>, reactData, [<span class="string">'/build/client.js'</span>]);</div><div class="line"></div><div class="line">      res.send(<span class="built_in">document</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="comment">// 服务器使用 static 中间件构建 build 路径</span></div><div class="line">app.use(<span class="string">'/build'</span>, express.static(path.join(__dirname, <span class="string">'build'</span>)));</div><div class="line"></div><div class="line"><span class="comment">// 使用我们的 handleRender 中间件处理服务端请求</span></div><div class="line">app.get(<span class="string">'*'</span>, handleRender);</div><div class="line"></div><div class="line"><span class="comment">// 启动服务器</span></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure><p>重新启动服务器浏览到 <code>http://localhost：3000</code>。查看页面源代码，您将看到该页面现在完全呈现在服务器上！</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358548/rendered-react_t5neam.png" alt=""></p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 <a href="https://github.com/electrode-io/electrode" target="_blank" rel="external">Electrode</a> 或 <a href="https://github.com/zeit/next.js" target="_blank" rel="external">Next.js</a>。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 <a href="https://github.com/airbnb/hypernova" target="_blank" rel="external">Hypernova</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/f82f7765b1171459d9fa593df836c658.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;原文地址：&lt;a href=&quot;https://css-tricks.com/server-side-react-rendering/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server-Side React Rendering&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="SEO" scheme="http://muyunyun.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>使用 React 全家桶搭建一个后台管理系统</title>
    <link href="http://muyunyun.cn/posts/9bfbdbf4/"/>
    <id>http://muyunyun.cn/posts/9bfbdbf4/</id>
    <published>2017-06-14T17:16:07.000Z</published>
    <updated>2017-08-08T22:07:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy" alt=""></p><p>使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。<br><a id="more"></a></p><h2 id="项目地址以及局部展示"><a href="#项目地址以及局部展示" class="headerlink" title="项目地址以及局部展示"></a>项目地址以及局部展示</h2><ul><li><p><a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">项目地址</a></p></li><li><p>小模块展示：<br><img src="http://files.cnblogs.com/files/MuYunyun/reactSPA.gif" alt=""></p></li><li>redux在项目中的运用demo展示<br><img src="http://files.cnblogs.com/files/MuYunyun/todoList.gif" alt=""></li></ul><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">├── build<span class="selector-class">.js</span>                   项目打包后的文件</div><div class="line">├── config                     webpack配置文件</div><div class="line">│   ├──...</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.dev</span><span class="selector-class">.js</span>   开发环境配置</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.prod</span><span class="selector-class">.js</span>  生产环境配置</div><div class="line">├── node_modules               node模块目录</div><div class="line">├── public</div><div class="line">│   └──index<span class="selector-class">.html</span></div><div class="line">├── scripts</div><div class="line">│   ├── build<span class="selector-class">.js</span>               打包项目文件</div><div class="line">│   ├── start<span class="selector-class">.js</span>               启动项目文件</div><div class="line">│   └── test<span class="selector-class">.js</span>                测试项目文件</div><div class="line">├── src</div><div class="line">│   ├── client                 汇聚(入口)目录</div><div class="line">│   ├── common                 核心目录</div><div class="line">│   │   ├── actions            redux中的action</div><div class="line">│   │   ├── components         通用功能组件</div><div class="line">│   │   ├── container          通用样式组件</div><div class="line">│   │   ├── images</div><div class="line">│   │   ├── pages              页面模块</div><div class="line">│   │   ├── reducers           redux中的reducer</div><div class="line">│   │   ├── utils              工具类</div><div class="line">│   │   │   ├── config<span class="selector-class">.js</span>      通用配置</div><div class="line">│   │   │   ├── <span class="selector-tag">menu</span><span class="selector-class">.js</span>        菜单配置</div><div class="line">│   │   │   └── ajax<span class="selector-class">.js</span>        ajax模块(日后用到)</div><div class="line">│   │   └── routes<span class="selector-class">.js</span>          前端路由</div><div class="line">│   └── server                 服务端目录(日后用到)</div><div class="line">│       └── controller</div><div class="line">├── <span class="selector-class">.gitignore</span></div><div class="line">├── package<span class="selector-class">.json</span></div><div class="line">├── README<span class="selector-class">.md</span></div><div class="line">└── yarn.lock</div></pre></td></tr></table></figure><p>项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。</p><p>下面对目录结构作以下说明</p><ul><li>项目最初始是用 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a> 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;</li><li>client 作为入口目录，到时候可以把第三方中间件也放在此处;</li><li>container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">container</th><th style="text-align:center">component</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">如何工作(数据获取,状态更新)</td><td style="text-align:center">如何显示(样式，布局)</td></tr><tr><td style="text-align:center">是否在 Redux 数据流中</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">读取数据</td><td style="text-align:center">从 Redux 获取 state</td><td style="text-align:center">从 props 获取数据</td></tr><tr><td style="text-align:center">修改数据</td><td style="text-align:center">向 Redux 派发 actions</td><td style="text-align:center">从 props 调用回调函数</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">向react-redux生成</td><td style="text-align:center">手写</td></tr></tbody></table><ul><li>ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。</li><li>server 层就是作为网关层，日后计划用来写 node 的。</li></ul><h2 id="技术栈相关"><a href="#技术栈相关" class="headerlink" title="技术栈相关"></a>技术栈相关</h2><p>虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;</p><h3 id="webpack-2-x"><a href="#webpack-2-x" class="headerlink" title="webpack(2.x)"></a>webpack(2.x)</h3><p>4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="external">babel-plugin-import</a> 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        <span class="attr">include</span>: paths.appSrc,</div><div class="line">        <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">plugins</span>: [</div><div class="line">            <span class="string">"transform-decorators-legacy"</span>,  <span class="comment">// 引人 ES7 的装饰器 @</span></div><div class="line">            [<span class="string">'import'</span>, [&#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;]],</div><div class="line">          ],</div><div class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div></pre></td></tr></table></figure><p></p><h4 id="引人less"><a href="#引人less" class="headerlink" title="引人less"></a>引人less</h4><p>首先引人 <a href="https://github.com/webpack-contrib/less-loader" target="_blank" rel="external">less-loader</a> 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  test: <span class="regexp">/\.less$/</span>,</div><div class="line">  <span class="attr">use</span>: [</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">ident</span>: <span class="string">'postcss'</span>, <span class="comment">//https://webpack.js.org/guides/migrating/#complex-options</span></div><div class="line">        plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</div><div class="line">          <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</div><div class="line">          autoprefixer(&#123;</div><div class="line">            <span class="attr">browsers</span>: [</div><div class="line">              <span class="string">'&gt;1%'</span>,</div><div class="line">              <span class="string">'last 4 versions'</span>,</div><div class="line">              <span class="string">'Firefox ESR'</span>,</div><div class="line">              <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></div><div class="line">            ],</div><div class="line">            <span class="attr">flexbox</span>: <span class="string">'no-2009'</span>,</div><div class="line">          &#125;),</div><div class="line">        ],</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">modifyVars</span>: &#123; <span class="string">"@primary-color"</span>: <span class="string">"#1DA57A"</span> &#125;,  <span class="comment">// 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。</span></div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  ],</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p></p><h4 id="一键发布到-gh-pages"><a href="#一键发布到-gh-pages" class="headerlink" title="一键发布到 gh-pages"></a>一键发布到 gh-pages</h4><p>用到了 <a href="https://github.com/tschaub/gh-pages" target="_blank" rel="external">gh-pages</a> ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。</p><h4 id="引用路径的缩写"><a href="#引用路径的缩写" class="headerlink" title="引用路径的缩写"></a>引用路径的缩写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">alias: &#123;</div><div class="line">      <span class="string">'react-native'</span>: <span class="string">'react-native-web'</span>,</div><div class="line">      <span class="attr">components</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/components'</span>,</div><div class="line">      <span class="attr">container</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/container'</span>,</div><div class="line">      <span class="attr">images</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/images'</span>,</div><div class="line">      <span class="attr">pages</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/pages'</span>,</div><div class="line">      <span class="attr">utils</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/utils'</span>,</div><div class="line">      <span class="attr">data</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/server/data'</span>,</div><div class="line">      <span class="attr">actions</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/actions'</span>,</div><div class="line">      <span class="attr">reducers</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/reducers'</span>,</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>配置了引用路径的缩写后，就可以在任意地方如这样引用，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Table <span class="keyword">from</span> <span class="string">'components/table'</span></div></pre></td></tr></table></figure><p></p><h3 id="Antd-2-x"><a href="#Antd-2-x" class="headerlink" title="Antd(2.x)"></a>Antd(2.x)</h3><p>antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的<a href="https://ant.design/docs/spec/introduce-cn" target="_blank" rel="external">设计理念</a>也学到了很多关于UI、UX的知识。<br>该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。</p><h3 id="React-router-4-x"><a href="#React-router-4-x" class="headerlink" title="React-router(4.x)"></a>React-router(4.x)</h3><p>react-router 4.x和2.x的差异又是特别的大，召唤<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="external">文档</a>,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。</p><p>2.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/aaaa"</span> <span class="attr">component</span>=<span class="string">&#123;AAAA&#125;</span> /&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/bbbb"</span> <span class="attr">component</span>=<span class="string">&#123;BBBB&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>4.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</div><div class="line">&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;</div><div class="line">&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;</div></pre></td></tr></table></figure><p></p><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch 使用比较简单，基本的 promise 用法如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</div><div class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e))</div></pre></td></tr></table></figure><p></p><p>此外还能这样用<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.json();</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 <a href="https://www.npmjs.com/package/fetch-jsonp" target="_blank" rel="external">fetch-jsonp</a> 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetchJsonp(url,&#123;<span class="attr">method</span>: <span class="string">'GET'</span>&#125;)</div><div class="line">　　.then(<span class="function">(<span class="params">res</span>) =&gt;</span>res.json())</div><div class="line">　　.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure><p></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/a40c3540ca26a56b28506d14125c04c1.jpg-400" alt=""></p><p>画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇<a href="http://www.cnblogs.com/MuYunyun/p/6530715.html" target="_blank" rel="external">深入Redux架构</a></p><p>下面通过把 <a href="https://github.com/MuYunyun/todoList" target="_blank" rel="external">代办事项</a> 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。</p><p>首先，在入口目录创建 store<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(rootReducer)</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    &#123; routes &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p></p><p>接着，我使用了 <a href="https://github.com/acdlite/redux-actions" target="_blank" rel="external">redux-actions</a> 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。</p><p>代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = createAction(<span class="string">'SET_VISIBILITY'</span>)</div></pre></td></tr></table></figure><p></p><p>没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">type</span>: <span class="string">"SET_VISIBILITY"</span>,</div><div class="line">		filter</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>相应的代办事项的 reducers 文件片段:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = handleActions(&#123;</div><div class="line">  <span class="string">'SET_VISIBILITY'</span>(state, action) &#123;</div><div class="line">    <span class="keyword">return</span> &#123; ...state, ...action.payload&#125;</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="string">'SHOW_ALL'</span>)</div></pre></td></tr></table></figure><p></p><p>使用 redux-actions 后，只要进行如下调用,reducers文件里的<code>SET_VISIBILITY</code>的 action 就能捕获到<code>SHOW_ALL</code>这个状态。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; setVisibility &#125; <span class="keyword">from</span> <span class="string">'actions/todoList'</span></div><div class="line">@connect(</div><div class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</div><div class="line">        <span class="attr">setVisibility</span>: state.setVisibility, <span class="comment">// 这个 setVisibility 是取自 reducers 的</span></div><div class="line">    &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">dispatch(<span class="keyword">this</span>.props.dispatch(setVisibility(<span class="string">'SHOW_ALL'</span>)))</div></pre></td></tr></table></figure><p></p><p>connect 来自 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">react-redux</a>，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>。</p><h2 id="项目的一些扩展计划"><a href="#项目的一些扩展计划" class="headerlink" title="项目的一些扩展计划"></a>项目的一些扩展计划</h2><p>计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，<a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">点我 Star</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="Redux" scheme="http://muyunyun.cn/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-你不知道的 JavaScript (上)</title>
    <link href="http://muyunyun.cn/posts/4a895cbd/"/>
    <id>http://muyunyun.cn/posts/4a895cbd/</id>
    <published>2017-06-06T14:15:01.000Z</published>
    <updated>2017-08-08T22:07:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy" alt=""></p><p>《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。<br><a id="more"></a></p><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量。</p><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li>分词/词法分析<br>将字符串分解成有意义的代码块，代码块又称词法单元。比如程序<code>var a = 2;</code>会被分解为<code>var、a、=、2、;</code></li><li>解析/语法分析<br>将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。</li><li>代码生成<br>将抽象语法树转换为机器能够识别的指令。</li></ul><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>作用域 分别与编译器、引擎进行配合完成代码的解析</p><ul><li>引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。</li><li>编译器负责语法分析以及生成代码。</li><li>作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。</li></ul><p>对于 <code>var a = 2</code> 这条语句，首先编译器会将其分为两部分，一部分是 <code>var a</code>，一部分是 <code>a = 2</code>。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>对于 <code>var a = 10</code> 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 <code>LHS</code> 查询。 对于 <code>console.log(a)</code> 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 <code>RHS</code> 查询。</p><p>为什么区分 <code>LHS</code> 和 <code>RHS</code> 是一件重要的事情？<br>在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。</p><h2 id="作用域的工作模式"><a href="#作用域的工作模式" class="headerlink" title="作用域的工作模式"></a>作用域的工作模式</h2><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><p>词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="匿名与具名"><a href="#匿名与具名" class="headerlink" title="匿名与具名"></a>匿名与具名</h3><p>对于函数表达式一个最熟悉的场景可能就是回调函数了，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><p>这叫作<code>匿名函数表达式</code>。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。</li><li>如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ul><p>始终给函数表达式命名是一个最佳实践:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 我有名字了</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><h3 id="先有声明还是先有赋值"><a href="#先有声明还是先有赋值" class="headerlink" title="先有声明还是先有赋值"></a>先有声明还是先有赋值</h3><p>考虑以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p></p><p>考虑另外一段代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure><p></p><p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。</p><p>可以看出，先有声明后有赋值。</p><p>再来看以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这个代码片段经过提升后，实际上会被理解为以下形式:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"></div><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个<code>函数声明而不是函数表达式就会赋值</code>)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>之前写过关于闭包的一篇文章<a href="http://www.cnblogs.com/MuYunyun/p/5930703.html" target="_blank" rel="external">深入浅出JavaScript之闭包(Closure)</a></p><h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>要说明闭包，for 循环是最常见的例子。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。</p><p>它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>还可以对这段代码进行一些改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><h4 id="重返块作用域"><a href="#重返块作用域" class="headerlink" title="重返块作用域"></a>重返块作用域</h4><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">  &#125;, j*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>本质上这是将一个块转换成一个可以被关闭的作用域。</p><p>此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h2><p>之前写过一篇<a href="http://www.cnblogs.com/MuYunyun/p/5932024.html" target="_blank" rel="external">深入浅出JavaScript之this</a>。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>来看下面这段代码的问题：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="string">"awesome"</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span>;</div><div class="line"></div><div class="line">obj.cool();  <span class="comment">// awesome</span></div><div class="line"></div><div class="line">setTimeout( obj.cool, <span class="number">100</span>); <span class="comment">// not awesome</span></div></pre></td></tr></table></figure><p></p><p>obj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引人了一个叫作 this 词法的行为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。</p><p>但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。</p><p>箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"more awesome"</span>);</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// more awesome</span></div></pre></td></tr></table></figure><p></p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。</p><ul><li>默认绑定<ul><li>独立函数调用</li></ul></li><li>隐式绑定<ul><li>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象</li></ul></li><li>显示绑定<ul><li>call/apply</li><li>bind（本质是对call/apply函数的封装 <code>fn.apply( obj, arguments )</code>）</li><li>第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 this</li></ul></li><li>new 绑定<ul><li>JavaScript 中的 new 机制实际上和面向类的语言完全不同</li><li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</li></ul></li></ul><p>书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:</p><ul><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</li><li>函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。</li></ul><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><p>其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。</p><p>使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript中的对象有字面形式（比如<code>var a = { .. }</code>)和构造形式（比如<code>var a = new Array(..)</code>）。字面形式更常用，不过有时候构造形式可以提供更多选择。</p><p>作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>思考一下这个对象：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">  <span class="attr">c</span>: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherArray = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">b</span>: anotherObject, <span class="comment">// 引用，不是复本！</span></div><div class="line">  c: anotherArray, <span class="comment">// 另一个引用！</span></div><div class="line">  d: anotherFunction</div><div class="line">&#125;;</div><div class="line"></div><div class="line">anotherArray.push( myObject )</div></pre></td></tr></table></figure><p></p><p>如何准确地表示 myObject 的复制呢？<br>这里有一个知识点。</p><ul><li>浅复制。复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用。</li><li>深复制。除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。</li></ul><p>对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的复制方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(someObj) )</div></pre></td></tr></table></figure><p></p><p>我认为这种方法就是深复制。相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject );</div><div class="line"></div><div class="line">newObj.a; <span class="comment">// 2</span></div><div class="line">newObj.b === anotherObject; <span class="comment">// true</span></div><div class="line">newObj.c === anotherArray; <span class="comment">// true</span></div><div class="line">newObj.d === anotherFunction; <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。</p><ul><li>类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。</li><li>JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li></ul><h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><p>思考下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.blah = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure><p></p><p>我们如何找出 a 的“祖先”（委托关系）呢？</p><ul><li>方法一：<code>a instanceof Foo; // true</code> (对象 instanceof 函数)</li><li>方法二: <code>Foo.prototype.isPrototypeOf(a); // true</code> (对象 isPrototypeOf 对象)</li><li>方法三: <code>Object.getPrototypeOf(a) === Foo.prototype; // true</code> (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;</li><li>方法四: <code>a.__proto__ == Foo.prototype; // true</code></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</li><li>使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。</li><li>constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。</li></ul><h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p>来看下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">something</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Tell me something good..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">Object</span>.create(foo);</div><div class="line"></div><div class="line">bar.something(); <span class="comment">// Tell me something good...</span></div></pre></td></tr></table></figure><p></p><p>Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。</p><p>Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p><p>此书的第二章第6部分就把<code>面对类和继承</code>和<code>行为委托</code>两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到<code>Object.create()</code>的强大。</p><h3 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h3><p>来看一段 ES6中Class 的例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  render($where)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">      <span class="keyword">this</span>.$elem.css(&#123;</div><div class="line">        <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>，</div><div class="line">        height: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">      &#125;).appendTo($where);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height, label) &#123;</div><div class="line">    <span class="keyword">super</span>(width, height);</div><div class="line">    <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = $(<span class="string">"&lt;button&gt;"</span>).text(<span class="keyword">this</span>.label)</div><div class="line">  &#125;</div><div class="line">  render($where) &#123;</div><div class="line">    <span class="keyword">super</span>($where);</div><div class="line">    <span class="keyword">this</span>.$elem.click(<span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">  onClick(evt) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>除了语法更好看之外，ES6还有以下优点</p><ul><li>基本上不再引用杂乱的 .prototype 了。</li><li>Button 声明时直接 “继承” 了 Widget。</li><li>可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。</li><li>class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。</li><li>可以通过 extends 很自然地扩展对象(子)类型。</li></ul><p>但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。</p><p>这也是本书作者希望我们思考的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://muyunyun.cn/categories/JavaScript/"/>
    
    
      <category term="读书笔记" scheme="http://muyunyun.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>hexo 摸爬滚打之进阶教程</title>
    <link href="http://muyunyun.cn/posts/f55182c5/"/>
    <id>http://muyunyun.cn/posts/f55182c5/</id>
    <published>2017-05-29T14:01:26.000Z</published>
    <updated>2017-11-03T01:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy" alt=""></p><p>写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了<a href="https://hexo.io/" target="_blank" rel="external">hexo</a>。本文有以下内容:</p><ul><li>快速实现博客压缩</li><li>文章链接唯一化</li><li>添加酷炫的打赏二维码</li><li>自定义JS和CSS</li><li>添加酷炫的歌单模块以及播放器</li><li>github分支管理博客思路</li><li>秒传图片到七牛云并展现在博客中</li><li>将博客同时部署到github和coding<a id="more"></a></li></ul><h2 id="快速实现博客压缩"><a href="#快速实现博客压缩" class="headerlink" title="快速实现博客压缩"></a>快速实现博客压缩</h2><p>项目压缩也叫<code>代码丑化</code>,分别对html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把images进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。</p><p>蛮多朋友使用了<code>gulp</code>对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="external">hexo-all-minifier</a>，这个模块集成了对html、css、js、image的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">html_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  ignore_error: <span class="literal">false</span></div><div class="line">  exclude:</div><div class="line"></div><div class="line">css_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.css'</span></div><div class="line"></div><div class="line">js_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  mangle: <span class="literal">true</span></div><div class="line">  output:</div><div class="line">  compress:</div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.js'</span></div><div class="line"></div><div class="line">image_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  interlaced: <span class="literal">false</span></div><div class="line">  multipass: <span class="literal">false</span></div><div class="line">  optimizationLevel: <span class="number">2</span></div><div class="line">  pngquant: <span class="literal">false</span></div><div class="line">  progressive: <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h2 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h2><p>也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-abbrlink --save</div></pre></td></tr></table></figure><p>在<code>站点配置文件</code>中查找代码<code>permalink</code>，将其更改为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: posts/:abbrlink/  # “posts/” 可自行更换</div></pre></td></tr></table></figure><p>这里有个知识点：</p><blockquote><p>百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p></blockquote><p>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p><p>然后在<code>站点配置文件</code>中添加如下代码:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># abbrlink config</div><div class="line">abbrlink:</div><div class="line">  alg: crc32  # 算法：crc16(default) and crc32</div><div class="line">  rep: hex    # 进制：dec(default) and hex</div></pre></td></tr></table></figure><p></p><p>可选择模式：</p><ul><li>crc16 &amp; hex</li><li>crc16 &amp; dec</li><li>crc32 &amp; hex</li><li>crc32 &amp; dec</li></ul><h2 id="添加酷炫的打赏二维码"><a href="#添加酷炫的打赏二维码" class="headerlink" title="添加酷炫的打赏二维码"></a>添加酷炫的打赏二维码</h2><p>看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)<br><img src="http://oqhtscus0.bkt.clouddn.com/134f61fc3181e90acfa945aad72a04a6.png-400" alt=""></p><p>实现这个酷炫二维码的流程如下：</p><ul><li>首先，分别获得支付宝和微信的收款码</li><li>接着到<a href="https://www.hotapp.cn/shouqian" target="_blank" rel="external">芝麻二维码</a>里将两张二维码合并</li><li>最后到<a href="http://www.9thws.com/" target="_blank" rel="external">第九工场</a>生成自己喜欢的造型</li></ul><p>讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alipay: <span class="regexp">/pay.png</span></div></pre></td></tr></table></figure><p></p><h3 id="打赏字体不闪动"><a href="#打赏字体不闪动" class="headerlink" title="打赏字体不闪动"></a>打赏字体不闪动</h3><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 注释文字闪动函数</span></div><div class="line"> #wechat:hover p&#123;</div><div class="line">    animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line"> #alipay:hover p&#123;</div><div class="line">   animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure><p></p><h2 id="自定义JS和CSS"><a href="#自定义JS和CSS" class="headerlink" title="自定义JS和CSS"></a>自定义JS和CSS</h2><p>博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的</p><h3 id="添加自定义js样式"><a href="#添加自定义js样式" class="headerlink" title="添加自定义js样式"></a>添加自定义js样式</h3><ul><li>首先把js文件放在<code>\themes\next\source\js\src</code>文件目录下</li><li>然后找到<code>\themes\next\layout</code>目录下的布局文件<code>_layout.swig</code></li><li>把script引用代码加入到该文件中即可</li></ul><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="添加自定义css样式"><a href="#添加自定义css样式" class="headerlink" title="添加自定义css样式"></a>添加自定义css样式</h3><p>添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在<code>\themes\next\source\css\_custom\custom.styl</code>文件中进行样式的添加。</p><h2 id="添加酷炫的歌单模块以及播放器"><a href="#添加酷炫的歌单模块以及播放器" class="headerlink" title="添加酷炫的歌单模块以及播放器"></a>添加酷炫的歌单模块以及播放器</h2><p>这个模块借鉴了@<a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a>。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：<br><img src="http://oqhtscus0.bkt.clouddn.com/502d78856e46095253e59fd11396b2a4.jpg" alt=""><br>核心代码在<code>\themes\next\source\js\src\music\nmlist</code>中，<a href="https://github.com/MuYunyun/MuYunyun.githubio/blob/muyy/themes/next/source/js/src/music/nmlist.js" target="_blank" rel="external">点击看源码</a>，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。</p><p>在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了<code>$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)</code>解决了这个bug。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/73d9f4070b81bbdab8f80db388af4a40.jpg" alt=""></p><p>再接着玩的话，可以给播放器加上歌词的功能。这里有一篇<a href="http://frankorz.com/2016/09/30/Hexo-patch/#歌词" target="_blank" rel="external">相关文章</a>,有机会可以去把玩一番。</p><h2 id="github分支管理博客思路"><a href="#github分支管理博客思路" class="headerlink" title="github分支管理博客思路"></a>github分支管理博客思路</h2><p>有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件push到user.github.io的其他分支。我选择了后者。</p><h3 id="创建muyy-任意-分支"><a href="#创建muyy-任意-分支" class="headerlink" title="创建muyy(任意)分支"></a>创建muyy(任意)分支</h3><p>创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>然后我们再初始化仓库，重新对我们的代码进行版本控制<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p></p><p><code>&lt;server&gt;</code>是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端</p><h3 id="将博客源文件上传至muyy分支"><a href="#将博客源文件上传至muyy分支" class="headerlink" title="将博客源文件上传至muyy分支"></a>将博客源文件上传至muyy分支</h3><p>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/.deploy_git</div><div class="line">/public</div><div class="line">/_config.yml</div></pre></td></tr></table></figure><p></p><p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</p><p>依次执行<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m <span class="string">"..."</span></div><div class="line">git push origin muyy</div></pre></td></tr></table></figure><p></p><h2 id="秒传图片到七牛云并展现在博客中"><a href="#秒传图片到七牛云并展现在博客中" class="headerlink" title="秒传图片到七牛云并展现在博客中"></a>秒传图片到七牛云并展现在博客中</h2><p>在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具<a href="https://github.com/jiwenxing/qiniu-image-tool" target="_blank" rel="external">qiniu-image-tool</a>，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac是基于Alfred的，其windows也有相应版本<a href="http://jverson.com/2017/05/28/qiniu-image-v2/" target="_blank" rel="external">windows版本</a>。</p><p>按照其要求配置好以后，用截图软件截图后，或者本地图片后copy，然后直接按设置好的command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。<br><img src="https://raw.githubusercontent.com/jiwenxing/qiniu-image-tool/master/res/local.gif" alt=""></p><h2 id="将博客同时部署到github和coding"><a href="#将博客同时部署到github和coding" class="headerlink" title="将博客同时部署到github和coding"></a>将博客同时部署到github和coding</h2><p>通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。</p><h3 id="coding上创建一个新项目"><a href="#coding上创建一个新项目" class="headerlink" title="coding上创建一个新项目"></a>coding上创建一个新项目</h3><p>这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面<br><img src="http://oqhtscus0.bkt.clouddn.com/41b27d98189a9164d2b2a47ccbafdbfa.jpg" alt=""></p><h3 id="同步本地hexo到coding上"><a href="#同步本地hexo到coding上" class="headerlink" title="同步本地hexo到coding上"></a>同步本地hexo到coding上</h3><p>把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="external">coding帮助中心</a>,其实和github配置一模一样的。</p><p>本地打开 <code>id_rsa.pub</code> 文件，复制其中全部内容，填写到<code>SSH_RSA公钥</code>key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。</p><p>添加后，在git bash命令输入：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure><p></p><p>如果得到下面提示就表示公钥添加成功了：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Coding.net Tips : [Hello ! You<span class="string">'ve conected to Coding.net by SSH successfully! ]</span></div></pre></td></tr></table></figure><p></p><p>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  message: [message]</div><div class="line">  repo:</div><div class="line">    github: &lt;repository url&gt;,[branch]</div><div class="line">    gitcafe: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure><p></p><p>所以我是这样的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo:</div><div class="line">    github: https:<span class="comment">//github.com/MuYunyun/MuYunyun.github.io.git,master</span></div><div class="line">    coding: git@git.coding.net:muyunyun/muyunyun.git,master</div></pre></td></tr></table></figure><p></p><p>最后使用部署命令就能把博客同步到coding上面：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy -g</div></pre></td></tr></table></figure><p></p><h3 id="pages服务方式部署"><a href="#pages服务方式部署" class="headerlink" title="pages服务方式部署"></a>pages服务方式部署</h3><p>将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了</p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：<br><img src="http://oqhtscus0.bkt.clouddn.com/c2337ab8ed97d0f825703e8ea80a4123.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a></li><li><a href="http://www.vitah.net/posts/20f300cc/" target="_blank" rel="external">Hexo Next主题设置和优化</a></li><li><a href="http://frankorz.com/2016/09/30/Hexo-patch/" target="_blank" rel="external">Hexo 博客补丁</a></li><li><a href="http://www.cduyzh.com/page/3/" target="_blank" rel="external">Water Sister’s Blog</a></li><li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="external">Hexo+NexT主题配置备忘</a></li><li><a href="http://www.cherryblog.site/" target="_blank" rel="external">Cherry’s Blog</a></li><li><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="http://tengj.github.io/2016/03/06/hexo4/" target="_blank" rel="external">将hexo博客同时托管到github和coding</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;。本文有以下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;快速实现博客压缩&lt;/li&gt;&lt;li&gt;文章链接唯一化&lt;/li&gt;&lt;li&gt;添加酷炫的打赏二维码&lt;/li&gt;&lt;li&gt;自定义JS和CSS&lt;/li&gt;&lt;li&gt;添加酷炫的歌单模块以及播放器&lt;/li&gt;&lt;li&gt;github分支管理博客思路&lt;/li&gt;&lt;li&gt;秒传图片到七牛云并展现在博客中&lt;/li&gt;&lt;li&gt;将博客同时部署到github和coding
    
    </summary>
    
      <category term="git" scheme="http://muyunyun.cn/categories/git/"/>
    
    
      <category term="hexo" scheme="http://muyunyun.cn/tags/hexo/"/>
    
      <category term="blog" scheme="http://muyunyun.cn/tags/blog/"/>
    
  </entry>
  
</feed>
