<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牧之</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://muyunyun.cn/"/>
  <updated>2017-06-14T18:18:30.000Z</updated>
  <id>http://muyunyun.cn/</id>
  
  <author>
    <name>牧云云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用React全家桶搭建一个后台管理系统</title>
    <link href="http://muyunyun.cn/posts/9bfbdbf4/"/>
    <id>http://muyunyun.cn/posts/9bfbdbf4/</id>
    <published>2017-06-14T17:16:07.000Z</published>
    <updated>2017-06-14T18:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/posts/9bfbdbf4/">http://muyunyun.cn/posts/9bfbdbf4/</a></p></blockquote><p>使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。<br><a id="more"></a></p><h2 id="项目地址以及局部展示"><a href="#项目地址以及局部展示" class="headerlink" title="项目地址以及局部展示"></a>项目地址以及局部展示</h2><ul><li><p><a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">项目地址</a></p></li><li><p>小模块展示：<br><img src="http://files.cnblogs.com/files/MuYunyun/reactSPA.gif" alt=""></p></li><li>redux在项目中的运用demo展示<br><img src="http://files.cnblogs.com/files/MuYunyun/todoList.gif" alt=""></li></ul><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">├── build<span class="selector-class">.js</span>                   项目打包后的文件</div><div class="line">├── config                     webpack配置文件</div><div class="line">│   ├──...</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.dev</span><span class="selector-class">.js</span>   开发环境配置</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.prod</span><span class="selector-class">.js</span>  生产环境配置</div><div class="line">├── node_modules               node模块目录</div><div class="line">├── public</div><div class="line">│   └──index<span class="selector-class">.html</span></div><div class="line">├── scripts</div><div class="line">│   ├── build<span class="selector-class">.js</span>               打包项目文件</div><div class="line">│   ├── start<span class="selector-class">.js</span>               启动项目文件</div><div class="line">│   └── test<span class="selector-class">.js</span>                测试项目文件</div><div class="line">├── src</div><div class="line">│   ├── client                 汇聚(入口)目录</div><div class="line">│   ├── common                 核心目录</div><div class="line">│   │   ├── actions            redux中的action</div><div class="line">│   │   ├── components         通用功能组件</div><div class="line">│   │   ├── container          通用样式组件</div><div class="line">│   │   ├── images</div><div class="line">│   │   ├── pages              页面模块</div><div class="line">│   │   ├── reducers           redux中的reducer</div><div class="line">│   │   ├── utils              工具类</div><div class="line">│   │   │   ├── config<span class="selector-class">.js</span>      通用配置</div><div class="line">│   │   │   ├── <span class="selector-tag">menu</span><span class="selector-class">.js</span>        菜单配置</div><div class="line">│   │   │   └── ajax<span class="selector-class">.js</span>        ajax模块(日后用到)</div><div class="line">│   │   └── routes<span class="selector-class">.js</span>          前端路由</div><div class="line">│   └── server                 服务端目录(日后用到)</div><div class="line">│       └── controller</div><div class="line">├── <span class="selector-class">.gitignore</span></div><div class="line">├── package<span class="selector-class">.json</span></div><div class="line">├── README<span class="selector-class">.md</span></div><div class="line">└── yarn.lock</div></pre></td></tr></table></figure><p>项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。</p><p>下面对目录结构作以下说明</p><ul><li>项目最初始是用 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a> 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;</li><li>client 作为入口目录，到时候可以把第三方中间件也放在此处;</li><li>container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">container</th><th style="text-align:center">component</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">如何工作(数据获取,状态更新)</td><td style="text-align:center">如何显示(样式，布局)</td></tr><tr><td style="text-align:center">是否在 Redux 数据流中</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">读取数据</td><td style="text-align:center">从 Redux 获取 state</td><td style="text-align:center">从 props 获取数据</td></tr><tr><td style="text-align:center">修改数据</td><td style="text-align:center">向 Redux 派发 actions</td><td style="text-align:center">从 props 调用回调函数</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">向react-redux生成</td><td style="text-align:center">手写</td></tr></tbody></table><ul><li>ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。</li><li>server 层就是作为网关层，日后计划用来写 node 的。</li></ul><h2 id="技术栈相关"><a href="#技术栈相关" class="headerlink" title="技术栈相关"></a>技术栈相关</h2><p>虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;</p><h3 id="webpack-2-x"><a href="#webpack-2-x" class="headerlink" title="webpack(2.x)"></a>webpack(2.x)</h3><p>4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="external">babel-plugin-import</a> 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        <span class="attr">include</span>: paths.appSrc,</div><div class="line">        <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">plugins</span>: [</div><div class="line">            <span class="string">"transform-decorators-legacy"</span>,  <span class="comment">// 引人 ES7 的装饰器 @</span></div><div class="line">            [<span class="string">'import'</span>, [&#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;]],</div><div class="line">          ],</div><div class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div></pre></td></tr></table></figure><p></p><h4 id="引人less"><a href="#引人less" class="headerlink" title="引人less"></a>引人less</h4><p>首先引人 <a href="https://github.com/webpack-contrib/less-loader" target="_blank" rel="external">less-loader</a> 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  test: <span class="regexp">/\.less$/</span>,</div><div class="line">  <span class="attr">use</span>: [</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">ident</span>: <span class="string">'postcss'</span>, <span class="comment">//https://webpack.js.org/guides/migrating/#complex-options</span></div><div class="line">        plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</div><div class="line">          <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</div><div class="line">          autoprefixer(&#123;</div><div class="line">            <span class="attr">browsers</span>: [</div><div class="line">              <span class="string">'&gt;1%'</span>,</div><div class="line">              <span class="string">'last 4 versions'</span>,</div><div class="line">              <span class="string">'Firefox ESR'</span>,</div><div class="line">              <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></div><div class="line">            ],</div><div class="line">            <span class="attr">flexbox</span>: <span class="string">'no-2009'</span>,</div><div class="line">          &#125;),</div><div class="line">        ],</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">modifyVars</span>: &#123; <span class="string">"@primary-color"</span>: <span class="string">"#1DA57A"</span> &#125;,  <span class="comment">// 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。</span></div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  ],</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p></p><h4 id="一键发布到-gh-pages"><a href="#一键发布到-gh-pages" class="headerlink" title="一键发布到 gh-pages"></a>一键发布到 gh-pages</h4><p>用到了 <a href="https://github.com/tschaub/gh-pages" target="_blank" rel="external">gh-pages</a> ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。</p><h4 id="引用路径的缩写"><a href="#引用路径的缩写" class="headerlink" title="引用路径的缩写"></a>引用路径的缩写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">alias: &#123;</div><div class="line">      <span class="string">'react-native'</span>: <span class="string">'react-native-web'</span>,</div><div class="line">      <span class="attr">components</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/components'</span>,</div><div class="line">      <span class="attr">container</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/container'</span>,</div><div class="line">      <span class="attr">images</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/images'</span>,</div><div class="line">      <span class="attr">pages</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/pages'</span>,</div><div class="line">      <span class="attr">utils</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/utils'</span>,</div><div class="line">      <span class="attr">data</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/server/data'</span>,</div><div class="line">      <span class="attr">actions</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/actions'</span>,</div><div class="line">      <span class="attr">reducers</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/reducers'</span>,</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>配置了引用路径的缩写后，就可以在任意地方如这样引用，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Table <span class="keyword">from</span> <span class="string">'components/table'</span></div></pre></td></tr></table></figure><p></p><h3 id="Antd-2-x"><a href="#Antd-2-x" class="headerlink" title="Antd(2.x)"></a>Antd(2.x)</h3><p>antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的<a href="https://ant.design/docs/spec/introduce-cn" target="_blank" rel="external">设计理念</a>也学到了很多关于UI、UX的知识。<br>该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。</p><h3 id="React-router-4-x"><a href="#React-router-4-x" class="headerlink" title="React-router(4.x)"></a>React-router(4.x)</h3><p>react-router 4.x和2.x的差异又是特别的大，召唤<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="external">文档</a>,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。</p><p>2.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/aaaa"</span> <span class="attr">component</span>=<span class="string">&#123;AAAA&#125;</span> /&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/bbbb"</span> <span class="attr">component</span>=<span class="string">&#123;BBBB&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>4.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</div><div class="line">&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;</div><div class="line">&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;</div></pre></td></tr></table></figure><p></p><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch 使用比较简单，基本的 promise 用法如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</div><div class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e))</div></pre></td></tr></table></figure><p></p><p>此外还能这样用<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.json();</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 <a href="https://www.npmjs.com/package/fetch-jsonp" target="_blank" rel="external">fetch-jsonp</a> 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetchJsonp(url,&#123;<span class="attr">method</span>: <span class="string">'GET'</span>&#125;)</div><div class="line">　　.then(<span class="function">(<span class="params">res</span>) =&gt;</span>res.json())</div><div class="line">　　.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure><p></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/a40c3540ca26a56b28506d14125c04c1.jpg-400" alt=""></p><p>画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇<a href="http://www.cnblogs.com/MuYunyun/p/6530715.html" target="_blank" rel="external">深入Redux架构</a></p><p>下面通过把 <a href="https://github.com/MuYunyun/todoList" target="_blank" rel="external">代办事项</a> 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。</p><p>首先，在入口目录创建 store<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(rootReducer)</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    &#123; routes &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p></p><p>接着，我使用了 <a href="https://github.com/acdlite/redux-actions" target="_blank" rel="external">redux-actions</a> 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。</p><p>代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = createAction(<span class="string">'SET_VISIBILITY'</span>)</div></pre></td></tr></table></figure><p></p><p>没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">type</span>: <span class="string">"SET_VISIBILITY"</span>,</div><div class="line">		filter</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>相应的代办事项的 reducers 文件片段:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = handleActions(&#123;</div><div class="line">  <span class="string">'SET_VISIBILITY'</span>(state, action) &#123;</div><div class="line">    <span class="keyword">return</span> &#123; ...state, ...action.payload&#125;</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="string">'SHOW_ALL'</span>)</div></pre></td></tr></table></figure><p></p><p>使用 redux-actions 后，只要进行如下调用,reducers文件里的<code>SET_VISIBILITY</code>的 action 就能捕获到<code>SHOW_ALL</code>这个状态。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; setVisibility &#125; <span class="keyword">from</span> <span class="string">'actions/todoList'</span></div><div class="line">@connect(</div><div class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</div><div class="line">        <span class="attr">setVisibility</span>: state.setVisibility, <span class="comment">// 这个 setVisibility 是取自 reducers 的</span></div><div class="line">    &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">dispatch(<span class="keyword">this</span>.props.dispatch(setVisibility(<span class="string">'SHOW_ALL'</span>)))</div></pre></td></tr></table></figure><p></p><p>connect 来自 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">react-redux</a>，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>。</p><h2 id="项目的一些扩展计划"><a href="#项目的一些扩展计划" class="headerlink" title="项目的一些扩展计划"></a>项目的一些扩展计划</h2><p>计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，<a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">点我 Star</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/posts/9bfbdbf4/&quot;&gt;http://muyunyun.cn/posts/9bfbdbf4/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="Redux" scheme="http://muyunyun.cn/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-你不知道的JavaScript(上)</title>
    <link href="http://muyunyun.cn/posts/4a895cbd/"/>
    <id>http://muyunyun.cn/posts/4a895cbd/</id>
    <published>2017-06-06T14:15:01.000Z</published>
    <updated>2017-06-14T18:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/posts/4a895cbd/">http://muyunyun.cn/posts/4a895cbd/</a></p></blockquote><p>《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。<br><a id="more"></a></p><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量。</p><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li>分词/词法分析<br>将字符串分解成有意义的代码块，代码块又称词法单元。比如程序<code>var a = 2;</code>会被分解为<code>var、a、=、2、;</code></li><li>解析/语法分析<br>将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。</li><li>代码生成<br>将抽象语法树转换为机器能够识别的指令。</li></ul><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>作用域 分别与编译器、引擎进行配合完成代码的解析</p><ul><li>引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。</li><li>编译器负责语法分析以及生成代码。</li><li>作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。</li></ul><p>对于 <code>var a = 2</code> 这条语句，首先编译器会将其分为两部分，一部分是 <code>var a</code>，一部分是 <code>a = 2</code>。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>对于 <code>var a = 10</code> 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 <code>LHS</code> 查询。 对于 <code>console.log(a)</code> 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 <code>RHS</code> 查询。</p><p>为什么区分 <code>LHS</code> 和 <code>RHS</code> 是一件重要的事情？<br>在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。</p><h2 id="作用域的工作模式"><a href="#作用域的工作模式" class="headerlink" title="作用域的工作模式"></a>作用域的工作模式</h2><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><p>词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="匿名与具名"><a href="#匿名与具名" class="headerlink" title="匿名与具名"></a>匿名与具名</h3><p>对于函数表达式一个最熟悉的场景可能就是回调函数了，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><p>这叫作<code>匿名函数表达式</code>。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。</li><li>如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ul><p>始终给函数表达式命名是一个最佳实践:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 我有名字了</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><h3 id="先有声明还是先有赋值"><a href="#先有声明还是先有赋值" class="headerlink" title="先有声明还是先有赋值"></a>先有声明还是先有赋值</h3><p>考虑以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p></p><p>考虑另外一段代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure><p></p><p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。</p><p>可以看出，先有声明后有赋值。</p><p>再来看以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这个代码片段经过提升后，实际上会被理解为以下形式:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"></div><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个<code>函数声明而不是函数表达式就会赋值</code>)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>之前写过关于闭包的一篇文章<a href="http://www.cnblogs.com/MuYunyun/p/5930703.html" target="_blank" rel="external">深入浅出JavaScript之闭包(Closure)</a></p><h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>要说明闭包，for 循环是最常见的例子。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。</p><p>它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>还可以对这段代码进行一些改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><h4 id="重返块作用域"><a href="#重返块作用域" class="headerlink" title="重返块作用域"></a>重返块作用域</h4><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">  &#125;, j*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>本质上这是将一个块转换成一个可以被关闭的作用域。</p><p>此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h2><p>之前写过一篇<a href="http://www.cnblogs.com/MuYunyun/p/5932024.html" target="_blank" rel="external">深入浅出JavaScript之this</a>。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>来看下面这段代码的问题：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="string">"awesome"</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span>;</div><div class="line"></div><div class="line">obj.cool();  <span class="comment">// awesome</span></div><div class="line"></div><div class="line">setTimeout( obj.cool, <span class="number">100</span>); <span class="comment">// not awesome</span></div></pre></td></tr></table></figure><p></p><p>obj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引人了一个叫作 this 词法的行为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。</p><p>但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。</p><p>箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"more awesome"</span>);</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// more awesome</span></div></pre></td></tr></table></figure><p></p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。</p><ul><li>默认绑定<ul><li>独立函数调用</li></ul></li><li>隐式绑定<ul><li>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象</li></ul></li><li>显示绑定<ul><li>call/apply</li><li>bind（本质是对call/apply函数的封装 <code>fn.apply( obj, arguments )</code>）</li><li>第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 this</li></ul></li><li>new 绑定<ul><li>JavaScript 中的 new 机制实际上和面向类的语言完全不同</li><li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</li></ul></li></ul><p>书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:</p><ul><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</li><li>函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。</li></ul><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><p>其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。</p><p>使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript中的对象有字面形式（比如<code>var a = { .. }</code>)和构造形式（比如<code>var a = new Array(..)</code>）。字面形式更常用，不过有时候构造形式可以提供更多选择。</p><p>作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>思考一下这个对象：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">  <span class="attr">c</span>: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherArray = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">b</span>: anotherObject, <span class="comment">// 引用，不是复本！</span></div><div class="line">  c: anotherArray, <span class="comment">// 另一个引用！</span></div><div class="line">  d: anotherFunction</div><div class="line">&#125;;</div><div class="line"></div><div class="line">anotherArray.push( myObject )</div></pre></td></tr></table></figure><p></p><p>如何准确地表示 myObject 的复制呢？<br>这里有一个知识点。</p><ul><li>浅复制。复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用。</li><li>深复制。除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。</li></ul><p>对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的复制方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(someObj) )</div></pre></td></tr></table></figure><p></p><p>我认为这种方法就是深复制。相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject );</div><div class="line"></div><div class="line">newObj.a; <span class="comment">// 2</span></div><div class="line">newObj.b === anotherObject; <span class="comment">// true</span></div><div class="line">newObj.c === anotherArray; <span class="comment">// true</span></div><div class="line">newObj.d === anotherFunction; <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。</p><ul><li>类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。</li><li>JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li></ul><h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><p>思考下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.blah = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure><p></p><p>我们如何找出 a 的“祖先”（委托关系）呢？</p><ul><li>方法一：<code>a instanceof Foo; // true</code> (对象 instanceof 函数)</li><li>方法二: <code>Foo.prototype.isPrototypeOf(a); // true</code> (对象 isPrototypeOf 对象)</li><li>方法三: <code>Object.getPrototypeOf(a) === Foo.prototype; // true</code> (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;</li><li>方法四: <code>a.__proto__ == Foo.prototype; // true</code></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</li><li>使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。</li><li>constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。</li></ul><h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p>来看下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">something</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Tell me something good..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">Object</span>.create(foo);</div><div class="line"></div><div class="line">bar.something(); <span class="comment">// Tell me something good...</span></div></pre></td></tr></table></figure><p></p><p>Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。</p><p>Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p><p>此书的第二章第6部分就把<code>面对类和继承</code>和<code>行为委托</code>两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到<code>Object.create()</code>的强大。</p><h3 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h3><p>来看一段 ES6中Class 的例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  render($where)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">      <span class="keyword">this</span>.$elem.css(&#123;</div><div class="line">        <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>，</div><div class="line">        height: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">      &#125;).appendTo($where);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height, label) &#123;</div><div class="line">    <span class="keyword">super</span>(width, height);</div><div class="line">    <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = $(<span class="string">"&lt;button&gt;"</span>).text(<span class="keyword">this</span>.label)</div><div class="line">  &#125;</div><div class="line">  render($where) &#123;</div><div class="line">    <span class="keyword">super</span>($where);</div><div class="line">    <span class="keyword">this</span>.$elem.click(<span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">  onClick(evt) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>除了语法更好看之外，ES6还有以下优点</p><ul><li>基本上不再引用杂乱的 .prototype 了。</li><li>Button 声明时直接 “继承” 了 Widget。</li><li>可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。</li><li>class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。</li><li>可以通过 extends 很自然地扩展对象(子)类型。</li></ul><p>但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。</p><p>这也是本书作者希望我们思考的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/posts/4a895cbd/&quot;&gt;http://muyunyun.cn/posts/4a895cbd/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://muyunyun.cn/categories/JavaScript/"/>
    
    
      <category term="读书笔记" scheme="http://muyunyun.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>hexo摸爬滚打之进阶教程</title>
    <link href="http://muyunyun.cn/posts/f55182c5/"/>
    <id>http://muyunyun.cn/posts/f55182c5/</id>
    <published>2017-05-29T14:01:26.000Z</published>
    <updated>2017-06-13T17:55:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/">http://muyunyun.cn/</a></p></blockquote><p>写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了<a href="https://hexo.io/" target="_blank" rel="external">hexo</a>。本文有以下内容:</p><ul><li>快速实现博客压缩</li><li>文章链接唯一化</li><li>添加酷炫的打赏二维码</li><li>自定义JS和CSS</li><li>添加酷炫的歌单模块以及播放器</li><li>github分支管理博客思路</li><li>秒传图片到七牛云并展现在博客中</li><li>将博客同时部署到github和coding<a id="more"></a></li></ul><h2 id="快速实现博客压缩"><a href="#快速实现博客压缩" class="headerlink" title="快速实现博客压缩"></a>快速实现博客压缩</h2><p>项目压缩也叫<code>代码丑化</code>,分别对html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把images进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。</p><p>蛮多朋友使用了<code>gulp</code>对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="external">hexo-all-minifier</a>，这个模块集成了对html、css、js、image的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">html_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  ignore_error: <span class="literal">false</span></div><div class="line">  exclude:</div><div class="line"></div><div class="line">css_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.css'</span></div><div class="line"></div><div class="line">js_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  mangle: <span class="literal">true</span></div><div class="line">  output:</div><div class="line">  compress:</div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.js'</span></div><div class="line"></div><div class="line">image_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  interlaced: <span class="literal">false</span></div><div class="line">  multipass: <span class="literal">false</span></div><div class="line">  optimizationLevel: <span class="number">2</span></div><div class="line">  pngquant: <span class="literal">false</span></div><div class="line">  progressive: <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h2 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h2><p>也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-abbrlink --save</div></pre></td></tr></table></figure><p>在<code>站点配置文件</code>中查找代码<code>permalink</code>，将其更改为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: posts/:abbrlink/  # “posts/” 可自行更换</div></pre></td></tr></table></figure><p>这里有个知识点：</p><blockquote><p>百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p></blockquote><p>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p><p>然后在<code>站点配置文件</code>中添加如下代码:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># abbrlink config</div><div class="line">abbrlink:</div><div class="line">  alg: crc32  # 算法：crc16(default) and crc32</div><div class="line">  rep: hex    # 进制：dec(default) and hex</div></pre></td></tr></table></figure><p></p><p>可选择模式：</p><ul><li>crc16 &amp; hex</li><li>crc16 &amp; dec</li><li>crc32 &amp; hex</li><li>crc32 &amp; dec</li></ul><h2 id="添加酷炫的打赏二维码"><a href="#添加酷炫的打赏二维码" class="headerlink" title="添加酷炫的打赏二维码"></a>添加酷炫的打赏二维码</h2><p>看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)<br><img src="http://oqhtscus0.bkt.clouddn.com/134f61fc3181e90acfa945aad72a04a6.png-400" alt=""></p><p>实现这个酷炫二维码的流程如下：</p><ul><li>首先，分别获得支付宝和微信的收款码</li><li>接着到<a href="https://www.hotapp.cn/shouqian" target="_blank" rel="external">芝麻二维码</a>里将两张二维码合并</li><li>最后到<a href="http://www.9thws.com/" target="_blank" rel="external">第九工场</a>生成自己喜欢的造型</li></ul><p>讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alipay: <span class="regexp">/pay.png</span></div></pre></td></tr></table></figure><p></p><h3 id="打赏字体不闪动"><a href="#打赏字体不闪动" class="headerlink" title="打赏字体不闪动"></a>打赏字体不闪动</h3><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 注释文字闪动函数</span></div><div class="line"> #wechat:hover p&#123;</div><div class="line">    animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line"> #alipay:hover p&#123;</div><div class="line">   animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure><p></p><h2 id="自定义JS和CSS"><a href="#自定义JS和CSS" class="headerlink" title="自定义JS和CSS"></a>自定义JS和CSS</h2><p>博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的</p><h3 id="添加自定义js样式"><a href="#添加自定义js样式" class="headerlink" title="添加自定义js样式"></a>添加自定义js样式</h3><ul><li>首先把js文件放在<code>\themes\next\source\js\src</code>文件目录下</li><li>然后找到<code>\themes\next\layout</code>目录下的布局文件<code>_layout.swig</code></li><li>把script引用代码加入到该文件中即可</li></ul><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="添加自定义css样式"><a href="#添加自定义css样式" class="headerlink" title="添加自定义css样式"></a>添加自定义css样式</h3><p>添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在<code>\themes\next\source\css\_custom\custom.styl</code>文件中进行样式的添加。</p><h2 id="添加酷炫的歌单模块以及播放器"><a href="#添加酷炫的歌单模块以及播放器" class="headerlink" title="添加酷炫的歌单模块以及播放器"></a>添加酷炫的歌单模块以及播放器</h2><p>这个模块借鉴了@<a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a>。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：<br><img src="http://oqhtscus0.bkt.clouddn.com/502d78856e46095253e59fd11396b2a4.jpg" alt=""><br>核心代码在<code>\themes\next\source\js\src\music\nmlist</code>中，<a href="https://github.com/MuYunyun/MuYunyun.githubio/blob/muyy/themes/next/source/js/src/music/nmlist.js" target="_blank" rel="external">点击看源码</a>，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。</p><p>在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了<code>$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)</code>解决了这个bug。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/73d9f4070b81bbdab8f80db388af4a40.jpg" alt=""></p><p>再接着玩的话，可以给播放器加上歌词的功能。这里有一篇<a href="http://frankorz.com/2016/09/30/Hexo-patch/#歌词" target="_blank" rel="external">相关文章</a>,有机会可以去把玩一番。</p><h2 id="github分支管理博客思路"><a href="#github分支管理博客思路" class="headerlink" title="github分支管理博客思路"></a>github分支管理博客思路</h2><p>有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件push到user.github.io的其他分支。我选择了后者。</p><h3 id="创建muyy-任意-分支"><a href="#创建muyy-任意-分支" class="headerlink" title="创建muyy(任意)分支"></a>创建muyy(任意)分支</h3><p>创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>然后我们再初始化仓库，重新对我们的代码进行版本控制<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p></p><p><code>&lt;server&gt;</code>是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端</p><h3 id="将博客源文件上传至muyy分支"><a href="#将博客源文件上传至muyy分支" class="headerlink" title="将博客源文件上传至muyy分支"></a>将博客源文件上传至muyy分支</h3><p>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/.deploy_git</div><div class="line">/public</div><div class="line">/_config.yml</div></pre></td></tr></table></figure><p></p><p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</p><p>依次执行<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m <span class="string">"..."</span></div><div class="line">git push origin muyy</div></pre></td></tr></table></figure><p></p><h2 id="秒传图片到七牛云并展现在博客中"><a href="#秒传图片到七牛云并展现在博客中" class="headerlink" title="秒传图片到七牛云并展现在博客中"></a>秒传图片到七牛云并展现在博客中</h2><p>在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具<a href="https://github.com/jiwenxing/qiniu-image-tool" target="_blank" rel="external">qiniu-image-tool</a>，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac是基于Alfred的，其windows也有相应版本<a href="http://jverson.com/2017/05/28/qiniu-image-v2/" target="_blank" rel="external">windows版本</a>。</p><p>按照其要求配置好以后，用截图软件截图后，或者本地图片后copy，然后直接按设置好的command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。<br><img src="https://raw.githubusercontent.com/jiwenxing/qiniu-image-tool/master/res/local.gif" alt=""></p><h2 id="将博客同时部署到github和coding"><a href="#将博客同时部署到github和coding" class="headerlink" title="将博客同时部署到github和coding"></a>将博客同时部署到github和coding</h2><p>通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。</p><h3 id="coding上创建一个新项目"><a href="#coding上创建一个新项目" class="headerlink" title="coding上创建一个新项目"></a>coding上创建一个新项目</h3><p>这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面<br><img src="http://oqhtscus0.bkt.clouddn.com/41b27d98189a9164d2b2a47ccbafdbfa.jpg" alt=""></p><h3 id="同步本地hexo到coding上"><a href="#同步本地hexo到coding上" class="headerlink" title="同步本地hexo到coding上"></a>同步本地hexo到coding上</h3><p>把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="external">coding帮助中心</a>,其实和github配置一模一样的。</p><p>本地打开 <code>id_rsa.pub</code> 文件，复制其中全部内容，填写到<code>SSH_RSA公钥</code>key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。</p><p>添加后，在git bash命令输入：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure><p></p><p>如果得到下面提示就表示公钥添加成功了：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Coding.net Tips : [Hello ! You<span class="string">'ve conected to Coding.net by SSH successfully! ]</span></div></pre></td></tr></table></figure><p></p><p>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  message: [message]</div><div class="line">  repo:</div><div class="line">    github: &lt;repository url&gt;,[branch]</div><div class="line">    gitcafe: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure><p></p><p>所以我是这样的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo:</div><div class="line">    github: https:<span class="comment">//github.com/MuYunyun/MuYunyun.github.io.git,master</span></div><div class="line">    coding: git@git.coding.net:muyunyun/muyunyun.git,master</div></pre></td></tr></table></figure><p></p><p>最后使用部署命令就能把博客同步到coding上面：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy -g</div></pre></td></tr></table></figure><p></p><h3 id="pages服务方式部署"><a href="#pages服务方式部署" class="headerlink" title="pages服务方式部署"></a>pages服务方式部署</h3><p>将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了</p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：<br><img src="http://oqhtscus0.bkt.clouddn.com/c2337ab8ed97d0f825703e8ea80a4123.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a></li><li><a href="http://www.vitah.net/posts/20f300cc/" target="_blank" rel="external">Hexo Next主题设置和优化</a></li><li><a href="http://frankorz.com/2016/09/30/Hexo-patch/" target="_blank" rel="external">Hexo 博客补丁</a></li><li><a href="http://www.cduyzh.com/page/3/" target="_blank" rel="external">Water Sister’s Blog</a></li><li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="external">Hexo+NexT主题配置备忘</a></li><li><a href="http://www.cherryblog.site/" target="_blank" rel="external">Cherry’s Blog</a></li><li><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="http://tengj.github.io/2016/03/06/hexo4/" target="_blank" rel="external">将hexo博客同时托管到github和coding</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/&quot;&gt;http://muyunyun.cn/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;。本文有以下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;快速实现博客压缩&lt;/li&gt;&lt;li&gt;文章链接唯一化&lt;/li&gt;&lt;li&gt;添加酷炫的打赏二维码&lt;/li&gt;&lt;li&gt;自定义JS和CSS&lt;/li&gt;&lt;li&gt;添加酷炫的歌单模块以及播放器&lt;/li&gt;&lt;li&gt;github分支管理博客思路&lt;/li&gt;&lt;li&gt;秒传图片到七牛云并展现在博客中&lt;/li&gt;&lt;li&gt;将博客同时部署到github和coding
    
    </summary>
    
      <category term="git" scheme="http://muyunyun.cn/categories/git/"/>
    
    
      <category term="hexo" scheme="http://muyunyun.cn/tags/hexo/"/>
    
      <category term="blog" scheme="http://muyunyun.cn/tags/blog/"/>
    
  </entry>
  
</feed>
