<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>牧之</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://muyunyun.cn/"/>
  <updated>2017-07-02T13:58:04.000Z</updated>
  <id>http://muyunyun.cn/</id>
  
  <author>
    <name>牧云云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 JavaScript 到 TypeScript</title>
    <link href="http://muyunyun.cn/posts/66a54fc2/"/>
    <id>http://muyunyun.cn/posts/66a54fc2/</id>
    <published>2017-07-02T05:40:33.000Z</published>
    <updated>2017-07-02T13:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/5e7b640325806920160f538d7c50f5d7.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/posts/66a54fc2/">http://muyunyun.cn/posts/66a54fc2/</a><br>文中的案例代码已经上传到 <a href="https://github.com/MuYunyun/TypeScript" target="_blank" rel="external">TypeScript</a></p></blockquote><p>TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。<br><a id="more"></a></p><h2 id="TypeScript-简介"><a href="#TypeScript-简介" class="headerlink" title="TypeScript 简介"></a>TypeScript 简介</h2><p>TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/da62039bf146c2ebd615ef1d11a1a808.jpg" alt=""></p><h2 id="使用-TypeScript-的原因"><a href="#使用-TypeScript-的原因" class="headerlink" title="使用 TypeScript 的原因"></a>使用 TypeScript 的原因</h2><p>JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。</p><p>此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。</p><p>对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~)</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><p>一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'muyy'</span></div><div class="line"><span class="keyword">let</span> name2: <span class="built_in">String</span> = <span class="string">'muyy'</span></div></pre></td></tr></table></figure><p></p><h3 id="Boolen-类型"><a href="#Boolen-类型" class="headerlink" title="Boolen 类型"></a>Boolen 类型</h3><p>boolean是 true 或 false 的值，所以 <code>let isBool3: boolean = new Boolean(1)</code> 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> isBool1: <span class="built_in">boolean</span> = <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">number</span>: <span class="built_in">number</span> = <span class="number">10</span>;</div></pre></td></tr></table></figure><h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><p>数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 <code>Array&lt;type&gt;</code> or <code>type[]</code> 语法为数组内的元素指定类型<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr:<span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">let</span> arr2:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> arr3:<span class="built_in">string</span>[] = [<span class="string">"1"</span>,<span class="string">"2"</span>];</div><div class="line"><span class="keyword">let</span> arr4:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">"1"</span>,<span class="string">"2"</span>];</div></pre></td></tr></table></figure><p></p><h3 id="Enums-类型"><a href="#Enums-类型" class="headerlink" title="Enums 类型"></a>Enums 类型</h3><p>列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Role &#123;Employee = <span class="number">3</span>, Manager, Admin&#125;</div><div class="line"><span class="keyword">let</span> role: Role = Role.Employee</div><div class="line"><span class="built_in">console</span>.log(role) <span class="comment">// 3</span></div></pre></td></tr></table></figure><p></p><h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h3><p>any 是默认的类型，其类型的变量允许任何类型的值：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> notSure:<span class="built_in">any</span> = <span class="number">10</span>;</div><div class="line"><span class="keyword">let</span> notSure2:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">"2"</span>,<span class="literal">false</span>];</div></pre></td></tr></table></figure><p></p><h3 id="Void-类型"><a href="#Void-类型" class="headerlink" title="Void 类型"></a>Void 类型</h3><p>JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'My name is muyy'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> add3: <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello TypeScript"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastname?: <span class="built_in">string</span></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(lastname ? firstName + <span class="string">""</span> + lastname : firstName)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> res1 = buildName(<span class="string">"鸣"</span>,<span class="string">"人"</span>); <span class="comment">// 鸣人</span></div><div class="line"><span class="keyword">let</span> res2 = buildName(<span class="string">"鸣"</span>); <span class="comment">// 鸣</span></div><div class="line"><span class="keyword">let</span> res3 = buildName(<span class="string">"鸣"</span>, <span class="string">"人"</span>, <span class="string">"君"</span>); <span class="comment">// Supplied parameters do not match any signature of call target.</span></div></pre></td></tr></table></figure><p></p><p>如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function buildName2(firstName = "鸣", lastName?: string)&#123;</div><div class="line">    console.log(firstName + "" + lastName)</div><div class="line">&#125;</div><div class="line"></div><div class="line">let res4 = buildName2("人"); // undefined人</div><div class="line">let res5 = buildName2(undefined, "人"); // 鸣人</div></pre></td></tr></table></figure><p></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    name:<span class="built_in">string</span>; <span class="comment">// 这个是对后文this.name类型的定义</span></div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    print()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person:Person = <span class="keyword">new</span> Person(<span class="string">'muyy'</span>,<span class="number">23</span>)</div><div class="line"><span class="built_in">console</span>.log(person.print()) <span class="comment">// muyy23</span></div></pre></td></tr></table></figure><p>我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person&#123;</div><div class="line">    <span class="keyword">public</span> name:<span class="built_in">string</span>;  <span class="comment">// public、private、static 是 typescript 中的类访问修饰符</span></div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    tell()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Student <span class="keyword">extends</span> Person&#123;</div><div class="line">    gender:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">gender:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"muyy"</span>,<span class="number">23</span>);</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">    &#125;</div><div class="line">    tell()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age + <span class="keyword">this</span>.gender);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">"male"</span>);</div><div class="line">student.tell();  <span class="comment">// muyy23male</span></div></pre></td></tr></table></figure><p>这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。</p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><p>对于存取器有下面几点需要注意的：<br>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Hello&#123;</div><div class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</div><div class="line">    <span class="keyword">get</span> name(): <span class="built_in">string</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> name(value: <span class="built_in">string</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._name = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">get</span> age(): <span class="built_in">number</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> age(age: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(age&gt;<span class="number">0</span> &amp;&amp; age&lt;<span class="number">100</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"年龄在0-100之间"</span>); <span class="comment">// 年龄在0-100之间</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>._age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> hello = <span class="keyword">new</span> Hello();</div><div class="line">hello.name = <span class="string">"muyy"</span>;</div><div class="line">hello.age = <span class="number">23</span></div><div class="line"><span class="built_in">console</span>.log(hello.name); <span class="comment">// muyy</span></div></pre></td></tr></table></figure><p></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> LabelValue&#123;</div><div class="line">    label: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelObj: LabelValue</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(labelObj.label);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myObj = &#123;</div><div class="line">    <span class="string">"label"</span>:<span class="string">"hello Interface"</span></div><div class="line">&#125;;</div><div class="line">printLabel(myObj);</div></pre></td></tr></table></figure><p></p><p>LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。</p><p>另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Person&#123;</div><div class="line">    name?:<span class="built_in">string</span>;</div><div class="line">    age?:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInfo</span>(<span class="params">info:Person</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(info);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> info = &#123;</div><div class="line">    <span class="string">"name"</span>:<span class="string">"muyy"</span>,</div><div class="line">    <span class="string">"age"</span>:<span class="number">23</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">printInfo(info); <span class="comment">// &#123;"name": "muyy", "age": 23&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> info2 = &#123;</div><div class="line">    <span class="string">"name"</span>:<span class="string">"muyy"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">printInfo(info2); <span class="comment">// &#123;"name": "muyy"&#125;</span></div></pre></td></tr></table></figure><p></p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> SearchFunc&#123;</div><div class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> mySearch: SearchFunc;</div><div class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>,subString: <span class="built_in">string</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(mySearch(<span class="string">"鸣人"</span>,<span class="string">"鸣"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(mySearch(<span class="string">"鸣人"</span>,<span class="string">"缨"</span>)); <span class="comment">// false</span></div></pre></td></tr></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> StringArray&#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> MyArray: StringArray;</div><div class="line">MyArray = [<span class="string">"是"</span>,<span class="string">"云"</span>,<span class="string">"随"</span>,<span class="string">"风"</span>];</div><div class="line"><span class="built_in">console</span>.log(MyArray[<span class="number">2</span>]); <span class="comment">// 随</span></div></pre></td></tr></table></figure><p></p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><p>我们可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface&#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface&#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    setTime(d: <span class="built_in">Date</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.currentTime = d;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape&#123;</div><div class="line">    color: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> PenStroke&#123;</div><div class="line">    penWidth: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape,PenStroke&#123;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> s = &lt;Square&gt;&#123;&#125;;</div><div class="line">s.color = <span class="string">"blue"</span>;</div><div class="line">s.penWidth = <span class="number">100</span>;</div><div class="line">s.sideLength = <span class="number">10</span>;</div></pre></td></tr></table></figure><p></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator&#123;</div><div class="line">    isAcceptable(s:<span class="built_in">string</span>): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> strReg = <span class="regexp">/^[A-Za-z]+$/</span>;</div><div class="line"><span class="keyword">var</span> numReg = <span class="regexp">/^[0-9]+$/</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> letterValidator <span class="keyword">implements</span> StringValidator&#123;</div><div class="line">    isAcceptable(s:<span class="built_in">string</span>): <span class="built_in">boolean</span>&#123;</div><div class="line">        <span class="keyword">return</span> strReg.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> zipCode <span class="keyword">implements</span> StringValidator&#123;</div><div class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>&#123;</div><div class="line">        <span class="keyword">return</span> s.length == <span class="number">5</span> &amp;&amp; numReg.test(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><h3 id="初探泛型"><a href="#初探泛型" class="headerlink" title="初探泛型"></a>初探泛型</h3><p>如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 <code>output</code> 和 <code>output2</code> 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：<br></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> outPut = Hello&lt;<span class="built_in">string</span>&gt;(<span class="string">'Hello Generic'</span>);</div><div class="line"><span class="keyword">let</span> output2 = Hello(<span class="string">'Hello Generic'</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(outPut);</div><div class="line"><span class="built_in">console</span>.log(outPut2);</div></pre></td></tr></table></figure><p></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.gitbook.com/book/zhongsp/typescript-handbook/details" target="_blank" rel="external">TypeScript 中文文档</a></li><li><a href="http://pinggod.com/2016/Typescript/" target="_blank" rel="external">TypeScript</a></li><li><a href="http://naywinmyint.com/typescript-for-angular-2-part-1/" target="_blank" rel="external">TypeScript for Angular 2 - Part 1 (An Introduction)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/5e7b640325806920160f538d7c50f5d7.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/posts/66a54fc2/&quot;&gt;http://muyunyun.cn/posts/66a54fc2/&lt;/a&gt;&lt;br&gt;文中的案例代码已经上传到 &lt;a href=&quot;https://github.com/MuYunyun/TypeScript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TypeScript&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。&lt;br&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://muyunyun.cn/categories/TypeScript/"/>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://muyunyun.cn/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>React 在服务端渲染的实现</title>
    <link href="http://muyunyun.cn/posts/2d678a6/"/>
    <id>http://muyunyun.cn/posts/2d678a6/</id>
    <published>2017-07-01T07:41:05.000Z</published>
    <updated>2017-07-02T05:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/f82f7765b1171459d9fa593df836c658.jpg-muyy" alt=""></p><blockquote><ul><li>原文地址：<a href="https://css-tricks.com/server-side-react-rendering/" target="_blank" rel="external">Server-Side React Rendering</a></li></ul></blockquote><p>React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？<br><a id="more"></a></p><h2 id="React-在服务端渲染的实现"><a href="#React-在服务端渲染的实现" class="headerlink" title="React 在服务端渲染的实现"></a>React 在服务端渲染的实现</h2><p>假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？</p><p>您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。</p><p>在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。<br>在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。</p><h2 id="服务端渲染的优势"><a href="#服务端渲染的优势" class="headerlink" title="服务端渲染的优势"></a>服务端渲染的优势</h2><p>可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。</p><p>更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了<a href="https://github.com/ButterCMS/react-ssr-example/releases/tag/starter-code" target="_blank" rel="external">相关代码</a>，您可以在其中看到完整的示例。</p><p>提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 <a href="https://buttercms.com/" target="_blank" rel="external">ButterCMS</a> 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以<a href="https://buttercms.com/home/" target="_blank" rel="external">使用你的 GitHub 账号登入 ButterCMS</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Butter <span class="keyword">from</span> <span class="string">'buttercms'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> butter = Butter(<span class="string">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">loaded</span>: <span class="literal">false</span>&#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">componentWillMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    butter.post.list().then(<span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">loaded</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">resp</span>: resp.data</div><div class="line">      &#125;)</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.loaded) &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">          &#123;this.state.resp.data.map((post) =&gt; &#123;</div><div class="line">            return (</div><div class="line">              &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;/div&gt;</div><div class="line">            )</div><div class="line">          &#125;)&#125;</div><div class="line">        &lt;/div&gt;</div><div class="line">      );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> &lt;div&gt;Loading...&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Hello;</div></pre></td></tr></table></figure><p>启动器代码中包含以下内容：</p><ul><li>package.json - 依赖项</li><li>Webpack 和 Babel 配置</li><li>index.html - app 的 HTML 文件</li><li>index.js - 加载 React 并渲染 Hello 组件</li></ul><p>要使应用运行，请先克隆资源库：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">git</span></span> clone ...</div><div class="line"><span class="function"><span class="title">cd</span></span> ..</div></pre></td></tr></table></figure><p>安装依赖:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span></div></pre></td></tr></table></figure><p>然后启动服务器:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">run</span><span class="bash"> start</span></div></pre></td></tr></table></figure><p>浏览器输入 <a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a> 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：<code>&quot;start&quot;: webpack-dev-server --watch</code>)</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358286/localhost_r84tot.png" alt=""></p><p>如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取:</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358332/some-html_mrmpfj.png" alt=""></p><h2 id="增加服务器端渲染"><a href="#增加服务器端渲染" class="headerlink" title="增加服务器端渲染"></a>增加服务器端渲染</h2><p>接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看<a href="https://github.com/ButterCMS/react-ssr-example/commit/525c625b0f65489050983ed03b52bb7770ce6b7a" target="_blank" rel="external">GitHub上的差异</a>。</p><p>To get started, we’ll install Express, a Node.js server side application framework:<br>开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install <span class="built_in">express</span> --<span class="built_in">save</span></div></pre></td></tr></table></figure><p>我们要创建一个渲染我们的 React 组件的服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./Hello.js'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="comment">// 把 Hello 组件渲染成 HTML 字符串</span></div><div class="line">  <span class="keyword">const</span> html = ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span>);</span></div><div class="line"></div><div class="line">  // 加载 index.html 的内容</div><div class="line">  fs.readFile('./index.html', 'utf8', function (err, data) &#123;</div><div class="line">    if (err) throw err;</div><div class="line"></div><div class="line">    // 把渲染后的 React HTML 插入到 div 中</div><div class="line">    const document = data.replace(/<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;<span class="name">\</span>/<span class="attr">div</span>&gt;</span>/, `<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>$&#123;html&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`);</div><div class="line"></div><div class="line">    // 把响应传回给客户端</div><div class="line">    res.send(document);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const app = express();</div><div class="line"></div><div class="line">// 服务器使用 static 中间件构建 build 路径</div><div class="line">app.use('/build', express.static(path.join(__dirname, 'build')));</div><div class="line"></div><div class="line">// 使用我们的 handleRender 中间件处理服务端请求</div><div class="line">app.get('*', handleRender);</div><div class="line"></div><div class="line">// 启动服务器</div><div class="line">app.listen(3000);</div></pre></td></tr></table></figure><p>让我们分解下程序看看发生了什么事情…</p><p><code>handleRender</code> 函数处理所有请求。在文件顶部导入的 <a href="https://facebook.github.io/react/docs/react-dom-server.html" target="_blank" rel="external">ReactDOMServer 类</a>提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span>);</span></div></pre></td></tr></table></figure><p></p><p>这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">document</span> = data.replace(<span class="regexp">/&lt;div id="app"&gt;&lt;\/div&gt;/</span>,<span class="string">`&lt;div id="app"&gt;<span class="subst">$&#123;html&#125;</span>&lt;/div&gt;`</span>);</div></pre></td></tr></table></figure><p>To start the server, update the start script in package.json and then run npm run start:<br>要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 <code>npm run start</code> :</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"start"</span>: <span class="string">"webpack &amp;&amp; babel-node server.js"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure><p>浏览 <code>http://localhost:3000</code> 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，<br>如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358447/devtools_qx5y1o.png" alt=""></p><p>虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，<a href="https://github.com/facebook/react/issues/1739" target="_blank" rel="external">React repo 有一个 issue</a>，超过 100 条评论讨论了这个问题和各种解决方法。</p><h2 id="在渲染之前获取数据"><a href="#在渲染之前获取数据" class="headerlink" title="在渲染之前获取数据"></a>在渲染之前获取数据</h2><p>要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在<a href="https://github.com/ButterCMS/react-ssr-example/commit/5fdd453e31ab08dfdc8b44261696d4ed89fbb719" target="_blank" rel="external">GitHub上查看完整的差异</a>。</p><p>To move data fetching before rendering, we’ll install react-transmit:<br>要在渲染之前获取数据，我们需安装 <a href="https://github.com/RickWong/react-transmit" target="_blank" rel="external">react-transmit</a>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> react-transmit <span class="comment">--save</span></div></pre></td></tr></table></figure><p>React Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。</p><p>这是我们使用 react-transmit 后的组件的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Butter <span class="keyword">from</span> <span class="string">'buttercms'</span></div><div class="line"><span class="keyword">import</span> Transmit <span class="keyword">from</span> <span class="string">'react-transmit'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> butter = Butter(<span class="string">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Hello = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.posts) &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">          &#123;this.props.posts.data.map((post) =&gt; &#123;</div><div class="line">            return (</div><div class="line">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;post.slug&#125;</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            )</div><div class="line">          &#125;)&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">      );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Transmit.createContainer(Hello, &#123;</div><div class="line">  <span class="comment">// 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错</span></div><div class="line">  initialVariables: &#123;&#125;,</div><div class="line">  <span class="comment">// 定义的方法名将成为 Transmit props 的名称</span></div><div class="line">  fragments: &#123;</div><div class="line">    posts() &#123;</div><div class="line">      <span class="keyword">return</span> butter.post.list().then(<span class="function">(<span class="params">resp</span>) =&gt;</span> resp.data);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>我们已经使用 <code>Transmit.createContainer</code> 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。</p><p>为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 <code>Transmit.renderToString</code> 而不是 <code>ReactDOM.renderToString</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</div><div class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</div><div class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</div><div class="line"><span class="keyword">import</span> Hello <span class="keyword">from</span> <span class="string">'./Hello.js'</span>;</div><div class="line"><span class="keyword">import</span> Transmit <span class="keyword">from</span> <span class="string">'react-transmit'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  Transmit.renderToString(Hello).then(<span class="function">(<span class="params">&#123;reactString, reactData&#125;</span>) =&gt;</span> &#123;</div><div class="line">    fs.readFile(<span class="string">'./index.html'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="built_in">document</span> = data.replace(<span class="regexp">/&lt;div id="app"&gt;&lt;\/div&gt;/</span>, <span class="string">`&lt;div id="app"&gt;<span class="subst">$&#123;reactString&#125;</span>&lt;/div&gt;`</span>);</div><div class="line">      <span class="keyword">const</span> output = Transmit.injectIntoMarkup(<span class="built_in">document</span>, reactData, [<span class="string">'/build/client.js'</span>]);</div><div class="line"></div><div class="line">      res.send(<span class="built_in">document</span>);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="comment">// 服务器使用 static 中间件构建 build 路径</span></div><div class="line">app.use(<span class="string">'/build'</span>, express.static(path.join(__dirname, <span class="string">'build'</span>)));</div><div class="line"></div><div class="line"><span class="comment">// 使用我们的 handleRender 中间件处理服务端请求</span></div><div class="line">app.get(<span class="string">'*'</span>, handleRender);</div><div class="line"></div><div class="line"><span class="comment">// 启动服务器</span></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure><p>重新启动服务器浏览到 <code>http://localhost：3000</code>。查看页面源代码，您将看到该页面现在完全呈现在服务器上！</p><p><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358548/rendered-react_t5neam.png" alt=""></p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 <a href="https://github.com/electrode-io/electrode" target="_blank" rel="external">Electrode</a> 或 <a href="https://github.com/zeit/next.js" target="_blank" rel="external">Next.js</a>。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 <a href="https://github.com/airbnb/hypernova" target="_blank" rel="external">Hypernova</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/f82f7765b1171459d9fa593df836c658.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;原文地址：&lt;a href=&quot;https://css-tricks.com/server-side-react-rendering/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server-Side React Rendering&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="SEO" scheme="http://muyunyun.cn/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>使用 React 全家桶搭建一个后台管理系统</title>
    <link href="http://muyunyun.cn/posts/9bfbdbf4/"/>
    <id>http://muyunyun.cn/posts/9bfbdbf4/</id>
    <published>2017-06-14T17:16:07.000Z</published>
    <updated>2017-07-01T07:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/posts/9bfbdbf4/">http://muyunyun.cn/posts/9bfbdbf4/</a></p></blockquote><p>使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。<br><a id="more"></a></p><h2 id="项目地址以及局部展示"><a href="#项目地址以及局部展示" class="headerlink" title="项目地址以及局部展示"></a>项目地址以及局部展示</h2><ul><li><p><a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">项目地址</a></p></li><li><p>小模块展示：<br><img src="http://files.cnblogs.com/files/MuYunyun/reactSPA.gif" alt=""></p></li><li>redux在项目中的运用demo展示<br><img src="http://files.cnblogs.com/files/MuYunyun/todoList.gif" alt=""></li></ul><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">├── build<span class="selector-class">.js</span>                   项目打包后的文件</div><div class="line">├── config                     webpack配置文件</div><div class="line">│   ├──...</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.dev</span><span class="selector-class">.js</span>   开发环境配置</div><div class="line">│   ├──webpack<span class="selector-class">.config</span><span class="selector-class">.prod</span><span class="selector-class">.js</span>  生产环境配置</div><div class="line">├── node_modules               node模块目录</div><div class="line">├── public</div><div class="line">│   └──index<span class="selector-class">.html</span></div><div class="line">├── scripts</div><div class="line">│   ├── build<span class="selector-class">.js</span>               打包项目文件</div><div class="line">│   ├── start<span class="selector-class">.js</span>               启动项目文件</div><div class="line">│   └── test<span class="selector-class">.js</span>                测试项目文件</div><div class="line">├── src</div><div class="line">│   ├── client                 汇聚(入口)目录</div><div class="line">│   ├── common                 核心目录</div><div class="line">│   │   ├── actions            redux中的action</div><div class="line">│   │   ├── components         通用功能组件</div><div class="line">│   │   ├── container          通用样式组件</div><div class="line">│   │   ├── images</div><div class="line">│   │   ├── pages              页面模块</div><div class="line">│   │   ├── reducers           redux中的reducer</div><div class="line">│   │   ├── utils              工具类</div><div class="line">│   │   │   ├── config<span class="selector-class">.js</span>      通用配置</div><div class="line">│   │   │   ├── <span class="selector-tag">menu</span><span class="selector-class">.js</span>        菜单配置</div><div class="line">│   │   │   └── ajax<span class="selector-class">.js</span>        ajax模块(日后用到)</div><div class="line">│   │   └── routes<span class="selector-class">.js</span>          前端路由</div><div class="line">│   └── server                 服务端目录(日后用到)</div><div class="line">│       └── controller</div><div class="line">├── <span class="selector-class">.gitignore</span></div><div class="line">├── package<span class="selector-class">.json</span></div><div class="line">├── README<span class="selector-class">.md</span></div><div class="line">└── yarn.lock</div></pre></td></tr></table></figure><p>项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。</p><p>下面对目录结构作以下说明</p><ul><li>项目最初始是用 <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">create-react-app</a> 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;</li><li>client 作为入口目录，到时候可以把第三方中间件也放在此处;</li><li>container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">container</th><th style="text-align:center">component</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">如何工作(数据获取,状态更新)</td><td style="text-align:center">如何显示(样式，布局)</td></tr><tr><td style="text-align:center">是否在 Redux 数据流中</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">读取数据</td><td style="text-align:center">从 Redux 获取 state</td><td style="text-align:center">从 props 获取数据</td></tr><tr><td style="text-align:center">修改数据</td><td style="text-align:center">向 Redux 派发 actions</td><td style="text-align:center">从 props 调用回调函数</td></tr><tr><td style="text-align:center">实现方式</td><td style="text-align:center">向react-redux生成</td><td style="text-align:center">手写</td></tr></tbody></table><ul><li>ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。</li><li>server 层就是作为网关层，日后计划用来写 node 的。</li></ul><h2 id="技术栈相关"><a href="#技术栈相关" class="headerlink" title="技术栈相关"></a>技术栈相关</h2><p>虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;</p><h3 id="webpack-2-x"><a href="#webpack-2-x" class="headerlink" title="webpack(2.x)"></a>webpack(2.x)</h3><p>4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。</p><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="external">babel-plugin-import</a> 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        <span class="attr">include</span>: paths.appSrc,</div><div class="line">        <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'babel-loader'</span>),</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">          <span class="attr">plugins</span>: [</div><div class="line">            <span class="string">"transform-decorators-legacy"</span>,  <span class="comment">// 引人 ES7 的装饰器 @</span></div><div class="line">            [<span class="string">'import'</span>, [&#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;]],</div><div class="line">          ],</div><div class="line">          <span class="attr">cacheDirectory</span>: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">      &#125;,</div></pre></td></tr></table></figure><p></p><h4 id="引人less"><a href="#引人less" class="headerlink" title="引人less"></a>引人less</h4><p>首先引人 <a href="https://github.com/webpack-contrib/less-loader" target="_blank" rel="external">less-loader</a> 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  test: <span class="regexp">/\.less$/</span>,</div><div class="line">  <span class="attr">use</span>: [</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'style-loader'</span>),</div><div class="line">    <span class="built_in">require</span>.resolve(<span class="string">'css-loader'</span>),</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">ident</span>: <span class="string">'postcss'</span>, <span class="comment">//https://webpack.js.org/guides/migrating/#complex-options</span></div><div class="line">        plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</div><div class="line">          <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</div><div class="line">          autoprefixer(&#123;</div><div class="line">            <span class="attr">browsers</span>: [</div><div class="line">              <span class="string">'&gt;1%'</span>,</div><div class="line">              <span class="string">'last 4 versions'</span>,</div><div class="line">              <span class="string">'Firefox ESR'</span>,</div><div class="line">              <span class="string">'not ie &lt; 9'</span>, <span class="comment">// React doesn't support IE8 anyway</span></div><div class="line">            ],</div><div class="line">            <span class="attr">flexbox</span>: <span class="string">'no-2009'</span>,</div><div class="line">          &#125;),</div><div class="line">        ],</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">loader</span>: <span class="built_in">require</span>.resolve(<span class="string">'less-loader'</span>),</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">modifyVars</span>: &#123; <span class="string">"@primary-color"</span>: <span class="string">"#1DA57A"</span> &#125;,  <span class="comment">// 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。</span></div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  ],</div><div class="line">&#125;,</div></pre></td></tr></table></figure><p></p><h4 id="一键发布到-gh-pages"><a href="#一键发布到-gh-pages" class="headerlink" title="一键发布到 gh-pages"></a>一键发布到 gh-pages</h4><p>用到了 <a href="https://github.com/tschaub/gh-pages" target="_blank" rel="external">gh-pages</a> ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。</p><h4 id="引用路径的缩写"><a href="#引用路径的缩写" class="headerlink" title="引用路径的缩写"></a>引用路径的缩写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">alias: &#123;</div><div class="line">      <span class="string">'react-native'</span>: <span class="string">'react-native-web'</span>,</div><div class="line">      <span class="attr">components</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/components'</span>,</div><div class="line">      <span class="attr">container</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/container'</span>,</div><div class="line">      <span class="attr">images</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/images'</span>,</div><div class="line">      <span class="attr">pages</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/pages'</span>,</div><div class="line">      <span class="attr">utils</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/utils'</span>,</div><div class="line">      <span class="attr">data</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/server/data'</span>,</div><div class="line">      <span class="attr">actions</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/actions'</span>,</div><div class="line">      <span class="attr">reducers</span>: path.resolve(__dirname, <span class="string">'..'</span>) + <span class="string">'/src/common/reducers'</span>,</div><div class="line">    &#125;,</div></pre></td></tr></table></figure><p>配置了引用路径的缩写后，就可以在任意地方如这样引用，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Table <span class="keyword">from</span> <span class="string">'components/table'</span></div></pre></td></tr></table></figure><p></p><h3 id="Antd-2-x"><a href="#Antd-2-x" class="headerlink" title="Antd(2.x)"></a>Antd(2.x)</h3><p>antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的<a href="https://ant.design/docs/spec/introduce-cn" target="_blank" rel="external">设计理念</a>也学到了很多关于UI、UX的知识。<br>该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。</p><h3 id="React-router-4-x"><a href="#React-router-4-x" class="headerlink" title="React-router(4.x)"></a>React-router(4.x)</h3><p>react-router 4.x和2.x的差异又是特别的大，召唤<a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="external">文档</a>,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。</p><p>2.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/aaaa"</span> <span class="attr">component</span>=<span class="string">&#123;AAAA&#125;</span> /&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">"/bbbb"</span> <span class="attr">component</span>=<span class="string">&#123;BBBB&#125;</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>4.x:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</div><div class="line">&lt;Route path="/aaaa" component=&#123;AAAA&#125; /&gt;</div><div class="line">&lt;Route path="/bbbb" component=&#123;BBBB&#125; /&gt;</div></pre></td></tr></table></figure><p></p><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>fetch 使用比较简单，基本的 promise 用法如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetch(url).then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</div><div class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</div><div class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e))</div></pre></td></tr></table></figure><p></p><p>此外还能这样用<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</div><div class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.json();</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Oops, error"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 <a href="https://www.npmjs.com/package/fetch-jsonp" target="_blank" rel="external">fetch-jsonp</a> 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetchJsonp(url,&#123;<span class="attr">method</span>: <span class="string">'GET'</span>&#125;)</div><div class="line">　　.then(<span class="function">(<span class="params">res</span>) =&gt;</span>res.json())</div><div class="line">　　.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;&#125;)</div></pre></td></tr></table></figure><p></p><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/a40c3540ca26a56b28506d14125c04c1.jpg-400" alt=""></p><p>画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇<a href="http://www.cnblogs.com/MuYunyun/p/6530715.html" target="_blank" rel="external">深入Redux架构</a></p><p>下面通过把 <a href="https://github.com/MuYunyun/todoList" target="_blank" rel="external">代办事项</a> 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。</p><p>首先，在入口目录创建 store<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = createStore(rootReducer)</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    &#123; routes &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">);</div></pre></td></tr></table></figure><p></p><p>接着，我使用了 <a href="https://github.com/acdlite/redux-actions" target="_blank" rel="external">redux-actions</a> 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。</p><p>代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = createAction(<span class="string">'SET_VISIBILITY'</span>)</div></pre></td></tr></table></figure><p></p><p>没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">type</span>: <span class="string">"SET_VISIBILITY"</span>,</div><div class="line">		filter</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>相应的代办事项的 reducers 文件片段:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> setVisibility = handleActions(&#123;</div><div class="line">  <span class="string">'SET_VISIBILITY'</span>(state, action) &#123;</div><div class="line">    <span class="keyword">return</span> &#123; ...state, ...action.payload&#125;</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="string">'SHOW_ALL'</span>)</div></pre></td></tr></table></figure><p></p><p>使用 redux-actions 后，只要进行如下调用,reducers文件里的<code>SET_VISIBILITY</code>的 action 就能捕获到<code>SHOW_ALL</code>这个状态。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; setVisibility &#125; <span class="keyword">from</span> <span class="string">'actions/todoList'</span></div><div class="line">@connect(</div><div class="line">    <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</div><div class="line">        <span class="attr">setVisibility</span>: state.setVisibility, <span class="comment">// 这个 setVisibility 是取自 reducers 的</span></div><div class="line">    &#125;)</div><div class="line">)</div><div class="line"></div><div class="line">dispatch(<span class="keyword">this</span>.props.dispatch(setVisibility(<span class="string">'SHOW_ALL'</span>)))</div></pre></td></tr></table></figure><p></p><p>connect 来自 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">react-redux</a>，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>。</p><h2 id="项目的一些扩展计划"><a href="#项目的一些扩展计划" class="headerlink" title="项目的一些扩展计划"></a>项目的一些扩展计划</h2><p>计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，<a href="https://github.com/MuYunyun/reactSPA" target="_blank" rel="external">点我 Star</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/007a8b596b798249ed85d11307c959cb.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/posts/9bfbdbf4/&quot;&gt;http://muyunyun.cn/posts/9bfbdbf4/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="Redux" scheme="http://muyunyun.cn/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-你不知道的 JavaScript (上)</title>
    <link href="http://muyunyun.cn/posts/4a895cbd/"/>
    <id>http://muyunyun.cn/posts/4a895cbd/</id>
    <published>2017-06-06T14:15:01.000Z</published>
    <updated>2017-07-01T07:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/posts/4a895cbd/">http://muyunyun.cn/posts/4a895cbd/</a></p></blockquote><p>《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。<br><a id="more"></a></p><h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量。</p><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li>分词/词法分析<br>将字符串分解成有意义的代码块，代码块又称词法单元。比如程序<code>var a = 2;</code>会被分解为<code>var、a、=、2、;</code></li><li>解析/语法分析<br>将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。</li><li>代码生成<br>将抽象语法树转换为机器能够识别的指令。</li></ul><h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>作用域 分别与编译器、引擎进行配合完成代码的解析</p><ul><li>引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。</li><li>编译器负责语法分析以及生成代码。</li><li>作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。</li></ul><p>对于 <code>var a = 2</code> 这条语句，首先编译器会将其分为两部分，一部分是 <code>var a</code>，一部分是 <code>a = 2</code>。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>对于 <code>var a = 10</code> 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 <code>LHS</code> 查询。 对于 <code>console.log(a)</code> 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 <code>RHS</code> 查询。</p><p>为什么区分 <code>LHS</code> 和 <code>RHS</code> 是一件重要的事情？<br>在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。</p><h2 id="作用域的工作模式"><a href="#作用域的工作模式" class="headerlink" title="作用域的工作模式"></a>作用域的工作模式</h2><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><p>词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。</p><h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  foo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line"></div><div class="line">bar()</div></pre></td></tr></table></figure><p></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="匿名与具名"><a href="#匿名与具名" class="headerlink" title="匿名与具名"></a>匿名与具名</h3><p>对于函数表达式一个最熟悉的场景可能就是回调函数了，比如<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><p>这叫作<code>匿名函数表达式</code>。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。</li><li>如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ul><p>始终给函数表达式命名是一个最佳实践:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timeoutHandler</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 我有名字了</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"I waited 1 second!"</span>)</div><div class="line">&#125;, <span class="number">1000</span> )</div></pre></td></tr></table></figure><p></p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><h3 id="先有声明还是先有赋值"><a href="#先有声明还是先有赋值" class="headerlink" title="先有声明还是先有赋值"></a>先有声明还是先有赋值</h3><p>考虑以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></div></pre></td></tr></table></figure><p></p><p>考虑另外一段代码<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure><p></p><p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。</p><p>可以看出，先有声明后有赋值。</p><p>再来看以下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这个代码片段经过提升后，实际上会被理解为以下形式:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo;</div><div class="line"></div><div class="line">foo();  <span class="comment">// TypeError</span></div><div class="line">bar();  <span class="comment">// ReferenceError</span></div><div class="line"></div><div class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bar = ...self...</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p></p><p>这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个<code>函数声明而不是函数表达式就会赋值</code>)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>之前写过关于闭包的一篇文章<a href="http://www.cnblogs.com/MuYunyun/p/5930703.html" target="_blank" rel="external">深入浅出JavaScript之闭包(Closure)</a></p><h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>要说明闭包，for 循环是最常见的例子。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。</p><p>它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> j = i;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>还可以对这段代码进行一些改进：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, j*<span class="number">1000</span> )</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p><h4 id="重返块作用域"><a href="#重返块作用域" class="headerlink" title="重返块作用域"></a>重返块作用域</h4><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="keyword">let</span> j = i;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(j);</div><div class="line">  &#125;, j*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>本质上这是将一个块转换成一个可以被关闭的作用域。</p><p>此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i*<span class="number">1000</span> )</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h2><p>之前写过一篇<a href="http://www.cnblogs.com/MuYunyun/p/5932024.html" target="_blank" rel="external">深入浅出JavaScript之this</a>。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><h3 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h3><p>来看下面这段代码的问题：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="string">"awesome"</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> id = <span class="string">"not awesome"</span>;</div><div class="line"></div><div class="line">obj.cool();  <span class="comment">// awesome</span></div><div class="line"></div><div class="line">setTimeout( obj.cool, <span class="number">100</span>); <span class="comment">// not awesome</span></div></pre></td></tr></table></figure><p></p><p>obj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (self.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        self.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p><p>ES6 中的箭头函数引人了一个叫作 this 词法的行为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"awesome?"</span>);</div><div class="line">      &#125;, <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// awesome?</span></div></pre></td></tr></table></figure><p></p><p>箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。</p><p>但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。</p><p>箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">count</span>: <span class="number">0</span>,</div><div class="line">  <span class="attr">cool</span>: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt; <span class="number">1</span>) &#123;</div><div class="line">      setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">this</span>.count++;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"more awesome"</span>);</div><div class="line">      &#125;.bind( <span class="keyword">this</span> ), <span class="number">100</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.cool(); <span class="comment">// more awesome</span></div></pre></td></tr></table></figure><p></p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。</p><ul><li>默认绑定<ul><li>独立函数调用</li></ul></li><li>隐式绑定<ul><li>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象</li></ul></li><li>显示绑定<ul><li>call/apply</li><li>bind（本质是对call/apply函数的封装 <code>fn.apply( obj, arguments )</code>）</li><li>第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 this</li></ul></li><li>new 绑定<ul><li>JavaScript 中的 new 机制实际上和面向类的语言完全不同</li><li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</li></ul></li></ul><p>书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:</p><ul><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</li><li>函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li><li>如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。</li></ul><h3 id="被忽略的-this"><a href="#被忽略的-this" class="headerlink" title="被忽略的 this"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( <span class="literal">null</span>, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><p>其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。</p><p>使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"a:"</span> + a + <span class="string">", b:"</span> + b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line"><span class="comment">// 把数组"展开"成参数</span></div><div class="line">foo.apply( ø, [<span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// a:2, b:3</span></div><div class="line"></div><div class="line"><span class="comment">// 使用 bind(..) 进行柯里化</span></div><div class="line"><span class="keyword">var</span> bar = foo.bind( ø, <span class="number">2</span>);</div><div class="line">bar(<span class="number">3</span>); <span class="comment">// a:2, b:3</span></div></pre></td></tr></table></figure><p></p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript中的对象有字面形式（比如<code>var a = { .. }</code>)和构造形式（比如<code>var a = new Array(..)</code>）。字面形式更常用，不过有时候构造形式可以提供更多选择。</p><p>作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>思考一下这个对象：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherFunction</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*..*/</span> &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherObject = &#123;</div><div class="line">  <span class="attr">c</span>: <span class="literal">true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherArray = [];</div><div class="line"></div><div class="line"><span class="keyword">var</span> myObject = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">b</span>: anotherObject, <span class="comment">// 引用，不是复本！</span></div><div class="line">  c: anotherArray, <span class="comment">// 另一个引用！</span></div><div class="line">  d: anotherFunction</div><div class="line">&#125;;</div><div class="line"></div><div class="line">anotherArray.push( myObject )</div></pre></td></tr></table></figure><p></p><p>如何准确地表示 myObject 的复制呢？<br>这里有一个知识点。</p><ul><li>浅复制。复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是 2，但是新对象中 b、c、d 三个属性其实只是三个引用。</li><li>深复制。除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。</li></ul><p>对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的复制方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(someObj) )</div></pre></td></tr></table></figure><p></p><p>我认为这种方法就是深复制。相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject );</div><div class="line"></div><div class="line">newObj.a; <span class="comment">// 2</span></div><div class="line">newObj.b === anotherObject; <span class="comment">// true</span></div><div class="line">newObj.c === anotherArray; <span class="comment">// true</span></div><div class="line">newObj.d === anotherFunction; <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。</p><ul><li>类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。</li><li>JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li></ul><h3 id="检查“类”关系"><a href="#检查“类”关系" class="headerlink" title="检查“类”关系"></a>检查“类”关系</h3><p>思考下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.blah = ...;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure><p></p><p>我们如何找出 a 的“祖先”（委托关系）呢？</p><ul><li>方法一：<code>a instanceof Foo; // true</code> (对象 instanceof 函数)</li><li>方法二: <code>Foo.prototype.isPrototypeOf(a); // true</code> (对象 isPrototypeOf 对象)</li><li>方法三: <code>Object.getPrototypeOf(a) === Foo.prototype; // true</code> (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;</li><li>方法四: <code>a.__proto__ == Foo.prototype; // true</code></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</li><li>使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。</li><li>constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。</li></ul><h3 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h3><p>来看下面的代码：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">  <span class="attr">something</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Tell me something good..."</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="built_in">Object</span>.create(foo);</div><div class="line"></div><div class="line">bar.something(); <span class="comment">// Tell me something good...</span></div></pre></td></tr></table></figure><p></p><p>Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。</p><p>Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p><p>此书的第二章第6部分就把<code>面对类和继承</code>和<code>行为委托</code>两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到<code>Object.create()</code>的强大。</p><h3 id="ES6中的Class"><a href="#ES6中的Class" class="headerlink" title="ES6中的Class"></a>ES6中的Class</h3><p>来看一段 ES6中Class 的例子<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height) &#123;</div><div class="line">    <span class="keyword">this</span>.width = width || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.height = height || <span class="number">50</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">  render($where)&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</div><div class="line">      <span class="keyword">this</span>.$elem.css(&#123;</div><div class="line">        <span class="attr">width</span>: <span class="keyword">this</span>.width + <span class="string">"px"</span>，</div><div class="line">        height: <span class="keyword">this</span>.height + <span class="string">"px"</span></div><div class="line">      &#125;).appendTo($where);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(width, height, label) &#123;</div><div class="line">    <span class="keyword">super</span>(width, height);</div><div class="line">    <span class="keyword">this</span>.label = label || <span class="string">"Default"</span>;</div><div class="line">    <span class="keyword">this</span>.$elem = $(<span class="string">"&lt;button&gt;"</span>).text(<span class="keyword">this</span>.label)</div><div class="line">  &#125;</div><div class="line">  render($where) &#123;</div><div class="line">    <span class="keyword">super</span>($where);</div><div class="line">    <span class="keyword">this</span>.$elem.click(<span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line">  onClick(evt) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Button '"</span> + <span class="keyword">this</span>.label + <span class="string">"' clicked!"</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>除了语法更好看之外，ES6还有以下优点</p><ul><li>基本上不再引用杂乱的 .prototype 了。</li><li>Button 声明时直接 “继承” 了 Widget。</li><li>可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。</li><li>class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。</li><li>可以通过 extends 很自然地扩展对象(子)类型。</li></ul><p>但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。</p><p>这也是本书作者希望我们思考的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/posts/4a895cbd/&quot;&gt;http://muyunyun.cn/posts/4a895cbd/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://muyunyun.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://muyunyun.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo 摸爬滚打之进阶教程</title>
    <link href="http://muyunyun.cn/posts/f55182c5/"/>
    <id>http://muyunyun.cn/posts/f55182c5/</id>
    <published>2017-05-29T14:01:26.000Z</published>
    <updated>2017-07-01T07:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy" alt=""></p><blockquote><p>本文首发在我的个人博客：<a href="http://muyunyun.cn/">http://muyunyun.cn/</a></p></blockquote><p>写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了<a href="https://hexo.io/" target="_blank" rel="external">hexo</a>。本文有以下内容:</p><ul><li>快速实现博客压缩</li><li>文章链接唯一化</li><li>添加酷炫的打赏二维码</li><li>自定义JS和CSS</li><li>添加酷炫的歌单模块以及播放器</li><li>github分支管理博客思路</li><li>秒传图片到七牛云并展现在博客中</li><li>将博客同时部署到github和coding<a id="more"></a></li></ul><h2 id="快速实现博客压缩"><a href="#快速实现博客压缩" class="headerlink" title="快速实现博客压缩"></a>快速实现博客压缩</h2><p>项目压缩也叫<code>代码丑化</code>,分别对html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把images进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。</p><p>蛮多朋友使用了<code>gulp</code>对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块<a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="external">hexo-all-minifier</a>，这个模块集成了对html、css、js、image的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">html_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  ignore_error: <span class="literal">false</span></div><div class="line">  exclude:</div><div class="line"></div><div class="line">css_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.css'</span></div><div class="line"></div><div class="line">js_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  mangle: <span class="literal">true</span></div><div class="line">  output:</div><div class="line">  compress:</div><div class="line">  exclude:</div><div class="line">    - <span class="string">'*.min.js'</span></div><div class="line"></div><div class="line">image_minifier:</div><div class="line">  enable: <span class="literal">true</span></div><div class="line">  interlaced: <span class="literal">false</span></div><div class="line">  multipass: <span class="literal">false</span></div><div class="line">  optimizationLevel: <span class="number">2</span></div><div class="line">  pngquant: <span class="literal">false</span></div><div class="line">  progressive: <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h2 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h2><p>也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-abbrlink --save</div></pre></td></tr></table></figure><p>在<code>站点配置文件</code>中查找代码<code>permalink</code>，将其更改为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: posts/:abbrlink/  # “posts/” 可自行更换</div></pre></td></tr></table></figure><p>这里有个知识点：</p><blockquote><p>百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p></blockquote><p>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p><p>然后在<code>站点配置文件</code>中添加如下代码:<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># abbrlink config</div><div class="line">abbrlink:</div><div class="line">  alg: crc32  # 算法：crc16(default) and crc32</div><div class="line">  rep: hex    # 进制：dec(default) and hex</div></pre></td></tr></table></figure><p></p><p>可选择模式：</p><ul><li>crc16 &amp; hex</li><li>crc16 &amp; dec</li><li>crc32 &amp; hex</li><li>crc32 &amp; dec</li></ul><h2 id="添加酷炫的打赏二维码"><a href="#添加酷炫的打赏二维码" class="headerlink" title="添加酷炫的打赏二维码"></a>添加酷炫的打赏二维码</h2><p>看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)<br><img src="http://oqhtscus0.bkt.clouddn.com/134f61fc3181e90acfa945aad72a04a6.png-400" alt=""></p><p>实现这个酷炫二维码的流程如下：</p><ul><li>首先，分别获得支付宝和微信的收款码</li><li>接着到<a href="https://www.hotapp.cn/shouqian" target="_blank" rel="external">芝麻二维码</a>里将两张二维码合并</li><li>最后到<a href="http://www.9thws.com/" target="_blank" rel="external">第九工场</a>生成自己喜欢的造型</li></ul><p>讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alipay: <span class="regexp">/pay.png</span></div></pre></td></tr></table></figure><p></p><h3 id="打赏字体不闪动"><a href="#打赏字体不闪动" class="headerlink" title="打赏字体不闪动"></a>打赏字体不闪动</h3><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 注释文字闪动函数</span></div><div class="line"> #wechat:hover p&#123;</div><div class="line">    animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line"> #alipay:hover p&#123;</div><div class="line">   animation: roll 0.1s infinite linear;</div><div class="line">    -webkit-animation: roll 0.1s infinite linear;</div><div class="line">    -moz-animation: roll 0.1s infinite linear;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure><p></p><h2 id="自定义JS和CSS"><a href="#自定义JS和CSS" class="headerlink" title="自定义JS和CSS"></a>自定义JS和CSS</h2><p>博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的</p><h3 id="添加自定义js样式"><a href="#添加自定义js样式" class="headerlink" title="添加自定义js样式"></a>添加自定义js样式</h3><ul><li>首先把js文件放在<code>\themes\next\source\js\src</code>文件目录下</li><li>然后找到<code>\themes\next\layout</code>目录下的布局文件<code>_layout.swig</code></li><li>把script引用代码加入到该文件中即可</li></ul><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;</code></p><h3 id="添加自定义css样式"><a href="#添加自定义css样式" class="headerlink" title="添加自定义css样式"></a>添加自定义css样式</h3><p>添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在<code>\themes\next\source\css\_custom\custom.styl</code>文件中进行样式的添加。</p><h2 id="添加酷炫的歌单模块以及播放器"><a href="#添加酷炫的歌单模块以及播放器" class="headerlink" title="添加酷炫的歌单模块以及播放器"></a>添加酷炫的歌单模块以及播放器</h2><p>这个模块借鉴了@<a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a>。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：<br><img src="http://oqhtscus0.bkt.clouddn.com/502d78856e46095253e59fd11396b2a4.jpg" alt=""><br>核心代码在<code>\themes\next\source\js\src\music\nmlist</code>中，<a href="https://github.com/MuYunyun/MuYunyun.githubio/blob/muyy/themes/next/source/js/src/music/nmlist.js" target="_blank" rel="external">点击看源码</a>，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。</p><p>在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了<code>$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)</code>解决了这个bug。</p><p><img src="http://oqhtscus0.bkt.clouddn.com/73d9f4070b81bbdab8f80db388af4a40.jpg" alt=""></p><p>再接着玩的话，可以给播放器加上歌词的功能。这里有一篇<a href="http://frankorz.com/2016/09/30/Hexo-patch/#歌词" target="_blank" rel="external">相关文章</a>,有机会可以去把玩一番。</p><h2 id="github分支管理博客思路"><a href="#github分支管理博客思路" class="headerlink" title="github分支管理博客思路"></a>github分支管理博客思路</h2><p>有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件push到user.github.io的其他分支。我选择了后者。</p><h3 id="创建muyy-任意-分支"><a href="#创建muyy-任意-分支" class="headerlink" title="创建muyy(任意)分支"></a>创建muyy(任意)分支</h3><p>创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）</p><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>然后我们再初始化仓库，重新对我们的代码进行版本控制<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p></p><p><code>&lt;server&gt;</code>是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端</p><h3 id="将博客源文件上传至muyy分支"><a href="#将博客源文件上传至muyy分支" class="headerlink" title="将博客源文件上传至muyy分支"></a>将博客源文件上传至muyy分支</h3><p>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/.deploy_git</div><div class="line">/public</div><div class="line">/_config.yml</div></pre></td></tr></table></figure><p></p><p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</p><p>依次执行<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m <span class="string">"..."</span></div><div class="line">git push origin muyy</div></pre></td></tr></table></figure><p></p><h2 id="秒传图片到七牛云并展现在博客中"><a href="#秒传图片到七牛云并展现在博客中" class="headerlink" title="秒传图片到七牛云并展现在博客中"></a>秒传图片到七牛云并展现在博客中</h2><p>在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具<a href="https://github.com/jiwenxing/qiniu-image-tool" target="_blank" rel="external">qiniu-image-tool</a>，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac是基于Alfred的，其windows也有相应版本<a href="http://jverson.com/2017/05/28/qiniu-image-v2/" target="_blank" rel="external">windows版本</a>。</p><p>按照其要求配置好以后，用截图软件截图后，或者本地图片后copy，然后直接按设置好的command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。<br><img src="https://raw.githubusercontent.com/jiwenxing/qiniu-image-tool/master/res/local.gif" alt=""></p><h2 id="将博客同时部署到github和coding"><a href="#将博客同时部署到github和coding" class="headerlink" title="将博客同时部署到github和coding"></a>将博客同时部署到github和coding</h2><p>通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。</p><h3 id="coding上创建一个新项目"><a href="#coding上创建一个新项目" class="headerlink" title="coding上创建一个新项目"></a>coding上创建一个新项目</h3><p>这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面<br><img src="http://oqhtscus0.bkt.clouddn.com/41b27d98189a9164d2b2a47ccbafdbfa.jpg" alt=""></p><h3 id="同步本地hexo到coding上"><a href="#同步本地hexo到coding上" class="headerlink" title="同步本地hexo到coding上"></a>同步本地hexo到coding上</h3><p>把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://coding.net/help/doc/git/ssh-key.html" target="_blank" rel="external">coding帮助中心</a>,其实和github配置一模一样的。</p><p>本地打开 <code>id_rsa.pub</code> 文件，复制其中全部内容，填写到<code>SSH_RSA公钥</code>key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。</p><p>添加后，在git bash命令输入：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure><p></p><p>如果得到下面提示就表示公钥添加成功了：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Coding.net Tips : [Hello ! You<span class="string">'ve conected to Coding.net by SSH successfully! ]</span></div></pre></td></tr></table></figure><p></p><p>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  message: [message]</div><div class="line">  repo:</div><div class="line">    github: &lt;repository url&gt;,[branch]</div><div class="line">    gitcafe: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure><p></p><p>所以我是这样的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo:</div><div class="line">    github: https:<span class="comment">//github.com/MuYunyun/MuYunyun.github.io.git,master</span></div><div class="line">    coding: git@git.coding.net:muyunyun/muyunyun.git,master</div></pre></td></tr></table></figure><p></p><p>最后使用部署命令就能把博客同步到coding上面：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy -g</div></pre></td></tr></table></figure><p></p><h3 id="pages服务方式部署"><a href="#pages服务方式部署" class="headerlink" title="pages服务方式部署"></a>pages服务方式部署</h3><p>将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了</p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：<br><img src="http://oqhtscus0.bkt.clouddn.com/c2337ab8ed97d0f825703e8ea80a4123.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.barretlee.com/entry/" target="_blank" rel="external">小胡子哥</a></li><li><a href="http://www.vitah.net/posts/20f300cc/" target="_blank" rel="external">Hexo Next主题设置和优化</a></li><li><a href="http://frankorz.com/2016/09/30/Hexo-patch/" target="_blank" rel="external">Hexo 博客补丁</a></li><li><a href="http://www.cduyzh.com/page/3/" target="_blank" rel="external">Water Sister’s Blog</a></li><li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="external">Hexo+NexT主题配置备忘</a></li><li><a href="http://www.cherryblog.site/" target="_blank" rel="external">Cherry’s Blog</a></li><li><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="http://tengj.github.io/2016/03/06/hexo4/" target="_blank" rel="external">将hexo博客同时托管到github和coding</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqhtscus0.bkt.clouddn.com/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文首发在我的个人博客：&lt;a href=&quot;http://muyunyun.cn/&quot;&gt;http://muyunyun.cn/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo&lt;/a&gt;。本文有以下内容:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;快速实现博客压缩&lt;/li&gt;&lt;li&gt;文章链接唯一化&lt;/li&gt;&lt;li&gt;添加酷炫的打赏二维码&lt;/li&gt;&lt;li&gt;自定义JS和CSS&lt;/li&gt;&lt;li&gt;添加酷炫的歌单模块以及播放器&lt;/li&gt;&lt;li&gt;github分支管理博客思路&lt;/li&gt;&lt;li&gt;秒传图片到七牛云并展现在博客中&lt;/li&gt;&lt;li&gt;将博客同时部署到github和coding
    
    </summary>
    
      <category term="git" scheme="http://muyunyun.cn/categories/git/"/>
    
    
      <category term="hexo" scheme="http://muyunyun.cn/tags/hexo/"/>
    
      <category term="blog" scheme="http://muyunyun.cn/tags/blog/"/>
    
  </entry>
  
</feed>
